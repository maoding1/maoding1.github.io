<!-- build time:Mon Sep 16 2024 22:54:49 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><meta name="referrer" content="http://localhost:4000/"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="MikeMao's blog" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="MikeMao's blog" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="MikeMao's blog" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C++ 读书笔记"><link rel="canonical" href="http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><title>Efective Modern C++读书笔记 - C++ | MikeMao's blog = MikeMao's blog = 风烟俱净，天山共色 从流飘荡，任意东西</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Efective Modern C++读书笔记</h1><div class="meta"><span class="item" title="创建时间：2024-08-31 20:44:57"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-08-31T20:44:57+08:00">2024-08-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">MikeMao's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1gicitspjpbj20zk0m81ky.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="MikeMao"><meta itemprop="description" content="风烟俱净，天山共色 从流飘荡，任意东西, a student of NJU && record learning experience"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="MikeMao's blog"></span><div class="body md" itemprop="articleBody"><p>本书主要设计 C++11/14 的新语言特性，Modern C++ 带来的各种改变是亡羊补牢，还是脱胎换骨，通过阅读本书可能会得到答案。</p><p>看书是一件乐趣，写读书笔记可不是😢。但是就阅读《Efective C++》的经历而言，减慢阅读速度而留下记录是很重要的，不知本篇何时才能完成。</p><p><span id="more"></span></p><h2 id="chapter-1-类型推导"><a class="anchor" href="#chapter-1-类型推导">#</a> chapter 1 类型推导</h2><h3 id="item1-理解模板类型推导"><a class="anchor" href="#item1-理解模板类型推导">#</a> item1 理解模板类型推导</h3><p>模板类型推导，是 C++ 一个广泛应用的特性，并且可以被称为一个良好的设计，因为很多程序员都在完全不了解其底层运行机制的情况下，获得了满意的结果。C++ 11 带来了 <code>auto</code> ，模板类型推导也是其运行的基础，一个坏消息是有些时候它的应用并不符合直觉，因此了解模板类型推导的一些细节就有些重要了。</p><p>考虑如下一个函数模板：</p><pre><code class="language-c++">template&lt;typename T&gt;
void f(ParamType param)
</code></pre><p>这里的 ParamType 是与 T 有关的一个类型，比如 <code>const T</code> , <code>T &amp;</code> 等</p><p>对于某一次调用 <code>f(expr)</code> , T 的推导结果会是什么呢，答案是，<strong>既与 expr 的类型有关也和 ParamType 有关</strong>，具体要分为三种情况讨论。</p><h4 id="情况1-paramtype是一个指针或引用但不是一个万能引用"><a class="anchor" href="#情况1-paramtype是一个指针或引用但不是一个万能引用">#</a> 情况 1： ParamType 是一个指针或引用，但不是一个万能引用</h4><p>这种情况下，类型推导会这样运作：</p><ol><li>若 expr 具有引用类型，先将引用部分忽略</li><li>然后，对 <code>expr</code> 的类型和 <code>ParamType</code> 的类型执行模式匹配，来决定 T 的类型。</li></ol><p>for example:</p><pre><code class="language-c++">// 对与如下模式
template&lt;typename T&gt;
void f(T&amp; param) // param 是一个引用

int x = 27;
const int cx = x;
const int&amp; rx = x;

f(x);                           //T是int，param的类型是int&amp;
f(cx);                          //T是const int，param的类型是const int&amp;
f(rx);                          //T是const int，param的类型是const int&amp;

</code></pre><p>这些例子只展示了左值引用，但是类型推导会如左值引用一样对待右值引用。</p><h4 id="情况2-paramtype-是一个万能引用"><a class="anchor" href="#情况2-paramtype-是一个万能引用">#</a> 情况 2： ParamType 是一个万能引用</h4><p>对于使用万能引用形参的模板而言，规则就没那么显明了：</p><ol><li>如果 expr 是左值， <code>T</code> 和 ParamType 都会被推导为左值引用。这个结果又两点比较奇怪：首先，这是在模板类型推导中，T 被推导为引用类型的唯一情形。其次，尽管在声明时使用的是右值引用语法，它的类型推导结果却是左值引用。</li><li>如果 expr 是一个右值，则应用情况 1 中的规则</li></ol><p>例如：</p><pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp;&amp; param);              //param现在是一个通用引用类型
        
int x=27;                       //如之前一样
const int cx=x;                 //如之前一样
const int &amp; rx=cx;              //如之前一样

f(x);                           //x是左值，所以T是int&amp;，
                                //param类型也是int&amp;

f(cx);                          //cx是左值，所以T是const int&amp;，
                                //param类型也是const int&amp;

f(rx);                          //rx是左值，所以T是const int&amp;，
                                //param类型也是const int&amp;

f(27);                          //27是右值，所以T是int，
                                //param类型就是int&amp;&amp;
</code></pre><p>item24 详细解释了为什么这些例子是像这样发生的。这里关键在于通用引用的类型推导规则是不同于普通的左值或者右值引用的。尤其是，当通用引用被使用时，类型推导会区分左值实参和右值实参，但是对非通用引用时不会区分。</p><h3 id="情况3-paramtype既非指针也非引用"><a class="anchor" href="#情况3-paramtype既非指针也非引用">#</a> 情况 3： ParamType 既非指针，也非引用</h3><p>当 <code>ParamType</code> 既非引用也非指针时，我们面对的就是所谓的按值传递了，这意味着无论传入的是什么，param 都会是它的一个副本，即一个全新的对象。具体来说：</p><ol><li>和之前一样，如果 <code>expr</code> 的类型是一个引用，忽略这个引用部分</li><li>如果忽略 <code>expr</code> 的引用性之后，如果 <code>expr</code> 具有 <code>const</code> 或 <code>volatile</code> 属性，都会被忽略。</li></ol><p>例如：</p><pre><code class="language-c++">int x=27;                       //如之前一样
const int cx=x;                 //如之前一样
const int &amp; rx=cx;              //如之前一样

f(x);                           //T和param的类型都是int
f(cx);                          //T和param的类型都是int
f(rx);                          //T和param的类型都是int

</code></pre><p>这是因为根据按值传递的思想， <code>expr</code> 是 const 或者 volatile 不意为着它的拷贝也不能被修改。</p><p>认识到只有在传值给形参时才会忽略 <code>const</code> （和 <code>volatile</code> ）这一点很重要，正如我们看到的，对于 reference-to- <code>const</code> 和 pointer-to- <code>const</code> 形参来说， <code>expr</code> 的常量性在推导时会被保留。但是考虑这样的情况， <code>expr</code> 是一个 <code>const</code> 指针，指向 <code>const</code> 对象， <code>expr</code> 通过传值传递给 <code>param</code> ：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 仍然以传值的方式处理 param</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span>         <span class="token comment">//ptr 是一个常量指针，指向常量对象 </span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">"Fun with pointers"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 传递 const char * const 类型的实参</span></pre></td></tr></table></figure><p>在这里，解引用符号（*）的右边的 <code>const</code> 表示 <code>ptr</code> 本身是一个 <code>const</code> ： <code>ptr</code> 不能被修改为指向其它地址，也不能被设置为 null（解引用符号左边的 <code>const</code> 表示 <code>ptr</code> 指向一个字符串，这个字符串是 <code>const</code> ，因此字符串不能被修改）。当 <code>ptr</code> 作为实参传给 <code>f</code> ，组成这个指针的每一比特都被拷贝进 <code>param</code> 。像这种情况， <code>ptr</code> <strong>自身的值会被传给形参</strong>，根据类型推导的第三条规则， <code>ptr</code> 自身的常量性将会被省略，所以 <code>param</code> 是 <code>const char*</code> ，也就是一个可变指针指向 <code>const</code> 字符串。在类型推导中，这个指针指向的数据的常量性将会被保留，但是当拷贝 <code>ptr</code> 来创造一个新指针 <code>param</code> 时， <code>ptr</code> 自身的常量性将会被忽略。</p><h4 id="数组实参与函数实参"><a class="anchor" href="#数组实参与函数实参">#</a> 数组实参与函数实参</h4><p>在模板类型推导过程中，数组或函数类型的实参会退化成对应的指针，除非它们被用来初始化引用</p><h3 id="item2-理解auto类型推导"><a class="anchor" href="#item2-理解auto类型推导">#</a> item2 理解 auto 类型推导</h3><p>继续使用上一节的这个例子来解释 auto 类型推导是如何和模板类型推导联系在一起的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParmaType param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 使用一些表达式调用 f</span></pre></td></tr></table></figure><p>当变量采用 auto 来声明时，auto 扮演了模板中 T 的角色，变量的类型饰词扮演了 ParamType 的角色。</p><p>比如说：</p><pre><code class="language-c++">auto x = 27;	//类型饰词是auto
const auto cx = x;	//类型饰词是const auto
const auto&amp; rx = x;	//类型饰词是const auto &amp;
</code></pre><p>在这里例子中要推导 x，cx 和 rx 的类型，编译器的行为看起来就像是认为这里每个声明都有一个模板，然后使用合适的初始化表达式进行调用：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 x 的类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                                <span class="token comment">//param 的推导类型是 x 的类型</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 cx 的类型</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_cx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">func_for_cx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                                <span class="token comment">//param 的推导类型是 cx 的类型</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 rx 的类型</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_rx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">func_for_rx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                                <span class="token comment">//param 的推导类型是 rx 的类型</span></pre></td></tr></table></figure><p>除了一个例外，就是使用初始化列表时。</p><p>例如：</p><pre><code class="language-c++">auto x = &#123; 11, 23, 9 &#125;;         //x的类型是std::initializer_list&lt;int&gt;

template&lt;typename T&gt;            //带有与x的声明等价的
void f(T param);                //形参声明的模板

f(&#123; 11, 23, 9 &#125;);               //错误！不能推导出T

</code></pre><p>C++\14 中允许 <code>auto</code> 用户函数返回值，也允许 lambda 函数的形参声明中使用 <code>auto</code> , 但在这些情况下 <code>auto</code> 实际上使用模板类型推导那一套规则在工作，因此下面的代码不会通过编译：</p><pre><code class="language-c++">auto createInitList()
&#123;
    return &#123; 1, 2, 3 &#125;;         //错误！不能推导&#123; 1, 2, 3 &#125;的类型
&#125;

std::vector&lt;int&gt; v;
…
auto resetV = 
    [&amp;v](const auto&amp; newValue)&#123; v = newValue; &#125;;        //C++14
…
resetV(&#123; 1, 2, 3 &#125;);            //错误！不能推导&#123; 1, 2, 3 &#125;的类型

</code></pre><p>总结：</p><ul><li>在一般情况下，auto 类型推导和模板类型推导是一模一样的，但是 auto 类型推导会假定用大括号扩起的初始化表达式代表一个 std::initializer_list, 但模板类型推导不会。</li><li>在函数返回值或 lambda 的形参中使用 auto，意思是使用模板类型推导规则而不是 auto 类型推导规则。</li></ul><h3 id="item3-理解decltype"><a class="anchor" href="#item3-理解decltype">#</a> item3 理解 decltype</h3><p>打了一大段但是忘保存了:😢, 不过相信作者的总结已经够用了。</p><blockquote><p>总结：</p><ul><li>绝大多数情况下，decltype 会得出变量或表达式的类型而不作任何修改。</li><li>对于类型为 T 的左值表达式，除非改表达式仅有一个名字，decltype 总是得出类型 T&amp;</li><li>C++14 支持 decltype (auto), 和 auto 一样，它会从其初始化表达式出发来推导类型，但是它的类型推导使用的是 decltype 的规则。</li></ul></blockquote><h3 id="item4-掌握查看类型推导结果的方法"><a class="anchor" href="#item4-掌握查看类型推导结果的方法">#</a> item4 掌握查看类型推导结果的方法</h3><p>比较推荐的方法：使用 IDE 编辑器直接查看，或者使用编译器诊断信息， 而作者提到的第三种方法，使用运行时输出方法的正确性和易读性方面都有缺陷。</p><p>对于使用编译器诊断信息这种方法，一个很好的方法是使用一个没有定义的类模板：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">// 只声明 TD (Type Displayer) 而不定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">TD</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>只要试图具现该模板，就会诱发一个错误信息，原因是找不到具现模板所需要的定义，如果想查看 x 和 y 的类型，用 x 和 y 的类型去具现 TD 即可：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span> xType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span> yType<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样，编译器就可能会给出这样的信息：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>error<span class="token operator">:</span> aggregate <span class="token char">'TD&lt;int> xType'</span> has incomplete type <span class="token operator">and</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>        cannot be defined</pre></td></tr><tr><td data-num="3"></td><td><pre>error<span class="token operator">:</span> aggregate <span class="token char">'TD&lt;const int *> yType'</span> has incomplete type <span class="token operator">and</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        cannot be defined</pre></td></tr></table></figure><p><strong>当然，即使有一些工具，理解 C++ 的类型推导规则也是很必要的。</strong></p><h2 id="chapter2-auto"><a class="anchor" href="#chapter2-auto">#</a> chapter2 auto</h2><p>从概念上来说， <code>auto</code> 要多简单有多简单，但是细究起来里面却大有文章。使用 <code>auto</code> 可以少打一些字，没错，但好处不止这些：它还能阻止那些由于手动指定类型带来的潜在错误和性能问题。还有，某些 <code>auto</code> 类型推导结果尽管是按部就班地符合标准规定的推导算法，然而从程序员的视角来看却是错误的。如果是这样的情况，那就很有必要知道如何去引导 <code>auto</code> 得出正确结果，因为退回手工指定类型的声明，是通常需要避免的途径。</p><p>这个小小的章节讨论了有关 <code>auto</code> 的一切。</p><h3 id="item5-优先选用auto而非显示类型声明"><a class="anchor" href="#item5-优先选用auto而非显示类型声明">#</a> item5 优先选用 <code>auto</code> , 而非显示类型声明</h3><p>使用 <code>auto</code> 的好处有无数条，但是它几乎唯一的一个缺点却难以说服一些人使用 <code>auto</code> ，即 <code>auto</code> 为代码可维护性和可读性的坏影响。但是，相比于全篇使用或根本不用，了解作者提到的一些优点，适当地使用 <code>auto</code> , 我认为是很有必要的。</p><ul><li><p><code>auto</code> 要求变量在定义的时候提供初始化，这能减少错误并提升性能。</p></li><li><p>在使用 <code>auto</code> 声明迭代器类型或者 lambda 表达式这种复杂类型的时候，能减轻很多负担</p></li><li><p>使用 <code>auto</code> 能减少一些隐式类型转换带来的问题，因为 programer 有时显式使用的类型与表达式实际类型并不完全相等。</p></li></ul><p>前两点易于理解，对于第三点，考虑下面这段代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>…</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    …                                   <span class="token comment">// 用 p 做一些事</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看起来合情合理，但是暗藏隐患。对于 <code>std::unordered_map</code> 来说，它的键值部分是 const，所以哈希表中的 <code>std::pair</code> 的类型并不是 <code>std::pair&lt;std::string,int&gt;</code> , 而是 std::pair&lt;const std::string,int&gt;。可是在上面的循环中，用来声明 <code>p</code> 的类型却不是这个。因此编译器就会想要使用某种方法把 <code>std::pair&lt;const std::string,int&gt;</code> 对象转换成 <code>std::pair&lt;std::string, int&gt;</code> 对象。这一步是可以成功的，方法是对 <code>m</code> 中的每个对象都做一次复制操作，形成一个 <code>p</code> 想要绑定的类型的临时对象，然后把 <code>p</code> 这个引用绑定到该临时对象。并且在循环的每次迭代结束时，该临时对象都会被析构一次，这之间带来的开销与使用 <code>const auto&amp;</code> 相比来说可太大了。</p><h3 id="item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom"><a class="anchor" href="#item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom">#</a> item6 auto 推导不符合要求时，使用显式类型初始化惯用法 (explicitly typed initializer idiom)</h3><p><code>auto</code> 在大多数情况下都很好用，但在遇到一些 &quot;代理&quot; 类型的时候，可能会带来意料之外的错误。</p><p>一个常见的例子是遇到 <code>vector&lt;bool&gt;</code> 的时候，对其它的 vector 容器，operator [] 通常会返回一个引用类型，可是 <code>vector&lt;bool&gt;</code> 不一样，它会返回一个 <code>std::vector&lt;bool&gt;::reference</code> 类型，原因是由于 bool 类型实际上通过 1bit 就可以表示， <code>vector&lt;bool&gt;</code> 为了节省空间，会对 bool 类型压缩为 1bit 来表示。但是这和 <code>vector&lt;bool&gt;</code> 不返回一个 <code>bool&amp;</code> 有什么关系呢，原因是，C++ 禁止返回对一个比特的引用，因此 <code>vector&lt;bool&gt;</code> 的 <code>operator[]</code> 不得不返回一个 <code>std::vector&lt;bool&gt;::reference</code> 对象，然后为了让它在使用其它所有 <code>bool&amp;</code> 的地方保证它能用，让其支持向 <code>bool</code> 类型隐式类型转换（虽然实际更复杂）。</p><p>嗯，但是既然 <code>std::vector&lt;bool&gt;::reference</code> 支持向 <code>bool</code> 类型的隐式转换了，那么 <code>auto</code> 将一个表达式推导为 <code>std::vector&lt;bool&gt;::reference</code> 或者 <code>bool</code> 类型又有什么关系呢？在下面的例子中，可能会引发问题：</p><p>假如我有一个函数，参数为 <code>Widget</code> ，返回一个 <code>std::vector&lt;bool&gt;</code> ，这里的 <code>bool</code> 表示 <code>Widget</code> 是否提供一个独有的特性。更进一步假设第 5 个<em> bit</em> 表示 <code>Widget</code> 是否具有高优先级，我们可以写这样的代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//w 高优先级吗？</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">processWidget</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>highPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 未定义行为！</span></pre></td></tr></table></figure><p>通过上面的讲述，我们知道这里的 <code>auto</code> 会将 <code>highPriority</code> 推导为 <code>std::vector&lt;bool&gt;::reference</code> 类型，并用一个<strong>临时的</strong> <code>vector&lt;bool&gt;</code> 类型的 <code>opertor[]</code> 返回的对象来初始化它。问题是， <code>std::vector&lt;bool&gt;::reference</code> 对象中可能包含一个指针，并指向一个机器字 (word), 该机器字中含有实际上被压缩的那个 1bit 的 <code>bool</code> 。但是随着临时 <code>vector&lt;bool&gt;</code> 对象的析构，这个指针指向的地方马上就会被析构，因此 <code>highPriority</code> 中也会包含一个野指针！对它的使用自然也会包含未定义行为了。</p><p>综上，程序员应该避免写出这样的代码:</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> someVar <span class="token operator">=</span> expression of <span class="token string">"invisible"</span> proxy <span class="token keyword">class</span> <span class="token class-name">type</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这里， <code>auto</code> 本身并不是一个问题，而是其没有推导出想要的类型，一个解决方案是使用<strong>显式类型初始化惯用法</strong>，在上面那个例子中，可以这样操作：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>但是，这与下面这样的代码有何不同，况且还更简单：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>优势是，通过使用 static_cast&lt;bool&gt;，<strong>显式的指明了这里发生了一次类型转换</strong>，而让事情更加显而易见了。</p><p>总结：</p><ul><li>不可见的代理类可能会使 <code>auto</code> 从表达式中推导出 “错误的” 类型</li><li>显式类型初始化惯用法强制 <code>auto</code> 推导出你想要的结果</li></ul><h2 id="chapter3-转向现代c"><a class="anchor" href="#chapter3-转向现代c">#</a> chapter3 转向现代 C++</h2><h3 id="item7-在创建对象时注意区分和"><a class="anchor" href="#item7-在创建对象时注意区分和">#</a> item7 在创建对象时注意区分 () 和 {}</h3><p>总结：</p><ul><li>大括号初始化可以应用的语境最为广泛，可以阻止内建类型之间进行隐式窄化类型转换 (如 double 转 int)，还可以对最令人烦恼的解析语法免疫 (使用小括号初始化的时候要注意，C++ 会优先将表达式解释为声明，比如 <code>Widget w3();</code> 是一个函数声明)</li><li>在构造函数重载匹配期间，只要有任何可能，大括号初始化就会与带有 <code>std::initializer_list</code> 类型的形参相匹配，即使其他重载版本有这更加匹配的形参表</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 <code>std::vector</code> 对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号是需要仔细考虑的。</li></ul><h3 id="item8-优先使用nullptr而非0或null"><a class="anchor" href="#item8-优先使用nullptr而非0或null">#</a> item8 优先使用 nullptr, 而非 0 或 NULL</h3><p>优先使用 nullptr 的主要原因是，0 和 NULL 实际上是一个整型，并非指针，这在重载了支持整型和指针类型参数的函数中有时会引起问题。</p><p>其次是在模板推导的时候，0 和 NULL 会被推导为 int 类型。</p><h3 id="item9-优先选用别名声明而非typedef"><a class="anchor" href="#item9-优先选用别名声明而非typedef">#</a> item9 优先选用别名声明，而非 typedef</h3><p>优先选用别名声明的主要优势在于别名声明可以模板化，而 <code>typedef</code> 不行。为了达到相同效果，C++98 程序员不得不使用嵌套在模板的 struct 中的 typedef。比如下面两个分别使用别名声明和 <code>typedef</code> 来达到相同效果的例子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span>      <span class="token comment">// client </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">MyAllocList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token double-colon punctuation">::</span>type lw<span class="token punctuation">;</span> <span class="token comment">// client</span></pre></td></tr></table></figure><p>另一个优点是使用模板可以让人免写 &quot;::type&quot; 后缀，并且在模板内，对于内嵌 <code>typedef</code> 的使用经常要求加上 <code>typename</code> 前缀 (见 Effective C++ 对于依赖模板类型的说明)。</p><h3 id="item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型"><a class="anchor" href="#item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型">#</a> item10 优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><p>总结：</p><ul><li>C++98 风格的枚举类型，现在称为不限范围的枚举类型。</li><li>限定作用域的枚举类型仅在枚举类型内可见。它们只能通过强制类型转换以转换至其他类型。</li><li>限定作用域的枚举类型和不限范围的枚举类型都支持底层类型指定。限定作用域的枚举类型的默认底层类型是 <code>int</code> , 而不限范围的枚举类型没有默认底层类型。</li><li>限定作用域的枚举类型总是可以进行前置声明，而不限范围的枚举类型却只有在指定了默认底层类型的前提下才可以进行前置声明。</li></ul><h3 id="item11-优先选用删除函数而非private未定义函数"><a class="anchor" href="#item11-优先选用删除函数而非private未定义函数">#</a> item11 优先选用删除函数，而非 <code>private</code> 未定义函数</h3><ul><li>优先选用删除函数，而非 <code>private</code> 未定义函数</li><li>任何函数都可以删除，包括非成员函数和模板具现。</li></ul><div class="tags"><a href="/tags/C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> C++ 读书笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-09-15 01:38:08" itemprop="dateModified" datetime="2024-09-15T01:38:08+08:00">2024-09-15</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="MikeMao 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="MikeMao 支付宝"><p>支付宝</p></div><div><img data-src="/imagesnull" alt="MikeMao 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>MikeMao <i class="ic i-at"><em>@</em></i>MikeMao's blog</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="Efective Modern C++读书笔记">http://example.com/2024/08/31/Efective-Modern-C-读书笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;lz.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclg5ms2rj20zk0m8u0x.jpg" title="Effective C++读书笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>Effective C++读书笔记</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.</span> <span class="toc-text">chapter 1 类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item1-%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.1.</span> <span class="toc-text">item1 理解模板类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B51-paramtype%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E4%BD%86%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">情况 1： ParamType 是一个指针或引用，但不是一个万能引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B52-paramtype-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">情况 2： ParamType 是一个万能引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B53-paramtype%E6%97%A2%E9%9D%9E%E6%8C%87%E9%92%88%E4%B9%9F%E9%9D%9E%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">情况 3： ParamType 既非指针，也非引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">数组实参与函数实参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item2-%E7%90%86%E8%A7%A3auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.3.</span> <span class="toc-text">item2 理解 auto 类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item3-%E7%90%86%E8%A7%A3decltype"><span class="toc-number">1.4.</span> <span class="toc-text">item3 理解 decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item4-%E6%8E%8C%E6%8F%A1%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%BB%93%E6%9E%9C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">item4 掌握查看类型推导结果的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter2-auto"><span class="toc-number">2.</span> <span class="toc-text">chapter2 auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item5-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8auto%E8%80%8C%E9%9D%9E%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">item5 优先选用 auto , 而非显示类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item6-auto%E6%8E%A8%E5%AF%BC%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E6%97%B6%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%AF%E7%94%A8%E6%B3%95explicitly-typed-initializer-idiom"><span class="toc-number">2.2.</span> <span class="toc-text">item6 auto 推导不符合要求时，使用显式类型初始化惯用法 (explicitly typed initializer idiom)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter3-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c"><span class="toc-number">3.</span> <span class="toc-text">chapter3 转向现代 C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item7-%E5%9C%A8%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%B3%A8%E6%84%8F%E5%8C%BA%E5%88%86%E5%92%8C"><span class="toc-number">3.1.</span> <span class="toc-text">item7 在创建对象时注意区分 () 和 {}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item8-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8nullptr%E8%80%8C%E9%9D%9E0%E6%88%96null"><span class="toc-number">3.2.</span> <span class="toc-text">item8 优先使用 nullptr, 而非 0 或 NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item9-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E8%80%8C%E9%9D%9Etypedef"><span class="toc-number">3.3.</span> <span class="toc-text">item9 优先选用别名声明，而非 typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item10-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%80%8C%E9%9D%9E%E4%B8%8D%E9%99%90%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">item10 优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item11-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0%E8%80%8C%E9%9D%9Eprivate%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">item11 优先选用删除函数，而非 private 未定义函数</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/" rel="bookmark" title="STL学习-01-智能指针与vector">STL学习-01-智能指针与vector</a></li><li><a href="/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" rel="bookmark" title="C++：移动语义与右值引用">C++：移动语义与右值引用</a></li><li><a href="/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Effective C++读书笔记">Effective C++读书笔记</a></li><li class="active"><a href="/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Efective Modern C++读书笔记">Efective Modern C++读书笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="MikeMao" data-src="/images/avatar.jpg"><p class="name" itemprop="name">MikeMao</p><div class="description" itemprop="description">a student of NJU && record learning experience</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">16</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hb2Rpbmcx" title="https:&#x2F;&#x2F;github.com&#x2F;maoding1"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/" title="分类于 数理逻辑">数理逻辑</a></div><span><a href="/2023/11/17/%E4%BB%8E%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%9C%AC%E8%BA%AB%E5%88%B0%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95/" title="从数理逻辑本身到哥德尔不完备定理的一种证明方法">从数理逻辑本身到哥德尔不完备定理的一种证明方法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="分类于 编译原理">编译原理</a></div><span><a href="/2023/04/12/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8603-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" title="编译原理03-语义分析">编译原理03-语义分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="分类于 编译原理">编译原理</a></div><span><a href="/2023/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8602-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" title="编译原理02-语法分析">编译原理02-语法分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="分类于 编译原理">编译原理</a></div><span><a href="/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8605-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" title="编译原理05-目标代码生成">编译原理05-目标代码生成</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/git/" title="分类于 git">git</a></div><span><a href="/2022/10/01/Git%E5%AD%A6%E4%B9%A001-%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="git操作">git操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/docker/" title="分类于 docker">docker</a></div><span><a href="/2023/06/27/%E4%BA%91%E5%8E%9F%E7%94%9F-docker%E5%85%A5%E9%97%A8/" title="云原生-docker入门">云原生-docker入门</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/go/" title="分类于 go">go</a></div><span><a href="/2023/07/21/golang-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%8D%E5%85%B8/" title="golang-命令行词典">golang-命令行词典</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2023/03/16/nova%E2%80%94%E2%80%94%E9%AB%98%E8%80%83%E7%BD%91%E7%AB%99%E5%AD%A6%E6%A0%A1%E5%90%8D%E7%A7%B0%E7%88%AC%E5%8F%96/" title="nova——高考网站学校名称爬取">nova——高考网站学校名称爬取</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Maven/" title="分类于 Maven">Maven</a></div><span><a href="/2022/10/23/Maven-%E5%AD%A6%E4%B9%A0/" title="Maven 学习">Maven 学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/2022/09/30/Linux%E2%80%9401-Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E8%AF%86/" title="Linux—01-Linux安装常识">Linux—01-Linux安装常识</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">MikeMao @ MikeMao's blog</span></div><div id="running-time">博客已经运行了 <span id="years">0</span> 年 <span id="days">0</span> 天 <span id="hours">0</span> 小时 <span id="minutes">0</span> 分 <span id="seconds">0</span> 秒</div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div><script>function updateRunningTime(){const e=new Date("2022-09-30T00:00:00"),t=new Date,n=t-e,o=Math.floor(n/1e3%60),d=Math.floor(n/1e3/60%60),m=Math.floor(n/1e3/60/60%24),u=Math.floor(n/1e3/60/60/24%365),a=Math.floor(n/1e3/60/60/24/365);document.getElementById("years").textContent=a,document.getElementById("days").textContent=u,document.getElementById("hours").textContent=m,document.getElementById("minutes").textContent=d,document.getElementById("seconds").textContent=o}updateRunningTime(),setInterval(updateRunningTime,1e3)</script></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/08/31/Efective-Modern-C-读书笔记/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->