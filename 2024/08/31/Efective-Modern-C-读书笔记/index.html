<!-- build time:Wed Nov 20 2024 16:39:46 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><meta name="referrer" content="http://localhost:4000/"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="MikeMao's blog" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="MikeMao's blog" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="MikeMao's blog" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C++ 读书笔记"><link rel="canonical" href="http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><title>Efective Modern C++读书笔记 - C++ | MikeMao's blog = MikeMao's blog = 风烟俱净，天山共色 从流飘荡，任意东西</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Efective Modern C++读书笔记</h1><div class="meta"><span class="item" title="创建时间：2024-08-31 20:44:57"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-08-31T20:44:57+08:00">2024-08-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>34 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">MikeMao's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1giph47e9vtj20zk0m8x6l.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1giclip4jbpj20zk0m87cv.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://lz.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="MikeMao"><meta itemprop="description" content="风烟俱净，天山共色 从流飘荡，任意东西, a student of NJU && record learning experience"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="MikeMao's blog"></span><div class="body md" itemprop="articleBody"><p>本书主要设计 C++11/14 的新语言特性，Modern C++ 带来的各种改变是亡羊补牢，还是脱胎换骨，通过阅读本书可能会得到答案。</p><p>不得不说 C++11 之后的语言特性理解难度越来越高了，完全理解并作出比作者还高效精炼的总结实在是太困难，写作难度相比写《Effective C++》读书笔记的时候大大提高了。</p><p>看书是一件乐趣，写读书笔记可不是😢。但是就阅读《Effective C++》的经历而言，减慢阅读速度而留下记录是很重要的，不知本篇何时才能完成。</p><p>ps: 电力出版社的高博版翻译的错误实在有点多，正文中我看出来的已经更正 (隐式的)。同时本文涉及到的很多 C++ 新概念的详细语法和使用并不会解释。</p><p>在学习的过程中，非常推荐使用在线编译器<span class="exturl" data-url="aHR0cHM6Ly9nb2Rib2x0Lm9yZy8="> Compiler Explorer</span> 以及 AI 问答工具快速验证想法。比如直接询问 gpt：一个形参为右值引用的函数 给他传参的时候可以传左值吗？</p><p>对此 gpt 给出的答案是 <strong>可以</strong> ，并提供了一个例子</p><p><img data-src="image-20241117183223299.png" alt="image-20241117183223299"></p><p>但是实际上，compiler 给出的答案是否定的，所以，gpt 很好用，但验证还是有必要的。</p><p><img data-src="image-20241117183525877.png" alt="image-20241117183525877"></p><p><span id="more"></span></p><h2 id="chapter-1-类型推导"><a class="anchor" href="#chapter-1-类型推导">#</a> chapter 1 类型推导</h2><h3 id="item1-理解模板类型推导"><a class="anchor" href="#item1-理解模板类型推导">#</a> item1 理解模板类型推导</h3><p>模板类型推导，是 C++ 一个广泛应用的特性，并且可以被称为一个良好的设计，因为很多程序员都在完全不了解其底层运行机制的情况下，获得了满意的结果。C++ 11 带来了 <code>auto</code> ，模板类型推导也是其运行的基础，一个坏消息是有些时候它的应用并不符合直觉，因此了解模板类型推导的一些细节就有些重要了。</p><p>考虑如下一个函数模板：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span></pre></td></tr></table></figure><p>这里的 ParamType 是与 T 有关的一个类型，比如 <code>const T</code> , <code>T &amp;</code> 等</p><p>对于某一次调用 <code>f(expr)</code> , T 的推导结果会是什么呢，答案是，<strong>既与 expr 的类型有关也和 ParamType 有关</strong>，具体要分为三种情况讨论。</p><h4 id="情况1-paramtype是一个指针或引用但不是一个万能引用"><a class="anchor" href="#情况1-paramtype是一个指针或引用但不是一个万能引用">#</a> 情况 1： ParamType 是一个指针或引用，但不是一个万能引用</h4><p>这种情况下，类型推导会这样运作：</p><ol><li>若 expr 具有引用类型，先将引用部分忽略</li><li>然后，对 <code>expr</code> 的类型和 <code>ParamType</code> 的类型执行模式匹配，来决定 T 的类型。</li></ol><p>for example:</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 对与如下模式</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token comment">//param 是一个引用</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//T 是 int，param 的类型是 int&amp;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T 是 const int，param 的类型是 const int&amp;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T 是 const int，param 的类型是 const int&amp;</span></pre></td></tr></table></figure><p>这些例子只展示了左值引用，但是类型推导会如左值引用一样对待右值引用。</p><h4 id="情况2-paramtype-是一个万能引用"><a class="anchor" href="#情况2-paramtype-是一个万能引用">#</a> 情况 2： ParamType 是一个万能引用</h4><p>对于使用万能引用形参的模板而言，规则就没那么显明了：</p><ol><li>如果 expr 是左值， <code>T</code> 和 ParamType 都会被推导为左值引用。这个结果又两点比较奇怪：首先，这是在模板类型推导中，T 被推导为引用类型的唯一情形。其次，尽管在声明时使用的是右值引用语法，它的类型推导结果却是左值引用。</li><li>如果 expr 是一个右值，则应用情况 1 中的规则</li></ol><p>例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//param 现在是一个通用引用类型</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span>                       <span class="token comment">// 如之前一样</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span>                 <span class="token comment">// 如之前一样</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span>              <span class="token comment">// 如之前一样</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//x 是左值，所以 T 是 int&amp;，</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                                <span class="token comment">//param 类型也是 int&amp;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//cx 是左值，所以 T 是 const int&amp;，</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                                <span class="token comment">//param 类型也是 const int&amp;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//rx 是左值，所以 T 是 const int&amp;，</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                                <span class="token comment">//param 类型也是 const int&amp;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//27 是右值，所以 T 是 int，</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                                <span class="token comment">//param 类型就是 int&amp;&amp;</span></pre></td></tr></table></figure><p>item24 详细解释了为什么这些例子是像这样发生的。这里关键在于通用引用的类型推导规则是不同于普通的左值或者右值引用的。尤其是，当通用引用被使用时，类型推导会区分左值实参和右值实参，但是对非通用引用时不会区分。</p><h3 id="情况3-paramtype既非指针也非引用"><a class="anchor" href="#情况3-paramtype既非指针也非引用">#</a> 情况 3： ParamType 既非指针，也非引用</h3><p>当 <code>ParamType</code> 既非引用也非指针时，我们面对的就是所谓的按值传递了，这意味着无论传入的是什么，param 都会是它的一个副本，即一个全新的对象。具体来说：</p><ol><li>和之前一样，如果 <code>expr</code> 的类型是一个引用，忽略这个引用部分</li><li>如果忽略 <code>expr</code> 的引用性之后，如果 <code>expr</code> 具有 <code>const</code> 或 <code>volatile</code> 属性，都会被忽略。</li></ol><p>例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span>                       <span class="token comment">// 如之前一样</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span>                 <span class="token comment">// 如之前一样</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span>              <span class="token comment">// 如之前一样</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//T 和 param 的类型都是 int</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T 和 param 的类型都是 int</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T 和 param 的类型都是 int</span></pre></td></tr></table></figure><p>这是因为根据按值传递的思想， <code>expr</code> 是 const 或者 volatile 不意为着它的拷贝也不能被修改。</p><p>认识到只有在传值给形参时才会忽略 <code>const</code> （和 <code>volatile</code> ）这一点很重要，正如我们看到的，对于 reference-to- <code>const</code> 和 pointer-to- <code>const</code> 形参来说， <code>expr</code> 的常量性在推导时会被保留。但是考虑这样的情况， <code>expr</code> 是一个 <code>const</code> 指针，指向 <code>const</code> 对象， <code>expr</code> 通过传值传递给 <code>param</code> ：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 仍然以传值的方式处理 param</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span>         <span class="token comment">//ptr 是一个常量指针，指向常量对象 </span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">"Fun with pointers"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 传递 const char * const 类型的实参</span></pre></td></tr></table></figure><p>在这里，解引用符号（*）的右边的 <code>const</code> 表示 <code>ptr</code> 本身是一个 <code>const</code> ： <code>ptr</code> 不能被修改为指向其它地址，也不能被设置为 null（解引用符号左边的 <code>const</code> 表示 <code>ptr</code> 指向一个字符串，这个字符串是 <code>const</code> ，因此字符串不能被修改）。当 <code>ptr</code> 作为实参传给 <code>f</code> ，组成这个指针的每一比特都被拷贝进 <code>param</code> 。像这种情况， <code>ptr</code> <strong>自身的值会被传给形参</strong>，根据类型推导的第三条规则， <code>ptr</code> 自身的常量性将会被省略，所以 <code>param</code> 是 <code>const char*</code> ，也就是一个可变指针指向 <code>const</code> 字符串。在类型推导中，这个指针指向的数据的常量性将会被保留，但是当拷贝 <code>ptr</code> 来创造一个新指针 <code>param</code> 时， <code>ptr</code> 自身的常量性将会被忽略。</p><h4 id="数组实参与函数实参"><a class="anchor" href="#数组实参与函数实参">#</a> 数组实参与函数实参</h4><p>在模板类型推导过程中，数组或函数类型的实参会退化成对应的指针，除非它们被用来初始化引用</p><h3 id="item2-理解auto类型推导"><a class="anchor" href="#item2-理解auto类型推导">#</a> item2 理解 auto 类型推导</h3><p>继续使用上一节的这个例子来解释 auto 类型推导是如何和模板类型推导联系在一起的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParmaType param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 使用一些表达式调用 f</span></pre></td></tr></table></figure><p>当变量采用 auto 来声明时，auto 扮演了模板中 T 的角色，变量的类型饰词扮演了 ParamType 的角色。</p><p>比如说：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>	<span class="token comment">// 类型饰词是 auto</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>	<span class="token comment">// 类型饰词是 const auto</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>	<span class="token comment">// 类型饰词是 const auto &amp;</span></pre></td></tr></table></figure><p>在这里例子中要推导 x，cx 和 rx 的类型，编译器的行为看起来就像是认为这里每个声明都有一个模板，然后使用合适的初始化表达式进行调用：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 x 的类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                                <span class="token comment">//param 的推导类型是 x 的类型</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 cx 的类型</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_cx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">func_for_cx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                                <span class="token comment">//param 的推导类型是 cx 的类型</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 rx 的类型</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_rx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">func_for_rx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                                <span class="token comment">//param 的推导类型是 rx 的类型</span></pre></td></tr></table></figure><p>除了一个例外，就是使用初始化列表时。</p><p>例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>         <span class="token comment">//x 的类型是 std::initializer_list&lt;int></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 带有与 x 的声明等价的</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 形参声明的模板</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 错误！不能推导出 T</span></pre></td></tr></table></figure><p>C++\14 中允许 <code>auto</code> 用户函数返回值，也允许 lambda 函数的形参声明中使用 <code>auto</code> , 但在这些情况下 <code>auto</code> 实际上使用模板类型推导那一套规则在工作，因此下面的代码不会通过编译：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> <span class="token function">createInitList</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>         <span class="token comment">// 错误！不能推导 &#123;1, 2, 3&#125; 的类型</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>…</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">auto</span> resetV <span class="token operator">=</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">[</span><span class="token operator">&amp;</span>v<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> newValue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> v <span class="token operator">=</span> newValue<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">//C++14</span></pre></td></tr><tr><td data-num="10"></td><td><pre>…</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">resetV</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 错误！不能推导 &#123;1, 2, 3&#125; 的类型</span></pre></td></tr></table></figure><p>总结：</p><ul><li>在一般情况下，auto 类型推导和模板类型推导是一模一样的，但是 auto 类型推导会假定用大括号扩起的初始化表达式代表一个 std::initializer_list, 但模板类型推导不会。</li><li>在函数返回值或 lambda 的形参中使用 auto，意思是使用模板类型推导规则而不是 auto 类型推导规则。</li></ul><h3 id="item3-理解decltype"><a class="anchor" href="#item3-理解decltype">#</a> item3 理解 decltype</h3><p>打了一大段但是忘保存了:😢, 不过相信作者的总结已经够用了。</p><blockquote><p>总结：</p><ul><li>绝大多数情况下，decltype 会得出变量或表达式的类型而不作任何修改。</li><li>对于类型为 T 的左值表达式，除非改表达式仅有一个名字，decltype 总是得出类型 T&amp;</li><li>C++14 支持 decltype (auto), 和 auto 一样，它会从其初始化表达式出发来推导类型，但是它的类型推导使用的是 decltype 的规则。</li></ul></blockquote><h3 id="item4-掌握查看类型推导结果的方法"><a class="anchor" href="#item4-掌握查看类型推导结果的方法">#</a> item4 掌握查看类型推导结果的方法</h3><p>比较推荐的方法：使用 IDE 编辑器直接查看，或者使用编译器诊断信息， 而作者提到的第三种方法，使用运行时输出方法的正确性和易读性方面都有缺陷。</p><p>对于使用编译器诊断信息这种方法，一个很好的方法是使用一个没有定义的类模板：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">// 只声明 TD (Type Displayer) 而不定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">TD</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>只要试图具现该模板，就会诱发一个错误信息，原因是找不到具现模板所需要的定义，如果想查看 x 和 y 的类型，用 x 和 y 的类型去具现 TD 即可：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span> xType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span> yType<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样，编译器就可能会给出这样的信息：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>error<span class="token operator">:</span> aggregate <span class="token char">'TD&lt;int> xType'</span> has incomplete type <span class="token operator">and</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>        cannot be defined</pre></td></tr><tr><td data-num="3"></td><td><pre>error<span class="token operator">:</span> aggregate <span class="token char">'TD&lt;const int *> yType'</span> has incomplete type <span class="token operator">and</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        cannot be defined</pre></td></tr></table></figure><p><strong>当然，即使有一些工具，理解 C++ 的类型推导规则也是很必要的。</strong></p><h2 id="chapter2-auto"><a class="anchor" href="#chapter2-auto">#</a> chapter2 auto</h2><p>从概念上来说， <code>auto</code> 要多简单有多简单，但是细究起来里面却大有文章。使用 <code>auto</code> 可以少打一些字，没错，但好处不止这些：它还能阻止那些由于手动指定类型带来的潜在错误和性能问题。还有，某些 <code>auto</code> 类型推导结果尽管是按部就班地符合标准规定的推导算法，然而从程序员的视角来看却是错误的。如果是这样的情况，那就很有必要知道如何去引导 <code>auto</code> 得出正确结果，因为退回手工指定类型的声明，是通常需要避免的途径。</p><p>这个小小的章节讨论了有关 <code>auto</code> 的一切。</p><h3 id="item5-优先选用auto而非显示类型声明"><a class="anchor" href="#item5-优先选用auto而非显示类型声明">#</a> item5 优先选用 <code>auto</code> , 而非显示类型声明</h3><p>使用 <code>auto</code> 的好处有无数条，但是它几乎唯一的一个缺点却难以说服一些人使用 <code>auto</code> ，即 <code>auto</code> 为代码可维护性和可读性的坏影响。但是，相比于全篇使用或根本不用，了解作者提到的一些优点，适当地使用 <code>auto</code> , 我认为是很有必要的。</p><ul><li><p><code>auto</code> 要求变量在定义的时候提供初始化，这能减少错误并提升性能。</p></li><li><p>在使用 <code>auto</code> 声明迭代器类型或者 lambda 表达式这种复杂类型的时候，能减轻很多负担</p></li><li><p>使用 <code>auto</code> 能减少一些隐式类型转换带来的问题，因为 programer 有时显式使用的类型与表达式实际类型并不完全相等。</p></li></ul><p>前两点易于理解，对于第三点，考虑下面这段代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>…</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    …                                   <span class="token comment">// 用 p 做一些事</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看起来合情合理，但是暗藏隐患。对于 <code>std::unordered_map</code> 来说，它的键值部分是 const，所以哈希表中的 <code>std::pair</code> 的类型并不是 <code>std::pair&lt;std::string,int&gt;</code> , 而是 std::pair&lt;const std::string,int&gt;。可是在上面的循环中，用来声明 <code>p</code> 的类型却不是这个。因此编译器就会想要使用某种方法把 <code>std::pair&lt;const std::string,int&gt;</code> 对象转换成 <code>std::pair&lt;std::string, int&gt;</code> 对象。这一步是可以成功的，方法是对 <code>m</code> 中的每个对象都做一次复制操作，形成一个 <code>p</code> 想要绑定的类型的临时对象，然后把 <code>p</code> 这个引用绑定到该临时对象。并且在循环的每次迭代结束时，该临时对象都会被析构一次，这之间带来的开销与使用 <code>const auto&amp;</code> 相比来说可太大了。</p><h3 id="item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom"><a class="anchor" href="#item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom">#</a> item6 auto 推导不符合要求时，使用显式类型初始化惯用法 (explicitly typed initializer idiom)</h3><p><code>auto</code> 在大多数情况下都很好用，但在遇到一些 &quot;代理&quot; 类型的时候，可能会带来意料之外的错误。</p><p>一个常见的例子是遇到 <code>vector&lt;bool&gt;</code> 的时候，对其它的 vector 容器，operator [] 通常会返回一个引用类型，可是 <code>vector&lt;bool&gt;</code> 不一样，它会返回一个 <code>std::vector&lt;bool&gt;::reference</code> 类型，原因是由于 bool 类型实际上通过 1bit 就可以表示， <code>vector&lt;bool&gt;</code> 为了节省空间，会对 bool 类型压缩为 1bit 来表示。但是这和 <code>vector&lt;bool&gt;</code> 不返回一个 <code>bool&amp;</code> 有什么关系呢，原因是，C++ 禁止返回对一个比特的引用，因此 <code>vector&lt;bool&gt;</code> 的 <code>operator[]</code> 不得不返回一个 <code>std::vector&lt;bool&gt;::reference</code> 对象，然后为了让它在使用其它所有 <code>bool&amp;</code> 的地方保证它能用，让其支持向 <code>bool</code> 类型隐式类型转换（虽然实际更复杂）。</p><p>嗯，但是既然 <code>std::vector&lt;bool&gt;::reference</code> 支持向 <code>bool</code> 类型的隐式转换了，那么 <code>auto</code> 将一个表达式推导为 <code>std::vector&lt;bool&gt;::reference</code> 或者 <code>bool</code> 类型又有什么关系呢？在下面的例子中，可能会引发问题：</p><p>假如我有一个函数，参数为 <code>Widget</code> ，返回一个 <code>std::vector&lt;bool&gt;</code> ，这里的 <code>bool</code> 表示 <code>Widget</code> 是否提供一个独有的特性。更进一步假设第 5 个<em> bit</em> 表示 <code>Widget</code> 是否具有高优先级，我们可以写这样的代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//w 高优先级吗？</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">processWidget</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>highPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 未定义行为！</span></pre></td></tr></table></figure><p>通过上面的讲述，我们知道这里的 <code>auto</code> 会将 <code>highPriority</code> 推导为 <code>std::vector&lt;bool&gt;::reference</code> 类型，并用一个<strong>临时的</strong> <code>vector&lt;bool&gt;</code> 类型的 <code>opertor[]</code> 返回的对象来初始化它。问题是， <code>std::vector&lt;bool&gt;::reference</code> 对象中可能包含一个指针，并指向一个机器字 (word), 该机器字中含有实际上被压缩的那个 1bit 的 <code>bool</code> 。但是随着临时 <code>vector&lt;bool&gt;</code> 对象的析构，这个指针指向的地方马上就会被析构，因此 <code>highPriority</code> 中也会包含一个野指针！对它的使用自然也会包含未定义行为了。</p><p>综上，程序员应该避免写出这样的代码:</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> someVar <span class="token operator">=</span> expression of <span class="token string">"invisible"</span> proxy <span class="token keyword">class</span> <span class="token class-name">type</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这里， <code>auto</code> 本身并不是一个问题，而是其没有推导出想要的类型，一个解决方案是使用<strong>显式类型初始化惯用法</strong>，在上面那个例子中，可以这样操作：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>但是，这与下面这样的代码有何不同，况且还更简单：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>优势是，通过使用 static_cast&lt;bool&gt;，<strong>显式的指明了这里发生了一次类型转换</strong>，而让事情更加显而易见了。</p><p>总结：</p><ul><li>不可见的代理类可能会使 <code>auto</code> 从表达式中推导出 “错误的” 类型</li><li>显式类型初始化惯用法强制 <code>auto</code> 推导出你想要的结果</li></ul><h2 id="chapter3-转向现代c"><a class="anchor" href="#chapter3-转向现代c">#</a> chapter3 转向现代 C++</h2><h3 id="item7-在创建对象时注意区分和"><a class="anchor" href="#item7-在创建对象时注意区分和">#</a> item7 在创建对象时注意区分 () 和 {}</h3><p>总结：</p><ul><li>大括号初始化可以应用的语境最为广泛，可以阻止内建类型之间进行隐式窄化类型转换 (如 double 转 int)，还可以对最令人烦恼的解析语法免疫 (使用小括号初始化的时候要注意，C++ 会优先将表达式解释为声明，比如 <code>Widget w3();</code> 是一个函数声明)</li><li>在构造函数重载匹配期间，只要有任何可能，大括号初始化就会与带有 <code>std::initializer_list</code> 类型的形参相匹配，即使其他重载版本有这更加匹配的形参表</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 <code>std::vector</code> 对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号是需要仔细考虑的。</li></ul><h3 id="item8-优先使用nullptr而非0或null"><a class="anchor" href="#item8-优先使用nullptr而非0或null">#</a> item8 优先使用 nullptr, 而非 0 或 NULL</h3><p>优先使用 nullptr 的主要原因是，0 和 NULL 实际上是一个整型，并非指针，这在重载了支持整型和指针类型参数的函数中有时会引起问题。</p><p>其次是在模板推导的时候，0 和 NULL 会被推导为 int 类型。</p><h3 id="item9-优先选用别名声明而非typedef"><a class="anchor" href="#item9-优先选用别名声明而非typedef">#</a> item9 优先选用别名声明，而非 typedef</h3><p>优先选用别名声明的主要优势在于别名声明可以模板化，而 <code>typedef</code> 不行。为了达到相同效果，C++98 程序员不得不使用嵌套在模板的 struct 中的 typedef。比如下面两个分别使用别名声明和 <code>typedef</code> 来达到相同效果的例子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span>      <span class="token comment">// client </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">MyAllocList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token double-colon punctuation">::</span>type lw<span class="token punctuation">;</span> <span class="token comment">// client</span></pre></td></tr></table></figure><p>另一个优点是使用模板可以让人免写 &quot;::type&quot; 后缀，并且在模板内，对于内嵌 <code>typedef</code> 的使用经常要求加上 <code>typename</code> 前缀 (见 Effective C++ 对于依赖模板类型的说明)。</p><h3 id="item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型"><a class="anchor" href="#item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型">#</a> item10 优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><p>总结：</p><ul><li>C++98 风格的枚举类型，现在称为不限范围的枚举类型。</li><li>限定作用域的枚举类型仅在枚举类型内可见。它们只能通过强制类型转换以转换至其他类型。</li><li>限定作用域的枚举类型和不限范围的枚举类型都支持底层类型指定。限定作用域的枚举类型的默认底层类型是 <code>int</code> , 而不限范围的枚举类型没有默认底层类型。</li><li>限定作用域的枚举类型总是可以进行前置声明，而不限范围的枚举类型却只有在指定了默认底层类型的前提下才可以进行前置声明。</li></ul><h3 id="item11-优先选用删除函数而非private未定义函数"><a class="anchor" href="#item11-优先选用删除函数而非private未定义函数">#</a> item11 优先选用删除函数，而非 <code>private</code> 未定义函数</h3><ul><li>优先选用删除函数，而非 <code>private</code> 未定义函数</li><li>任何函数都可以删除，包括非成员函数和模板具现。</li></ul><h3 id="item12-为意在改写的函数添加override声明"><a class="anchor" href="#item12-为意在改写的函数添加override声明">#</a> item12 为意在改写的函数添加 <code>override</code> 声明</h3><p>首先回顾一下改写 (override) 这个动作的发生条件：</p><ul><li>基类中的函数必须是虚函数</li><li>基类和派生类中的函数名字必须完全相同 (析构函数例外)</li><li>基类和派生类中的函数形参类型必须完全相同</li><li>基类和派生类中的函数常量性必须完全相同</li><li>基类和派生类中的函数返回值和异常规格必须兼容</li></ul><p>除了这些限制，C++11 又加了一条：</p><ul><li>基类和派生类中的函数引用饰词 (reference qualifier) 必须完全相同</li></ul><p>成员函数引用饰词是 C++11 中鲜为人知的语言特性，他们是为了实现限制成员函数仅用于左值或右值，例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>	<span class="token comment">// 这个版本的 doWork 仅在 * this 是左值时调用</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span> 	<span class="token comment">// 这个版本的 doWork 仅在 * this 是右值时调用</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 工厂函数（返回右值）</span></pre></td></tr><tr><td data-num="10"></td><td><pre>Widget w<span class="token punctuation">;</span>				<span class="token comment">// 普通对象（左值）</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>w<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 调用 Widget::doWork &amp;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 	<span class="token comment">// 调用 Widget::doWork &amp;&amp;</span></pre></td></tr></table></figure><p>回到正题，既然对于 override 有这么多要求，为了避免程序员在想要实现重写的目的却由于微小的偏差导致重写失败这样的错误能够在编译的时候被发现，引入了 <code>override</code> 关键字，以显示标明派生类中的函数时为了改写基类版本。</p><h3 id="item13-优先选用const_iterator而非iterator"><a class="anchor" href="#item13-优先选用const_iterator而非iterator">#</a> item13 优先选用 const_iterator, 而非 iterator</h3><ul><li>优先选用 cons_iterator, 而非 iterator</li><li>在最通用的代码中，优先选用非成员函数版本的 begin, end 和 rbegin 等，而非其成员函数版本。这是因为对于一些内置类型比如指针，没有成员函数。</li></ul><h3 id="item-14-只要函数不会抛出异常就为其加上noexcept声明"><a class="anchor" href="#item-14-只要函数不会抛出异常就为其加上noexcept声明">#</a> item 14 只要函数不会抛出异常，就为其加上 noexcept 声明</h3><ul><li><code>noexcept</code> 声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。因此，在声明一个 <code>noexcept</code> 函数时要慎重考虑，需要保证此函数长期内都保持 <code>noexcept</code> 规格</li><li><strong>相对于不带 <code>noexcept</code> 声明的函数，带有 <code>noexcept</code> 声明的函数有更多机会得到优化</strong>。当一个异常视图逃离 <code>noexcept</code> 函数的时候，程序会直接终止，因此不需要保证栈的可开解性以及函数中的对象以其被构造顺序的逆序完成析构，这给了一些优化空间。</li><li><code>noexcept</code> 性质对于移动操作、 <code>swap</code> 、内存释放函数和析构函数最有价值</li><li>大多数函数都是异常中立的，不具备 <code>noexcept</code> 性质</li></ul><h3 id="item15-只要有可能使用constexpr就使用它"><a class="anchor" href="#item15-只要有可能使用constexpr就使用它">#</a> item15 只要有可能使用 <code>constexpr</code> , 就使用它</h3><p>首先指出一个对于 <code>constexpr</code> 函数的结果的误区：你既不能断定它是 <code>const</code> ，也不能假定其值在编译阶段就已知。</p><p>正确的理解方式应该是这样：</p><ol><li><code>constexpr</code> 函数可以用在要求编译期常量的语境中。在这样的语境中，若你传给一个 <code>constexpr</code> 函数的实参值是在编译期已知的，则结果也会在编译期间计算出来。如果任何一个实参值在编译期未知，则你的代码无法通过编译。</li><li>在调用 <code>constexpr</code> 函数时，若传入的值有一个或多个在编译期未知，则它的运作方式和普通函数无异，亦即他也是在运行期执行结果的计算。这意味着，如果函数执行的是同样的操作，仅仅应用的语境一个是要求编译期常量的，一个是用于所有其他值的话，那就不必写两个函数。 <code>constexpr</code> 函数就可以同时满足所有需求</li></ol><p>另外 <code>constexpr</code> 函数在 C++11 和 C++14 标准也有所不同，在 C++11 中， <code>constexpr</code> 函数只能包含一条 return 语句。</p><p>总结：</p><ul><li><code>constexpr</code> 对象都具备 <code>const</code> 属性，并由编译器已知的值完成初始化。</li><li><code>constexpr</code> 函数在调用时若传入的实参值是编译期已知的，则会产出编译期结果</li><li>比起非 <code>constexpr</code> 对象或 <code>constexpr</code> 函数而言， <code>constexpr</code> 对象或是 <code>constexpr</code> 函数可以用在一个作用域更广的语境中。</li></ul><h3 id="item16-保证const成员函数的线程安全性"><a class="anchor" href="#item16-保证const成员函数的线程安全性">#</a> item16 保证 const 成员函数的线程安全性</h3><p>总结：</p><ul><li>保证 <code>const</code> 成员函数的线程安全性，除非可以确信它们不会用在并发语境中</li><li>运用 <code>std::atomic</code> 类型的变量会比运用互斥量提供更好的性能，但前者仅使用对单个变量或内存区域的操作</li></ul><h3 id="item17-理解特种成员函数的生成机制"><a class="anchor" href="#item17-理解特种成员函数的生成机制">#</a> item17 理解特种成员函数的生成机制</h3><p>对于 c++11 之后特种成员函数的生成机制，直接提供一个总结版本，但由于为什么规则是这样，需参考原文。</p><ul><li><p><strong>默认构造函数</strong>：和 C++98 规则相同。仅当类不存在用户声明的构造函数时才自动生成。</p></li><li><p><strong>析构函数</strong>：基本上和 C++98 相同；稍微不同的是现在析构默认 <code>noexcept</code> （参见 item14）。和 C++98 一样，仅当基类析构为虚函数时该类析构才为虚函数。</p></li><li><p><strong>复制构造函数</strong>：运行期行为与 C++98 相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为</p></li><li><p><strong>复制赋值运算符</strong>： 运行期行为与 C++98 相同：按成员进行非静态数据成员的复制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了移动操作，则复制赋值运算符将被删除。在已经存在复制构造函数或析构函数的条件下，仍然生成复制赋值运算符已经成为了被废弃的行为</p></li><li><p><strong>移动构造函数和移动赋值运算符</strong>： 都按成员进行非静态成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成。</p></li></ul><p>除此之外，成员函数模板在任何情况下都不会抑制特种成员函数的生成。</p><h2 id="chapter4-智能指针"><a class="anchor" href="#chapter4-智能指针">#</a> chapter4 智能指针</h2><h3 id="item18-使用stdunique_ptr管理具备专属所有权的资源"><a class="anchor" href="#item18-使用stdunique_ptr管理具备专属所有权的资源">#</a> item18 使用 std::unique_ptr 管理具备专属所有权的资源</h3><p><code>std::unique_ptr</code> 的惯用场合和语义已经是基础知识了，不需赘述。但是一个新的知识点是可以为 <code>unique_ptr</code> 定制一个删除器，例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span>         <span class="token comment">// 自定义删除器</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                <span class="token punctuation">&#123;</span>                                   <span class="token comment">//（lambda 表达式）</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                    <span class="token keyword">delete</span> pInvestment<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>                <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span></pre></td></tr><tr><td data-num="8"></td><td><pre>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span>     <span class="token comment">// 更改后的返回类型</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token comment">// 应返回的指针</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> delInvmt<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 一个 Stock 对象应被创建 */</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Stock</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment">/* 一个 Bond 对象应被创建 */</span> <span class="token punctuation">)</span>   </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#123;</span>     </pre></td></tr><tr><td data-num="19"></td><td><pre>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Bond</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span>   </pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment">/* 一个 RealEstate 对象应被创建 */</span> <span class="token punctuation">)</span>   </pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#123;</span>     </pre></td></tr><tr><td data-num="23"></td><td><pre>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RealEstate</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span>   </pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">return</span> pInv<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>总结：</p><ul><li><code>std::unique_ptr</code> 是小巧的，高速的，具备只移类型的智能指针，对托管资源实施专属所有权语义</li><li>默认地，资源析构采用 <code>delete</code> 运算符来实现，但可以指定自定义删除器。有状态的删除器和采用函数指针实现的删除器会增加 <code>std::unique_ptr</code> 类型的对象尺寸。</li><li>将 <code>std::unique_ptr</code> 转换成 <code>std::shared_ptr</code> 是容易实现的</li></ul><h3 id="item19-使用stdshared_ptr管理具备共享所有权的资源"><a class="anchor" href="#item19-使用stdshared_ptr管理具备共享所有权的资源">#</a> item19 使用 std::shared_ptr 管理具备共享所有权的资源</h3><p>shared_ptr 的用法可以说是 C++11 最广为认知的特性了，他的强大之处在于，其不仅给 C++ 带来了垃圾回收的机制，同时垃圾回收的时机也是程序员可以掌握的。这样的想法有可能带来 shared_ptr 的滥用，因此了解其带来的性能影响是必要的：</p><ul><li>shared_ptr 的尺寸是裸指针的两倍，因为其内部包含一个指向资源的指针和一个指向该资源引用计数 (或者说控制块) 的指针</li><li>引用计数的内存必须动态分配。</li><li>引用计数的加减是原子操作</li></ul><p>有一点与 unique_ptr 不同的是：shared_ptr 也可以自定义析构器，不过这个析构器不是 shared_ptr 类型组成的一部分，知道有这一点即可。这个自定义析构器存在于 shared_ptr 的控制块中，控制块中还包含引用计数等结构。</p><p><img data-src="item19_fig1.png" alt="item19_fig1"></p><p>我们总是要保证拥有同一个对象的各个 shared_ptr 永远共享同一个控制块，否则就会引起 double free 等错误。控制块的创建遵循以下操作：</p><ul><li>std::make_shared 总是创建一个控制块</li><li>从具备专属所有权的指针出发 (如 unique_ptr) 构造一个 std::shared_ptr 的时候，会创建一个控制块</li><li>当 std::shared_ptr 构造函数使用裸指针作为实参来调用时，它会创建一个控制块。</li></ul><p>使用 shared_ptr 的时候，新手经常会在这样的场景下犯错，即在类的成员函数返回 this 指针时，</p><p>考虑下面这样的代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> processedWidgets<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    …</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    …</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    …                                       <span class="token comment">// 处理 Widget</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    processedWidgets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 然后将它加到已处理过的 Widget</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span>                                           <span class="token comment">// 的列表中，这是错的！</span></pre></td></tr></table></figure><p>Widget 类的成员函数 process 对自身进行一些处理，并将处理完毕后的 this 指针作为构造参数传入 processedWidgets 容器中，这里的错误是：我们用裸指针作为形参传到了 shared_ptr 的构造函数中，而这样做创建了一个新的控制块！因此如果调用 process 的 Widget 对象已经有了一个指向它的 shared_ptr, 错误将会发生。</p><p>标准库为这种情况提供了一个新的解决方案:std::enable_shared_from_this, 当你希望一个托管到 shared_ptr 的类能够安全地由 this 指针创建一个 shared_ptr 时，它将为你继承而来的基类提供一个模板。语法是这样的:</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Widget</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    …</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    …</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 和之前一样，处理 Widget</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    …</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 把指向当前对象的 std::shared_ptr 加入 processedWidgets</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    processedWidgets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>shared_from_this 提供了这样一个效果：它查询当前对象的控制块，并创建一个指向该控制块的 shared_ptr。这样的设计依赖于一个已经创建的指向该对象 shared_ptr，为了达到这一点，std::enable_shared_from_this 会将其构造函数声明为 private 层级，并只允许用户通过其提供的工厂函数来创建对象，例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Widget</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 完美转发参数给 private 构造函数的工厂函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    …</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 和前面一样</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    …</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    …                   <span class="token comment">// 构造函数</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="item20-对于类似stdshared_ptr但有可能空悬的指针使用stdweak_ptr"><a class="anchor" href="#item20-对于类似stdshared_ptr但有可能空悬的指针使用stdweak_ptr">#</a> item20 对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</h3><p>抛开 std::weak_ptr 这个糟糕的命名，大众对于其功能理解大多还停留在八股中循环引用问题中。其实，最适合使用 std::weak_ptr 的场景应该在其它地方。</p><p>std::weak_ptr 是 std::shared_ptr 的合作对象，它不能直接访问对象，也不能检查是否为空。weak_ptr 一般是通过 shared_ptr 来创建的，但其并不影响指向对象的引用计数。可以这样创建：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> spw <span class="token operator">=</span>                      <span class="token comment">//spw 创建之后，指向的 Widget 的</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 引用计数（ref count，RC）为 1。</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                                <span class="token comment">//std::make_shared 的信息参见条款 21</span></pre></td></tr><tr><td data-num="4"></td><td><pre>…</pre></td></tr><tr><td data-num="5"></td><td><pre>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">wpw</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//wpw 指向与 spw 所指相同的 Widget。引用计数仍为 1</span></pre></td></tr><tr><td data-num="6"></td><td><pre>…</pre></td></tr><tr><td data-num="7"></td><td><pre>spw <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>                  <span class="token comment">//RC 变为 0，Widget 被销毁。</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                                <span class="token comment">//wpw 现在悬空</span></pre></td></tr></table></figure><p>可以这样判断其指向的对象是否失效：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>wpw<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> …</pre></td></tr></table></figure><p>weak_ptr 一般用于这样的一个场景：用原子操作来校验一个对象是否失效，如果没有，就访问它。这个操作可以通过使用 weak_ptr 创建 shared_ptr 来实现，该操作有两种形式：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果 wpw 过期，spw1 就为空</span></pre></td></tr><tr><td data-num="2"></td><td><pre> 											</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">auto</span> spw2 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 同上，但是使用 auto</span></pre></td></tr></table></figure><p>另一种：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 如果 wpw 过期，抛出 std::bad_weak_ptr 异常</span></pre></td></tr></table></figure><p>总结：</p><ul><li>用 <code>std::weak_ptr</code> 替代可能会悬空的 <code>std::shared_ptr</code> 。</li><li><code>std::weak_ptr</code> 的潜在使用场景包括：缓存、观察者列表、打破 <code>std::shared_ptr</code> 环状结构。</li></ul><h3 id="item21-优先选用stdmake_unique和stdmake_shared而非直接使用new"><a class="anchor" href="#item21-优先选用stdmake_unique和stdmake_shared而非直接使用new">#</a> item21 优先选用 std::make_unique 和 std::make_shared, 而非直接使用 new</h3><ul><li>相比于直接使用 new 表达式，make 系列函数消除了重复代码、改进了异常安全性，并且对 std::make_shared 和 std::allocated_shared 而言，生成的目标代码会尺寸更小、速度更快。</li><li>不适于使用 make 系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始化物。</li><li>对于 std::shared_ptr, 不建议使用 make 系列函数的额外场景包括：1. 自定义内存管理的类。2. 内存紧张的系统、非常大的对象、以及存在比指向相同对象的 std::shared_ptr 生存期更久的 std::weak_ptr</li></ul><h3 id="item22-使用pimpl惯用法时将特殊成员函数的定义放到实现文件中"><a class="anchor" href="#item22-使用pimpl惯用法时将特殊成员函数的定义放到实现文件中">#</a> item22 使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</h3><ul><li>Pimpl 惯用法通过降低类的客户和类实现者之间的依赖性，减少了构建变数。</li><li>对于采用 std::unique_ptr 来实现的 pImpl 指针，须在类的头文件中声明特种成员函数，但在实现文件中实现它们。即使默认函数实现有着正确行为。也必须这样做。</li><li>上述建议仅使用与 std::unique_ptr, 但并不适用 std::shared_ptr</li></ul><h2 id="chapter5-右值引用-移动语义和完美转发"><a class="anchor" href="#chapter5-右值引用-移动语义和完美转发">#</a> chapter5 右值引用、移动语义和完美转发</h2><p>对于刚接触移动语义和完美转发这两个概念的程序员来说，它们显得非常的名副其实：</p><ul><li><strong>移动语义</strong> 使得编译器得以使用不那么昂贵的移动操作，来替换昂贵的复制操作，也使得创建类似 std::unique_ptr, std::thread 这样的 <strong>只移类型对象</strong>成为可能。</li><li><strong>完美转发</strong> 使得人们可以撰写接收任意实参的函数模板，并将其转发到其他函数，<strong>目标函数会接受到与转发函数所接受的完全相同的实参</strong></li></ul><p>而<strong>右值引用</strong>是将这两个看似风马牛不相及的语言特性胶合起来的底层语言机制，正是它使得移动语义和完美转发成为了可能。</p><p>接下来这段话可能会激发一些读者的兴趣，阅读后请带着疑问仔细阅读这一章，并最后回来看看作者的这一段话，相信你的理解会更上一层楼：</p><blockquote><p>你与这两个语言特性打的交道越多，你就越会发现，你的初印象只不过是冰山一角。移动语义、完美转发和右值引用的世界比它所呈现的更加微妙。举个例子， <code>std::move</code> 并不移动任何东西，完美转发也并不完美。移动操作并不永远比复制操作更成本更低；即便如此，它也并不总是像你期望的那么低。而且，它也并不总是被调用，即使在当移动操作可用的时候。构造 “ <code>type&amp;&amp;</code> ” 也并非总是代表一个右值引用。</p></blockquote><p>最后，请铭记：形参总是左值，即使其类型是右值引用。</p><h3 id="item23-理解stdmove和stdforward"><a class="anchor" href="#item23-理解stdmove和stdforward">#</a> item23 理解 std::move 和 std::forward</h3><p>开门见山，其实 std::move 和 std::forward 做什么和不做什么很简单：</p><ul><li>std::move 不进行任何移动，std::forward 也不进行任何转发。这两者在运行期都无所作为。它们不会生成任何可执行代码，连一个字节都不会生成。</li><li>std::move 和 std::forward 都是仅仅执行强制类型转换的函数（其实是函数模板）。std::move 无条件地将实参强制转换为右值，而 std::forward 则仅在某个特定条件满足时才执行同一个强制转换。</li></ul><p>不信的话，请看看这个 C++11 中 std::move 的示例实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">// 在 std 命名空间内</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span>                          <span class="token comment">// 别名声明，见条款 9</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>该函数返回类型的 &amp;&amp; 部分表明 std::move 函数返回的是一个右值引用，但是，正如 Item28 所述，如果类型 T 恰好是一个左值引用，那么 T&amp;&amp; 将会成为一个左值引用。为了避免如此，type trait（见 Item9）std::remove_reference 应用到了类型 T 上，因此确保了 &amp;&amp; 被正确的应用到了一个不是引用的类型上。这保证了 std::move 返回的真的是右值引用，这很重要，因为函数返回的右值引用是右值。因此，<strong>std::move 将它的实参转换为一个右值，这就是它的全部作用</strong>。</p><p>事实上，右值也不总是会被移动。假设你有一个类，它用来表示一段注解。这个类的构造函数接受一个包含有注解的 std::string 作为形参，然后它复制该形参到数据成员。假设你看了 item41，你会声明一个值传递的形参：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Annotation</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">explicit</span> <span class="token function">Annotation</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>    …                                    </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>但是 Annotation 类的构造函数仅仅是需要读取 text 的值，它并不需要修改它。为了和历史悠久的传统：能使用 const 就使用 const 保持一致，你修订了你的声明以使 text 变成 const：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Annotation</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">explicit</span> <span class="token function">Annotation</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    …</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当复制 text 到一个数据成员的时候，为了避免一次复制操作的代价，你按 Item41 的建议，把 std::move 应用到 text 上，因此产生一个右值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Annotation</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">explicit</span> <span class="token function">Annotation</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    ：<span class="token function">value</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">//“移动” text 到 value 里；这段代码执行起来</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span>                       <span class="token comment">// 并不是看起来那样</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    …</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    std<span class="token double-colon punctuation">::</span>string value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这段代码可以编译，可以链接，可以运行，但是，在你不知道的角落，<strong>text 并不是被移动到 value，而是被拷贝</strong>。诚然，text 通过 std::move 被转换到右值，但是 text 被声明为 const std::string，所以在转换之前，text 是一个左值的 const std::string，而转换的结果是一个右值的 const std::string，但是<strong>纵观全程，const 属性一直保留。</strong></p><p>当编译器决定哪一个 std::string 的构造函数被调用时，考虑它的作用，将会有两种可能性：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">string</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">//std::string 事实上是</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span>                         <span class="token comment">//std::basic_string&lt;char > 的类型别名</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    …</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">string</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拷贝构造函数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">string</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 移动构造函数</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    …</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在类 Annotation 的构造函数的成员初始化列表中，std::move (text) 的结果是一个 const std::string 的右值。这个右值不能被传递给 std::string 的移动构造函数，因为移动构造函数只接受一个指向 non-const 的 std::string 的右值引用。然而，该右值却可以被传递给 std::string 的拷贝构造函数，因为 lvalue-reference-to-const 允许被绑定到一个 const 右值上。因此，std::string 在成员初始化的过程中调用了拷贝构造函数，即使 text 已经被转换成了右值。这样是为了确保维持 const 属性的正确性。从一个对象中移动出某个值通常代表着修改该对象，所以语言不允许 const 对象被传递给可以修改他们的函数（例如移动构造函数）。</p><p>从这个例子中，可以总结出两点 **。第一，不要在你希望能移动对象的时候，声明他们为 const。对 const 对象的移动请求会悄无声息的被转化为拷贝操作。第二点，std::move 不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。关于 std::move，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。**</p><p>之前谈到：std::forward 是一个有条件的强制类型转换，为了说明这一点，请看以下这个 std::forward 的典型使用场景，即某个函数模板使用万能引用类型的形参，随后将其传递给另外一个函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> lvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 处理左值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 处理右值</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                        <span class="token comment">// 用以转发 param 到 process 的模板</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">logAndProcess</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">auto</span> now <span class="token operator">=</span>                              <span class="token comment">// 获取现在时间</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span><span class="token string">"Calling 'process'"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们期望的是：当我们使用左值来调用 logAndProcess 时，该左值被当作左值转发给 process 函数，而当我们使用右值来调用 logAndProcess 函数时，process 函数的右值重载版本被调用。但这个期望在不使用 std::forward 的前提下是做不到的，因为所有函数形参皆为左值，param 亦不例外。为了避免这个结果，我们需要一种机制：当且仅当传递给函数 logAndProcess 的用以初始化 param 的实参是一个右值时，param 会被转换为一个右值。这就是 std::forward 做的事情 **。这就是为什么 std::forward 是一个有条件的转换：它的实参用右值初始化时，转换为一个右值。**</p><p>至于 std::forward 是如何分辨 param 是通过左值还是右值完成初始化的，见 item28。</p><h3 id="item24-区分万能引用和右值引用"><a class="anchor" href="#item24-区分万能引用和右值引用">#</a> item24 区分万能引用和右值引用</h3><ul><li>如果函数模板形参具备 T&amp;&amp; 类型，并且 T 的类型系推导而来，或如果对象使用 auto&amp;&amp; 声明其类型，则该形参或对象就是个万能引用</li><li>如果类型声明并不精确地具备 type&amp;&amp; 的形式，或者类型推导并未发生，则 type&amp;&amp; 就代表右值引用。</li><li>若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用。</li></ul><h3 id="item25-针对右值引用实施stdmove针对万能引用实施stdforward"><a class="anchor" href="#item25-针对右值引用实施stdmove针对万能引用实施stdforward">#</a> item25 针对右值引用实施 std::move, 针对万能引用实施 std::forward</h3><ul><li>针对右值引用的最后一次使用实施 std::move, 针对万能引用的最后一次使用实施 std::forward</li><li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为。</li><li>若局部对象可能适用于返回值优化，则请勿针对其实施 std::move 或 std::forward</li></ul><h3 id="item26-避免依万能引用类型进行重载"><a class="anchor" href="#item26-避免依万能引用类型进行重载">#</a> item26 避免依万能引用类型进行重载</h3><p>假设一个函数有接收一个万能引用形参的版本，以及一个接收其它类型形参的重载版本，那么会调用哪一个呢？根据 C++ 的函数签名匹配原则，当实参的类型和常规函数的类型<strong>完全匹配</strong>的时候，我们才能调用到改常规函数，因为在存在参数类型能够完全匹配的模板函数和常规函数的时候，编译器会首先选择常规函数。可想而知，大部分情况下，编译器将会选择使用 “万能引用” 版本的函数重载。考虑这样两个函数重载：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>logAndAdd 的作用是取一个名字，记录下当前日期和时间，再把该名字添加到一个全局数据结构中。在第一个版本中，我们的日志函数接收一个 name (左值或右值的与 string 类型相关的参数)，第二个版本中，我们接收一个 idx 并从 nameFromIdx 函数中得到一个 name。</p><p>于是，这些调用都能正常工作：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>string <span class="token function">petName</span><span class="token punctuation">(</span><span class="token string">"Darla"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 跟之前一样</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">logAndAdd</span><span class="token punctuation">(</span>petName<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 跟之前一样，</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">logAndAdd</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Persephone"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 这些调用都去调用</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token string">"Patty Dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//T&amp;&amp; 重载版本</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 调用 int 重载版本</span></pre></td></tr></table></figure><p>但是，如果这样，函数将会出错：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">short</span> nameIdx<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">logAndAdd</span><span class="token punctuation">(</span>nameIdx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>** 这是因为，形参类型为 T&amp;&amp; 的版本可以将 T 推导为 short，从而产生一个精确匹配，而 int 版本的重载却需要参数进行一个隐式类型转换。** 所以，形参类型为万能引用的版本才是被调用到的版本。</p><p>可见，形参为万能引用的函数，是 C++ 中最贪婪地。它们会在具现过程中，和几乎任何实参类型都会产生精确匹配。这就是为何把重载和万能引用结合起来几乎总是馊主意：一旦万能引用成为重载候选，它就会吸引走大批的实参类型。</p><p>除此之外，我们还需要避免对类的构造函数添加一个万能引用版本，与前所述，原因和函数重载的原因是一致的，因为编译器会帮我们生成一系列构造函数，所以可以看做构造函数也是有多个重载版本的。如果添加万能引用版本构造函数，不仅基类，派生类中对基类的复制和移动构造函数的调用都很有可能会受到 “劫持”。</p><p>不过，当我们需要对绝大多数实参类型进行完美转发，只针对少数类型实施特殊处理，应该怎么做呢？答案在 item27。</p><div class="tags"><a href="/tags/C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> C++ 读书笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-11-20 16:39:35" itemprop="dateModified" datetime="2024-11-20T16:39:35+08:00">2024-11-20</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="MikeMao 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="MikeMao 支付宝"><p>支付宝</p></div><div><img data-src="/imagesnull" alt="MikeMao 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>MikeMao <i class="ic i-at"><em>@</em></i>MikeMao's blog</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="Efective Modern C++读书笔记">http://example.com/2024/08/31/Efective-Modern-C-读书笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;lz.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicli3sbvtj20zk0m8x6p.jpg" title="Effective C++读书笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>Effective C++读书笔记</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.</span> <span class="toc-text">chapter 1 类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item1-%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.1.</span> <span class="toc-text">item1 理解模板类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B51-paramtype%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E4%BD%86%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">情况 1： ParamType 是一个指针或引用，但不是一个万能引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B52-paramtype-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">情况 2： ParamType 是一个万能引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B53-paramtype%E6%97%A2%E9%9D%9E%E6%8C%87%E9%92%88%E4%B9%9F%E9%9D%9E%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">情况 3： ParamType 既非指针，也非引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">数组实参与函数实参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item2-%E7%90%86%E8%A7%A3auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.3.</span> <span class="toc-text">item2 理解 auto 类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item3-%E7%90%86%E8%A7%A3decltype"><span class="toc-number">1.4.</span> <span class="toc-text">item3 理解 decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item4-%E6%8E%8C%E6%8F%A1%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%BB%93%E6%9E%9C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">item4 掌握查看类型推导结果的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter2-auto"><span class="toc-number">2.</span> <span class="toc-text">chapter2 auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item5-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8auto%E8%80%8C%E9%9D%9E%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">item5 优先选用 auto , 而非显示类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item6-auto%E6%8E%A8%E5%AF%BC%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E6%97%B6%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%AF%E7%94%A8%E6%B3%95explicitly-typed-initializer-idiom"><span class="toc-number">2.2.</span> <span class="toc-text">item6 auto 推导不符合要求时，使用显式类型初始化惯用法 (explicitly typed initializer idiom)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter3-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c"><span class="toc-number">3.</span> <span class="toc-text">chapter3 转向现代 C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item7-%E5%9C%A8%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%B3%A8%E6%84%8F%E5%8C%BA%E5%88%86%E5%92%8C"><span class="toc-number">3.1.</span> <span class="toc-text">item7 在创建对象时注意区分 () 和 {}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item8-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8nullptr%E8%80%8C%E9%9D%9E0%E6%88%96null"><span class="toc-number">3.2.</span> <span class="toc-text">item8 优先使用 nullptr, 而非 0 或 NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item9-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E8%80%8C%E9%9D%9Etypedef"><span class="toc-number">3.3.</span> <span class="toc-text">item9 优先选用别名声明，而非 typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item10-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%80%8C%E9%9D%9E%E4%B8%8D%E9%99%90%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">item10 优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item11-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0%E8%80%8C%E9%9D%9Eprivate%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">item11 优先选用删除函数，而非 private 未定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item12-%E4%B8%BA%E6%84%8F%E5%9C%A8%E6%94%B9%E5%86%99%E7%9A%84%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0override%E5%A3%B0%E6%98%8E"><span class="toc-number">3.6.</span> <span class="toc-text">item12 为意在改写的函数添加 override 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item13-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8const_iterator%E8%80%8C%E9%9D%9Eiterator"><span class="toc-number">3.7.</span> <span class="toc-text">item13 优先选用 const_iterator, 而非 iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-14-%E5%8F%AA%E8%A6%81%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%B0%B1%E4%B8%BA%E5%85%B6%E5%8A%A0%E4%B8%8Anoexcept%E5%A3%B0%E6%98%8E"><span class="toc-number">3.8.</span> <span class="toc-text">item 14 只要函数不会抛出异常，就为其加上 noexcept 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item15-%E5%8F%AA%E8%A6%81%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8constexpr%E5%B0%B1%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="toc-number">3.9.</span> <span class="toc-text">item15 只要有可能使用 constexpr , 就使用它</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item16-%E4%BF%9D%E8%AF%81const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.10.</span> <span class="toc-text">item16 保证 const 成员函数的线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item17-%E7%90%86%E8%A7%A3%E7%89%B9%E7%A7%8D%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6"><span class="toc-number">3.11.</span> <span class="toc-text">item17 理解特种成员函数的生成机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">4.</span> <span class="toc-text">chapter4 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item18-%E4%BD%BF%E7%94%A8stdunique_ptr%E7%AE%A1%E7%90%86%E5%85%B7%E5%A4%87%E4%B8%93%E5%B1%9E%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">4.1.</span> <span class="toc-text">item18 使用 std::unique_ptr 管理具备专属所有权的资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item19-%E4%BD%BF%E7%94%A8stdshared_ptr%E7%AE%A1%E7%90%86%E5%85%B7%E5%A4%87%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">4.2.</span> <span class="toc-text">item19 使用 std::shared_ptr 管理具备共享所有权的资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item20-%E5%AF%B9%E4%BA%8E%E7%B1%BB%E4%BC%BCstdshared_ptr%E4%BD%86%E6%9C%89%E5%8F%AF%E8%83%BD%E7%A9%BA%E6%82%AC%E7%9A%84%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8stdweak_ptr"><span class="toc-number">4.3.</span> <span class="toc-text">item20 对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item21-%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8stdmake_unique%E5%92%8Cstdmake_shared%E8%80%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8new"><span class="toc-number">4.4.</span> <span class="toc-text">item21 优先选用 std::make_unique 和 std::make_shared, 而非直接使用 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item22-%E4%BD%BF%E7%94%A8pimpl%E6%83%AF%E7%94%A8%E6%B3%95%E6%97%B6%E5%B0%86%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%94%BE%E5%88%B0%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">4.5.</span> <span class="toc-text">item22 使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter5-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">chapter5 右值引用、移动语义和完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#item23-%E7%90%86%E8%A7%A3stdmove%E5%92%8Cstdforward"><span class="toc-number">5.1.</span> <span class="toc-text">item23 理解 std::move 和 std::forward</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item24-%E5%8C%BA%E5%88%86%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">item24 区分万能引用和右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item25-%E9%92%88%E5%AF%B9%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%9E%E6%96%BDstdmove%E9%92%88%E5%AF%B9%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%AE%9E%E6%96%BDstdforward"><span class="toc-number">5.3.</span> <span class="toc-text">item25 针对右值引用实施 std::move, 针对万能引用实施 std::forward</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item26-%E9%81%BF%E5%85%8D%E4%BE%9D%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">5.4.</span> <span class="toc-text">item26 避免依万能引用类型进行重载</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/" rel="bookmark" title="STL学习-01-智能指针与vector">STL学习-01-智能指针与vector</a></li><li><a href="/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" rel="bookmark" title="C++：移动语义与右值引用">C++：移动语义与右值引用</a></li><li><a href="/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Effective C++读书笔记">Effective C++读书笔记</a></li><li class="active"><a href="/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Efective Modern C++读书笔记">Efective Modern C++读书笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="MikeMao" data-src="/images/avatar.jpg"><p class="name" itemprop="name">MikeMao</p><div class="description" itemprop="description">a student of NJU && record learning experience</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">16</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hb2Rpbmcx" title="https:&#x2F;&#x2F;github.com&#x2F;maoding1"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE0OTkzNzQzMzM=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1499374333"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjIxMTA5ODMyNUBzbWFpbC5uanUuZWR1LmNu" title="mailto:211098325@smail.nju.edu.cn"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/" title="STL学习-01-智能指针与vector">STL学习-01-智能指针与vector</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a></div><span><a href="/2024/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/" title="分布式一致性算法">分布式一致性算法</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/02/15/python%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%80%89%E8%AF%BE/" title="python实现自动选课">python实现自动选课</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/2022/09/30/Linux%E2%80%9401-Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E8%AF%86/" title="Linux—01-Linux安装常识">Linux—01-Linux安装常识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="分类于 编译原理">编译原理</a></div><span><a href="/2023/03/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8601-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" title="编译原理01-词法分析">编译原理01-词法分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/go/" title="分类于 go">go</a></div><span><a href="/2023/07/21/golang-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%8D%E5%85%B8/" title="golang-命令行词典">golang-命令行词典</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2023/03/16/nova%E2%80%94%E2%80%94%E9%AB%98%E8%80%83%E7%BD%91%E7%AB%99%E5%AD%A6%E6%A0%A1%E5%90%8D%E7%A7%B0%E7%88%AC%E5%8F%96/" title="nova——高考网站学校名称爬取">nova——高考网站学校名称爬取</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 python">python</a></div><span><a href="/2023/01/25/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/" title="python爬虫学习">python爬虫学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/TVM/" title="分类于 TVM">TVM</a></div><span><a href="/2023/02/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BC%96%E8%AF%91%E5%99%A8TVM-UserTutorial/" title="深度学习编译器TVM-UserTutorial">深度学习编译器TVM-UserTutorial</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C++">C++</a></div><span><a href="/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" title="C++：移动语义与右值引用">C++：移动语义与右值引用</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">MikeMao @ MikeMao's blog</span></div><div id="running-time">博客已经运行了 <span id="years">0</span> 年 <span id="days">0</span> 天 <span id="hours">0</span> 小时 <span id="minutes">0</span> 分 <span id="seconds">0</span> 秒</div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div><script>function updateRunningTime(){const e=new Date("2022-09-30T00:00:00"),t=new Date,n=t-e,o=Math.floor(n/1e3%60),d=Math.floor(n/1e3/60%60),m=Math.floor(n/1e3/60/60%24),u=Math.floor(n/1e3/60/60/24%365),a=Math.floor(n/1e3/60/60/24/365);document.getElementById("years").textContent=a,document.getElementById("days").textContent=u,document.getElementById("hours").textContent=m,document.getElementById("minutes").textContent=d,document.getElementById("seconds").textContent=o}updateRunningTime(),setInterval(updateRunningTime,1e3)</script></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/08/31/Efective-Modern-C-读书笔记/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->