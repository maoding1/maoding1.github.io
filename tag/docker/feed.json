{
    "version": "https://jsonfeed.org/version/1",
    "title": "MikeMao's blog • All posts by \"docker\" tag",
    "description": "a student of NJU && record learning experience",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/06/27/%E4%BA%91%E5%8E%9F%E7%94%9F-docker%E5%85%A5%E9%97%A8/",
            "url": "http://example.com/2023/06/27/%E4%BA%91%E5%8E%9F%E7%94%9F-docker%E5%85%A5%E9%97%A8/",
            "title": "云原生-docker入门",
            "date_published": "2023-06-27T09:54:04.000Z",
            "content_html": "<h1 id=\"云原生-docker-k8s-springboot\"><a class=\"anchor\" href=\"#云原生-docker-k8s-springboot\">#</a> 云原生 docker + k8s + springboot</h1>\n<h2 id=\"云原生的本质\"><a class=\"anchor\" href=\"#云原生的本质\">#</a> 云原生的本质</h2>\n<p>根据微服务将应用进行细分，将每一部分打包放入对应的容器，动态统筹管理容器，实现资源利用最大化。</p>\n<h2 id=\"什么是docker\"><a class=\"anchor\" href=\"#什么是docker\">#</a> 什么是 Docker</h2>\n<p>Docker 是 Docker 公司开源的一种最流行的容器实现方案，极大方便了应用服务部署。</p>\n<p>Docker 可以将应用、配置、和环境打包，形成了一个独立的类似于 iOS APP 形式的 <strong>应用</strong>，此应用可以直接分发到任意一个支持 Docker 的环境中，通过简单的命令即可运行。</p>\n<p>Docker 使得容器化技术使用非常方便，极大地推进了容器行业的发展与容器技术标准化。</p>\n<blockquote>\n<p>docker 口号： build once, run anywhere</p>\n</blockquote>\n<h2 id=\"docker的优势\"><a class=\"anchor\" href=\"#docker的优势\">#</a> Docker 的优势</h2>\n<ul>\n<li>环境一致性</li>\n<li>资源独立与隔离</li>\n<li>轻量化</li>\n</ul>\n<h2 id=\"通过docker容器配置nginx静态网页\"><a class=\"anchor\" href=\"#通过docker容器配置nginx静态网页\">#</a> 通过 docker 容器配置 Nginx 静态网页</h2>\n<p>从 docker 仓库下载具有默认 Nginx 配置的容器：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull nginx</pre></td></tr></table></figure><p>现在有了镜像，但是镜像和容器的关系就像类和实例，要真正运行还要创建一个容器：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> docker-nginx <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 nginx</pre></td></tr></table></figure><p>参数说明：</p>\n<ul>\n<li>run 是创建新容器的命令</li>\n<li>--name 标志是指定容器名称的方式。如果为空，将分配一个生成的名称。</li>\n<li>-p 以 - p local-machine-port:internal-container-port 的格式指定公开的端口，比如这里将容器中的端口：80 映射到宿主机的端口：80</li>\n<li>nginx 是镜像名称，也就是刚刚 pull 下来的镜像，没有 tag 表示用最新 (latest)</li>\n</ul>\n<p>此时在浏览器输入本地 ip 可看到 nginx 默认登录界面：</p>\n<p><img data-src=\"image-20230627181050252.png\" alt=\"image-20230627181050252\"></p>\n<p>此时必须用 CTRL+c 在命令行中停止容器运行。可以使用 docker ps -a 查看此时的容器状态。</p>\n<p><img data-src=\"image-20230627181625674.png\" alt=\"image-20230627181625674\"></p>\n<p>可以使用</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-vf</span> docker-nginx</pre></td></tr></table></figure><p>删除现有的 dorker-nginx 容器。</p>\n<h2 id=\"daemon模式下运行\"><a class=\"anchor\" href=\"#daemon模式下运行\">#</a> Daemon 模式下运行</h2>\n<p>上面启动的容器还未与 terminal 分离，必须手动 CTRL+c 停止运行 才能输入后续指令，而在 daemon 模式下我们可以将容器交给 Daemon 进程，即一个守护进程托管，让其在后台运行。</p>\n<p>创建一个保存网页内容的文件夹：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> ~/docker-nginx/html</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> ~/docker-nginx/html</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">vim</span> index.html</pre></td></tr></table></figure><p>编写网页内容：</p>\n<figure class=\"highlight html\"><figcaption data-lang=\"HTML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>Docker nginx Tutorial<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>container<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Hello World<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>this page is provided by nginx<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>然后使用命令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> docker-nginx <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-v</span> ~/docker-nginx/html:/usr/share/nginx/html nginx</pre></td></tr></table></figure><p>参数说明：</p>\n<ul>\n<li>-v 标志开启挂载功能，: 的左侧是服务器（宿主机）上的位置：右侧是链接到的容器内的位置</li>\n<li>-d 采用 daemon 模式</li>\n<li><code>/usr/share/nginx/html</code>  是 nginx 服务器默认用于存储静态 HTML 网页和其他资源的位置，通常情况下会在这个目录中存放可由 Web 浏览器访问的 HTML 文件、CSS 文件、JavaScript 文件和图像文件等。</li>\n</ul>\n<p>结果：</p>\n<p><img data-src=\"image-20230627183153353.png\" alt=\"image-20230627183153353\"></p>\n<h2 id=\"使用dockerfile创建本地镜像\"><a class=\"anchor\" href=\"#使用dockerfile创建本地镜像\">#</a> 使用 Dockerfile 创建本地镜像</h2>\n<h3 id=\"什么是dockerfile\"><a class=\"anchor\" href=\"#什么是dockerfile\">#</a> 什么是 Dockerfile</h3>\n<p><img data-src=\"image-20230627190343246.png\" alt=\"image-20230627190343246\"></p>\n<h3 id=\"使用dockerfile创建2048镜像并运行\"><a class=\"anchor\" href=\"#使用dockerfile创建2048镜像并运行\">#</a> 使用 Dockerfile 创建 2048 镜像并运行</h3>\n<p>Dockerfile 的内容如下：</p>\n<figure class=\"highlight dockerfile\"><figcaption data-lang=\"Docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># Pull base image.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> nginx:latest</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> 2048-master /usr/share/nginx/html</span></pre></td></tr></table></figure><p>在 Dockerfile 的同级目录下存放了 2048-master 文件夹，其中包含了 2048 网页版的资源</p>\n<p>使用命令</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> my-2048 <span class=\"token builtin class-name\">.</span></pre></td></tr></table></figure><p>创建一个名为 my-2048 的镜像 最后的。表示 Dockerfile 在当前目录下。</p>\n<p>-t 指定镜像的名字</p>\n<p>然后使用</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> <span class=\"token number\">2048</span> <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 my-2048</pre></td></tr></table></figure><p>创建并启动一个容器</p>\n<p>此时打开 localhost：</p>\n<p><img data-src=\"image-20230627191156151.png\" alt=\"image-20230627191156151\"></p>\n<h2 id=\"docker镜像管理\"><a class=\"anchor\" href=\"#docker镜像管理\">#</a> Docker 镜像管理</h2>\n<p><img data-src=\"image-20230627192134665.png\" alt=\"image-20230627192134665\"></p>\n<h2 id=\"docker容器管理\"><a class=\"anchor\" href=\"#docker容器管理\">#</a> Docker 容器管理</h2>\n<p><img data-src=\"image-20230627192437509.png\" alt=\"image-20230627192437509\"></p>\n<h2 id=\"docker原理\"><a class=\"anchor\" href=\"#docker原理\">#</a> Docker 原理</h2>\n<h3 id=\"docker组成架构\"><a class=\"anchor\" href=\"#docker组成架构\">#</a> Docker 组成架构</h3>\n<p>Docker 采用 C/S 架构，client 通过接口与 Server 进程通信实现容器的构建，运行和发布。</p>\n<p>Docker 由五个部分组成</p>\n<p>－<strong>Docker Client</strong> <strong>客户端</strong>，负责向服务端（Docker Daemon 守护进程）发起请求</p>\n<p>－<strong>Docker Daemon</strong> <strong>守护进程</strong>，负责 从 Docker Registry 下载 Docker 镜像和通过 Docker 镜像 启动 Docker 容器</p>\n<p>－<strong>Docker Registry</strong> <strong>仓库</strong>，负责存储 Docker 镜像</p>\n<p>－<strong>Docker Container</strong> <strong>容器</strong></p>\n<p>－<strong>Docker Image</strong> <strong>镜像</strong></p>\n<p><img data-src=\"image-20230628141358473.png\" alt=\"image-20230628141358473\"></p>\n<h2 id=\"docker运行容器流程\"><a class=\"anchor\" href=\"#docker运行容器流程\">#</a> Docker 运行容器流程</h2>\n<ol>\n<li>\n<p>Docker Client 执行 docker run，Docker Daemon 收到来自 client 的请求；</p>\n</li>\n<li>\n<p>Docker Daemon 优先查找本地镜像，如果本地没有，Docker daemon 会从远端镜像仓库拉取所需镜像；</p>\n</li>\n<li>\n<p>启动 Linux Namespace 配置，设置指定的 Cgroups 参数，挂载 rootfs（容器镜像），切换进程的根目录；</p>\n</li>\n<li>\n<p>容器运行。</p>\n</li>\n</ol>\n<p><img data-src=\"image-20230628141534884.png\" alt=\"image-20230628141534884\"></p>\n<h2 id=\"docker容器文件系统\"><a class=\"anchor\" href=\"#docker容器文件系统\">#</a> Docker 容器文件系统</h2>\n<p>Docker 容器的 rootfs 使用的是 UnionFS（联合文件系统）。</p>\n<p>UnionFS 是通过联合挂载多个文件目录得到的一个完整的文件系统。容器 rootfs 看起来是一个可读、可写的具备完整功能的独立文件系统，但实际上由多层只读层和一个专属于该容器的读写层联合挂载而成。</p>\n<p>Linux 中支持的 UnionFS 实现有 overlay2、aufs、btrfs，其中最常用的就是 overlay2。</p>\n<p><img data-src=\"image-20230628145756899.png\" alt=\"image-20230628145756899\"></p>\n<p>在准备容器 rootfs 时联合挂载用到的多层目录是哪来的呢？</p>\n<p>－<strong>读写层</strong>，每个容器都有自己专属的读写层，该层由 docker 在创建此容器时创建的。</p>\n<p>－<strong>只读层</strong>，每个容器的 rootfs 都会包含好几层只读层，该层由 docker 在拉取镜像时将镜像中的各层解压到 docker 的数据目录得到的。</p>\n<p>总结</p>\n<p>－容器镜像与容器 rootfs 的关联</p>\n<p>Docker 拉取镜像解压到 docker 数据目录后得到只读层；</p>\n<p>Docker 创建容器时使用数据目录中的读写层联合挂载得到容器 rootfs</p>\n<p><img data-src=\"image-20230628145830246.png\" alt=\"image-20230628145830246\"></p>\n<h1 id=\"kubernetes\"><a class=\"anchor\" href=\"#kubernetes\">#</a> kubernetes</h1>\n<h2 id=\"什么是kubernetes\"><a class=\"anchor\" href=\"#什么是kubernetes\">#</a> 什么是 kubernetes</h2>\n<p>kubernetes 是开源的容器集群管理项目，诞生于 2014 年，有 Google 公司发起，试图为基于容器的应用部署和管理打造一个强大引擎。使用 go 语言构造。</p>\n<ul>\n<li>一个基于容器技术的分布式架构领先方案</li>\n<li>一个生产级容器编排工具</li>\n<li>一个完备的分布式学习通支撑平台</li>\n</ul>\n<p>竞品： Mesos， Docker Swarm</p>\n<p>我们在应用容器化的过程中会涉及到封装、调度单容器，也会涉及到解决各个容器间的类型关系，比如 web 容器会涉及到与 DB 容器的交互，可以通过建立 “link” 来将 DB 容器中的信息注入到 web 容器中。但这样做的缺陷在于缺少普适性，随着系统的扩大，容器间的 “link” 会越来越复杂。</p>\n<p>Kubernetes 的优势就在于：从设计之初就<strong>以统一的方式定义任务之间的各种关系</strong>， 并且为将来支持更多种类的关系留有余地，能够按照用户的意愿和整个系统的规则，完全自动化地处理好容器之间的各种关系，这个过程也就是<strong>编排</strong>。而其他很多集群管理项目（比如 Yarn、Mesos，以及 Swarm）擅长的，把一个容器按规则，放置在某个最佳节点上运行的功能则称为<strong>调度</strong>。</p>\n<p>容器本质是进程，那 Kubernetes 作为具有普遍意义的容器编排工具，就是云操作系统。</p>\n<p>理解 Kubernetes 设计理念是学习 Kubernetes 的前提。我们需要聚焦在两个问题：</p>\n<p>l <strong>如何处理应用与应用之间的关系？</strong></p>\n<p>l <strong>如何恰当的容器化一个应用？</strong></p>\n<p>第一个问题，应用与应用之间的关系可以细化为容器间的关系，具体来说是两类：一类关系是 “紧密交互” 的，即：这些应用之间需要频繁交互、访问，或者会直接通过本地文件进行信息交换。Kubernetes 把这类关系涉及到的一组容器划分为一个 <strong>“ Pod ”</strong>（ Kuberntes 最小调度单位），在这里面可以进行高效信息交换。</p>\n<p>另一类关系则是常见的应用间的普通访问，Kuberntes 通过定义 “<strong>服务对象</strong>” 来描述。比如 web 应用和数据库应用的交互，涉及到固定 IP 地址和端口以负载均衡的方式访问，就产生了 Service 对象来处理；加密授权的关系需求，则可由 Secret 对象解决等等。</p>\n<p>第二个问题，以 Pod 为基础为解决不同的场景需求衍生出了不同的解决方案，也就是<strong>基于 Pod 改进后的对象资源，称为 “编排对象”</strong>。比如被称为 DaemonSet 的对象资源，它可以像守护进程一样在每个宿主机上有且只能有一个 pod 副本；再比如 CronJob ，它专门用来描述定时任务等等。</p>\n<p>如下图所示，由 “Pod” 产生各类 “<strong>编排对象</strong>”，再为解决各种关系问题产生了类似 Service、Ingress 等 “<strong>服务对象</strong> ”。</p>\n<p><img data-src=\"/image-20230629231456801.png\" alt=\"image-20230629231456801\"></p>\n<h2 id=\"架构\"><a class=\"anchor\" href=\"#架构\">#</a> 架构</h2>\n<p><img data-src=\"image-20230723114238163.png\" alt=\"image-20230723114238163\"></p>\n<p>k8s 有一个 Master 节点负责与用户的通信和管理工作节点等工作，而每一个工作节点 (Node 节点) 对应一个真实的物理机或虚拟机，承担工作负载，Node 负责监控并汇报容器的状态，同时根据 Master 的要求管理容器生命周期。</p>\n<blockquote>\n<p>master 节点组件</p>\n<ul>\n<li><strong>API Server</strong>。<strong>K8S 的请求入口服务</strong>。API Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活。</li>\n<li><strong>Scheduler</strong>。<strong>K8S 所有 Worker Node 的调度器</strong>。当用户要部署服务时，Scheduler 会选择最合适的 Worker Node（服务器）来部署。</li>\n<li><strong>Controller Manager</strong>。<strong>K8S 所有 Worker Node 的监控器</strong>。Controller Manager 有很多具体的 Controller，在文章 **<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9tZWRpdW0uY29tLyU0MGt1bWFyZ2F1cmF2MTI0Ny9jb21wb25lbnRzLW9mLWt1YmVybmV0ZXMtYXJjaGl0ZWN0dXJlLTZmZWVhNGQ1YzcxMg==\">Components of Kubernetes Architecture</span>** 中提到的有 Node Controller、Service Controller、Volume Controller 等。Controller 负责监控和调整在 Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务。</li>\n<li><strong>etcd</strong>。<strong>K8S 的存储服务</strong>。etcd 存储了 K8S 的关键配置和用户配置，K8S 中仅 API Server 才具备读写权限，其他组件必须通过 API Server 的接口才能读写数据（见 **<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy90aGVuZXdzdGFjay5pby9ob3ctZG9lcy1rdWJlcm5ldGVzLXdvcmsv\">Kubernetes Works Like an Operating System</span>**）。\t\t\t\t--zhihu</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>node 节点组件</p>\n<ul>\n<li><strong>Kubelet</strong>。<strong>Worker Node 的监视器，以及与 Master Node 的通讯器</strong>。Kubelet 是 Master Node 安插在 Worker Node 上的 “眼线”，它会定期向 Worker Node 汇报自己 Node 上运行的服务的状态，并接受来自 Master Node 的指示采取调整措施。</li>\n<li><strong>Kube-Proxy</strong>。<strong>K8S 的网络代理</strong>。私以为称呼为 Network-Proxy 可能更适合？Kube-Proxy 负责 Node 在 K8S 的网络通讯、以及对外部网络流量的负载均衡。</li>\n<li><strong>Container Runtime</strong>。<strong>Worker Node 的运行环境</strong>。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine。大白话就是帮忙装好了 Docker 运行环境。</li>\n<li><strong>Logging Layer</strong>。<strong>K8S 的监控状态收集器</strong>。私以为称呼为 Monitor 可能更合适？Logging Layer 负责采集 Node 上所有服务的 CPU、内存、磁盘、网络等监控项信息。</li>\n<li><strong>Add-Ons</strong>。<strong>K8S 管理运维 Worker Node 的插件组件</strong>。有些文章认为 Worker Node 只有三大组件，不包含 Add-On，但笔者认为 K8S 系统提供了 Add-On 机制，让用户可以扩展更多定制化功能，是很不错的亮点。</li>\n</ul>\n</blockquote>\n<h2 id=\"k8s优势\"><a class=\"anchor\" href=\"#k8s优势\">#</a> k8s 优势</h2>\n<ul>\n<li>强大的容器编排能力</li>\n<li>轻量级</li>\n<li>开放开源</li>\n<li>优秀的 API 设计</li>\n<li>基于微服务模式的多层资源抽象模型</li>\n<li>可扩展性好</li>\n<li>自动化程度高</li>\n<li>部署支持多种环境</li>\n</ul>\n<h2 id=\"k8s常用命令\"><a class=\"anchor\" href=\"#k8s常用命令\">#</a> k8s 常用命令</h2>\n<h3 id=\"createapply\"><a class=\"anchor\" href=\"#createapply\">#</a> create/apply</h3>\n<p><code>kubectl apply/create -f [FILE NAME]</code></p>\n<p>kubectl create 属于</p>\n<h3 id=\"get\"><a class=\"anchor\" href=\"#get\">#</a> get</h3>\n<p><code>kubectl get pods|replicationcontrollers|services|namespaces|nodes|...|events [options]</code></p>\n<h3 id=\"describe\"><a class=\"anchor\" href=\"#describe\">#</a> describe</h3>\n<p>查看资源详细信息</p>\n<h3 id=\"logs\"><a class=\"anchor\" href=\"#logs\">#</a> logs</h3>\n<p>查看 pod 内容器日志</p>\n<h3 id=\"exec\"><a class=\"anchor\" href=\"#exec\">#</a> exec</h3>\n<p>在 pod 容器中执行命令</p>\n<h3 id=\"edit\"><a class=\"anchor\" href=\"#edit\">#</a> edit</h3>\n<p>编辑资源</p>\n<h3 id=\"delete\"><a class=\"anchor\" href=\"#delete\">#</a> delete</h3>\n<p>删除资源</p>\n<h3 id=\"故障检测\"><a class=\"anchor\" href=\"#故障检测\">#</a> 故障检测</h3>\n<p>放张图备用</p>\n<p><img data-src=\"v2-9437b19801b2a08dea506005a4dd2eb2_1440w.webp\" alt=\"img\"></p>\n<h1 id=\"springboot-入门\"><a class=\"anchor\" href=\"#springboot-入门\">#</a> Springboot 入门</h1>\n<h2 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h2>\n<ul>\n<li>独立运行的 spring 项目     spring boot 可以以 jar 包的形式独立运行</li>\n<li>内嵌 servlet 容器，应用无需打成 WAR 包。</li>\n<li>提供 starter 简化 Maven 配置</li>\n<li>提供了大量的自动配置</li>\n<li>自带应用监控</li>\n<li>无代码生成和 XML 配置</li>\n</ul>\n",
            "tags": [
                "docker"
            ]
        }
    ]
}