{
    "version": "https://jsonfeed.org/version/1",
    "title": "MikeMao's blog • All posts by \"编译原理\" tag",
    "description": "a student of NJU who use this website to record learning experience",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8605-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/",
            "url": "http://example.com/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8605-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/",
            "title": "编译原理05-目标代码生成",
            "date_published": "2023-06-02T06:38:27.000Z",
            "content_html": "<h1 id=\"编译原理05-目标代码生成\"><a class=\"anchor\" href=\"#编译原理05-目标代码生成\">#</a> 编译原理 05 - 目标代码生成</h1>\n<h2 id=\"risc-v指令集\"><a class=\"anchor\" href=\"#risc-v指令集\">#</a> RISC-V 指令集</h2>\n<p><img data-src=\"image-20230602144012905.png\" alt=\"image-20230602144012905\"></p>\n<p>精简指令集，精简的含义就是一条指令要么做运算，要么存，取内存。</p>\n<h3 id=\"寄存器\"><a class=\"anchor\" href=\"#寄存器\">#</a> 寄存器</h3>\n<p>RISC-V 有 32 个寄存器，名称分别为 X0,X1...X31</p>\n<p>但实际上不会按这些名称来使用，而是按照约定来使用，一些寄存器有专门的用途</p>\n<p><img data-src=\"image-20230602150421869.png\" alt=\"image-20230602150421869\"></p>\n<p>X0： zero 寄存器，专门存放数字 0</p>\n<p>ra： 存放 return address</p>\n<p>pc(X31): program counter</p>\n<h3 id=\"指令\"><a class=\"anchor\" href=\"#指令\">#</a> 指令</h3>\n<p>li ： 加载立即数\tli t0,0</p>\n<p>add: 加法，有三个操作数： add t5,t3,t4 , t5 = t3+t4</p>\n<p>addi： 加法，但有一个操作数是立即数</p>\n<p>risc-v 里没有 mov 指令，或者说 mov 指令是一个伪指令，实际上是用 add， target, source, zero 来实现的</p>\n<p>在.data 段声明全局变量：</p>\n<p>.data:</p>\n<p>g:  .word 0\t想.word 这样的是给汇编器看的，表示占用 4B</p>\n<p>数组：</p>\n<p>g: .word 0,1,2</p>\n<p>字符串：</p>\n<p>msg: .string &quot;The result is :&quot; #后面会自动加上 '\\0' 不想加就用.ascii</p>\n<p>使用全局变量：</p>\n<p>la t0, g  \t#la; load address</p>\n<p>lw t0, 0 (t0)\t#lw: load word 这里 0 表示偏移量 并且以字节为单位</p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2023/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8604-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/",
            "url": "http://example.com/2023/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8604-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/",
            "title": "编译原理04-中间代码生成",
            "date_published": "2023-05-05T06:02:27.000Z",
            "content_html": "<h1 id=\"编译原理04-中间代码生成\"><a class=\"anchor\" href=\"#编译原理04-中间代码生成\">#</a> 编译原理 04 - 中间代码生成</h1>\n<h2 id=\"llvm-ir简介\"><a class=\"anchor\" href=\"#llvm-ir简介\">#</a> LLVM IR 简介</h2>\n<p><img data-src=\"image-20230505140807839.png\" alt=\"image-20230505140807839\"></p>\n<p>LLVM 这个项目与最初的名字含义已经完全不同了，可以将 LLVM 理解为全称。目前 LLVM 是开发新的编译器的<strong>基础</strong>。</p>\n<p><img data-src=\"image-20230505141735207.png\" alt=\"image-20230505141735207\"></p>\n<p>前端经过语法分析，词法分析，生成 IR</p>\n<p><strong>“IR 设计的优秀与否决定着整个编译器的好坏”</strong></p>\n<p><img data-src=\"image-20230505141928962.png\" alt=\"image-20230505141928962\"></p>\n<p>一个.c 文件对应生成一个.ll 文件。Module 实际上就是一个文件 file, Module 里有多个函数，一个函数具有多个<strong>基本块 (Basic Block)</strong>, 每一个基本块都由多个指令构成。</p>\n<p>使用 clang <strong>-S -emit-llvm</strong> factorial0.c -o f0-opt0.ll 表示用 clang 生成到 llvm 中间代码阶段停止。</p>\n<p>中间代码示例：<br>\n<img data-src=\"image-20230505143323681.png\" alt=\"image-20230505143323681\"></p>\n<p>像 %3 %4 这样的是分配一个虚拟寄存器， alloca 表示内存分配， align 表示内存对齐</p>\n<p><code>store i32 0, i32* %3</code>  表示把 0 存到 %3 寄存器中</p>\n<p>call 一行表示函数调用</p>\n<p>下一行表示结果与 7 相乘， nsw 表示 no signed wrap</p>\n<p>zext: zero - extension 将一 bit 的 %8 扩展为 32 位</p>\n<p>%2 哪去了？ 被分配为 entry 基本块的名称</p>\n<p>限制：任何一个变量都只能一次赋值， 好处是使用变量时明确知道在什么时候定义过的。</p>\n<h2 id=\"控制流图\"><a class=\"anchor\" href=\"#控制流图\">#</a> 控制流图</h2>\n<p><img data-src=\"image-20230505150416543.png\" alt=\"image-20230505150416543\"></p>\n<p>控制流图的定义：<br>\n<img data-src=\"image-20230505150719324.png\" alt=\"image-20230505150719324\"></p>\n<p>例子：<br>\n<img data-src=\"image-20230505151157414.png\" alt=\"image-20230505151157414\"></p>\n<p>中间代码的数据流图：</p>\n<p><img data-src=\"image-20230505151318630.png\" alt=\"image-20230505151318630\"></p>\n<p>问题：%6 和 %7 基本块中要约定好把想 ret 的结果放在某一个寄存器中</p>\n<p>开了 o1 优化后：</p>\n<p><img data-src=\"image-20230505152003795.png\" alt=\"image-20230505152003795\"></p>\n<p>o1 优化会去掉所有的内存分配，store load 指令。</p>\n<p>phi 指令 根据从哪个块跳转出来决定赋值给 %8 寄存器的值</p>\n<p>然而 phi 指令只是为了简化中间代码的大小产生的，是一个虚拟指令，实际上仍然可能会使用基本方案。</p>\n<h2 id=\"llvm-java-api\"><a class=\"anchor\" href=\"#llvm-java-api\">#</a> LLVM JAVA API</h2>\n<p><img data-src=\"image-20230506141752865.png\" alt=\"image-20230506141752865\"></p>\n<p>在配置文件中加依赖</p>\n<p><img data-src=\"image-20230506142227366.png\" alt=\"image-20230506142227366\"></p>\n<p>可以参照 LLVM 官方的教程，c++ 语言如何翻译为中间代码。</p>\n<h2 id=\"中间代码翻译\"><a class=\"anchor\" href=\"#中间代码翻译\">#</a> 中间代码翻译</h2>\n<p><img data-src=\"image-20230506143047512.png\" alt=\"image-20230506143047512\"></p>\n<p>这里的 || 符号是 then 的意思，不是或者。</p>\n<p><img data-src=\"image-20230506144459580.png\" alt=\"image-20230506144459580\"></p>\n<p><img data-src=\"image-20230506144737646.png\" alt=\"image-20230506144737646\"></p>\n<p><img data-src=\"image-20230506145121379.png\" alt=\"image-20230506145121379\"></p>\n<p>例子： int a [2] [3]; c + a [i] [j];</p>\n<p><img data-src=\"image-20230506150834033.png\" alt=\"image-20230506150834033\"></p>\n<p>在 llvm IR 中：会用 getelementptr（GEP）指令处理数组引用</p>\n<p><img data-src=\"image-20230506151202417.png\" alt=\"image-20230506151202417\"></p>\n<p>GEP 指令有四个参数，其中第四个参数不限个数，可以有多个 index。</p>\n<p>第一个 index 比较特殊，表示 base-type 的一个元素的大小，用于 a++ 这样的操作，后面的 index 才用于进入数组获取元素，即没多一个 index 脱掉一层中括号。</p>\n<p><img data-src=\"image-20230506151901102.png\" alt=\"image-20230506151901102\"></p>\n<p>GEP provides a way to access arrays and manipulate pointers.</p>\n<p>GEP abstract away details like size of types.</p>\n<p>有了 GEP 指令后就不用像上面那样递归的计算偏移量了。</p>\n<p><img data-src=\"image-20230506154154393.png\" alt=\"image-20230506154154393\"></p>\n<h3 id=\"控制流语句的翻译\"><a class=\"anchor\" href=\"#控制流语句的翻译\">#</a> 控制流语句的翻译</h3>\n<p>简单的思路会带来冗余的代码</p>\n<p>要生成简短高效的代码，就需要<strong>创造困难</strong></p>\n<p><strong>简单 mode：</strong></p>\n<p><img data-src=\"image-20230510141125754.png\" alt=\"image-20230510141125754\"></p>\n<p>将 B 的值保存到临时变量 t1 中，翻译 if 语句时用 br 语句测试 t1 的值并根据情况跳转到两个基本块中。</p>\n<p>以 Control 语言为例：</p>\n<p><img data-src=\"image-20230510142838861.png\" alt=\"image-20230510142838861\"></p>\n<p>选择实现方式的范围： Listeners, Visitors, Attributed Grammar</p>\n<p>前两种方法能做到的 属性方法都能做到，但是属性文法本身比较困难，所以在前两种中方法中选择。</p>\n<p>Listener 模式有一个问题： 比如 B -&gt; B1 || B2 的翻译：</p>\n<p>要在 exitB () 方法拼接 B1.code 和 B2.code 。但是考虑出现了短路求值的问题时，由于在 exitB 的时候 B1 和 B2 的代码都生成好了，因此要在拼接 B1.code 和 B2.code 中间插入判断短路求值的代码，不能及时输出生成的中间代码，不能避免频繁的字符串拼接操作。简要来说，访问完 B1，将中间代码保存下来，才能进行接下来的操作，不能在访问 B1 和访问 B2 中间插入一些操作，这是 Listener 模式的缺陷。</p>\n<p>具体代码见代码仓库<em> 2023-compilers-coding-0/src/main/java/codegen/CodeGenVisitor.java</em></p>\n<p>true 和 false 的翻译：</p>\n<p><img data-src=\"image-20230510144428568.png\" alt=\"image-20230510144428568\"></p>\n<p>AND 语句：</p>\n<p>有一个小错误 String temp = getNewTemp () 要放在 emitLabel (trueLabel) 之上。</p>\n<p><img data-src=\"image-20230510151933288.png\" alt=\"image-20230510151933288\"></p>\n<p>if 语句：</p>\n<p><img data-src=\"image-20230510151955477.png\" alt=\"image-20230510151955477\"></p>\n<p>while 语句：</p>\n<p><img data-src=\"image-20230510152502018.png\" alt=\"image-20230510152502018\"></p>\n<p>一个问题：break 语句怎么翻译，多层嵌套的循环语句怎么办</p>\n<p>解决方法：使用一个栈，保存 break 语句要跳转到的地方。，参照 while 语句中的压栈出栈语句。</p>\n<p>短路求值问题： 参照 And 中的实现</p>\n<p><strong>复杂 mode</strong>：</p>\n<p><img data-src=\"image-20230510154721641.png\" alt=\"image-20230510154721641\"></p>\n<p>为什么让事情变得更复杂：</p>\n<p>eg：</p>\n<p><img data-src=\"image-20230517140632912.png\" alt=\"image-20230517140632912\"></p>\n<p>如果使用简单方案，将会生成 12 行中间代码，然而实际上这是一个死循环</p>\n<p>解决方案：利用继承属性让布尔表达式知道要跳转到哪</p>\n<p><img data-src=\"image-20230517141735294.png\" alt=\"image-20230517141735294\"></p>\n<h3 id=\"需要的继承属性\"><a class=\"anchor\" href=\"#需要的继承属性\">#</a> 需要的继承属性</h3>\n<p><img data-src=\"image-20230517142425226.png\" alt=\"image-20230517142425226\"></p>\n<h3 id=\"if语句\"><a class=\"anchor\" href=\"#if语句\">#</a> if 语句</h3>\n<p><img data-src=\"image-20230517142712190.png\" alt=\"image-20230517142712190\"></p>\n<p>S.next 是之前准备好的</p>\n<p><img data-src=\"image-20230517143447956.png\" alt=\"image-20230517143447956\"></p>\n<p>bool 表达式直接翻译成 goto 语句</p>\n<h3 id=\"if-else-语句\"><a class=\"anchor\" href=\"#if-else-语句\">#</a> if else 语句</h3>\n<p><img data-src=\"image-20230517144609460.png\" alt=\"image-20230517144609460\"></p>\n<p>eg：<img data-src=\"image-20230517144946527.png\" alt=\"image-20230517144946527\"></p>\n<h3 id=\"while语句\"><a class=\"anchor\" href=\"#while语句\">#</a> while 语句</h3>\n<p><img data-src=\"image-20230517150821390.png\" alt=\"image-20230517150821390\"></p>\n<h3 id=\"顺序语句\"><a class=\"anchor\" href=\"#顺序语句\">#</a> 顺序语句：</h3>\n<p><img data-src=\"image-20230517152329272.png\" alt=\"image-20230517152329272\"></p>\n<h3 id=\"短路求值\"><a class=\"anchor\" href=\"#短路求值\">#</a> 短路求值</h3>\n<p><img data-src=\"image-20230517153441075.png\" alt=\"image-20230517153441075\"></p>\n<p><img data-src=\"image-20230517153732513.png\" alt=\"image-20230517153732513\"></p>\n<h2 id=\"地址回填技术\"><a class=\"anchor\" href=\"#地址回填技术\">#</a> 地址回填技术</h2>\n<p><img data-src=\"image-20230519140559966.png\" alt=\"image-20230519140559966\"></p>\n<p>java 字节码中不使用符号化的标签作为跳转目标，而采用直接的地址值作为跳转目标。</p>\n<p>问题：往回跳简单，往前跳不知道跳转的地址，如何一趟扫描中就知道跳转目标的真实地址？</p>\n<p><img data-src=\"image-20230519141028791.png\" alt=\"image-20230519141028791\"></p>\n<p><img data-src=\"image-20230519141358466.png\" alt=\"image-20230519141358466\"></p>\n<p>解决方案： B 在 goto 语句后面空着，交给父节点 S 来回填。</p>\n<p><img data-src=\"image-20230519141905148.png\" alt=\"image-20230519141905148\"></p>\n<p>从底向上看怎么使用地址回填技术：(每幅图的下半部分是之前的翻译方案)</p>\n<p><img data-src=\"image-20230519143110842.png\" alt=\"image-20230519143110842\"></p>\n<p><img data-src=\"image-20230519143543907.png\" alt=\"image-20230519143543907\"></p>\n<p><img data-src=\"image-20230519143840206.png\" alt=\"image-20230519143840206\"></p>\n<p>到这里已经可以确定一些跳转的地址了：</p>\n<p>M 是一个辅助的符号，用来确定 B2 第一个指令的地址的值是多少</p>\n<p><img data-src=\"image-20230519144434026.png\" alt=\"image-20230519144434026\"></p>\n<p><img data-src=\"image-20230519150121225.png\" alt=\"image-20230519150121225\"></p>\n<p>布尔表达式结束 到达更高层：</p>\n<p><img data-src=\"/image-20230519151840965.png\" alt=\"image-20230519151840965\"></p>\n<p><img data-src=\"image-20230519152628678.png\" alt=\"image-20230519152628678\"></p>\n<p><img data-src=\"image-20230519153118656.png\" alt=\"image-20230519153118656\"></p>\n<p>顺序语句：</p>\n<p><img data-src=\"image-20230519153706714.png\" alt=\"image-20230519153706714\"></p>\n<p>总结：</p>\n<p><img data-src=\"image-20230519154323985.png\" alt=\"image-20230519154323985\"></p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2023/04/12/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8603-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/",
            "url": "http://example.com/2023/04/12/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8603-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/",
            "title": "编译原理03-语义分析",
            "date_published": "2023-04-12T07:46:23.000Z",
            "content_html": "<h1 id=\"语义分析\"><a class=\"anchor\" href=\"#语义分析\">#</a> 语义分析</h1>\n<h2 id=\"符号表\"><a class=\"anchor\" href=\"#符号表\">#</a> 符号表</h2>\n<p><img data-src=\"image-20230412154717575.png\" alt=\"image-20230412154717575\"></p>\n<p>用符号表保存我们已经定义了的变量或者函数以及其相关信息，在遍历语法分析树时，如果发现当前新出现的某些单元与符号表中的信息有冲突，我们就可以发现语义错误。</p>\n<h3 id=\"实现符号表\"><a class=\"anchor\" href=\"#实现符号表\">#</a> 实现符号表</h3>\n<p>首先构建作用域树：</p>\n<p><img data-src=\"image-20230419140503102.png\" alt=\"image-20230419140503102\"></p>\n<p><strong>我们在这里犯了一个小错误</strong>，即把函数参数的作用域单独独立出来了，以便于我们编码，实际上函数参数作用域和函数作用域应该是要合并的。</p>\n<p>作用域的指针指向父作用域，在查找某个变量是在哪个作用域时要循环从当前作用域到父作用域遍历。</p>\n<p>之后可以通过递归遍历等方式进行语义相关的检查。</p>\n<p>某个利用 antlr4 实现符号表的类图：</p>\n<p>scope 是作用域（持有一个 Map (name, symbol) 的符号表数据类型），symbol 是符号 (持有 name 和 type，是符号表的基本单元)，type 是符号所持有的类型（比如基本类型，array), 通过遍历时</p>\n<p><img data-src=\"image-20230419141503552.png\" alt=\"image-20230419141503552\"></p>\n<p>浅绿框起来的是接口。</p>\n<h2 id=\"属性文法\"><a class=\"anchor\" href=\"#属性文法\">#</a> 属性文法</h2>\n<h3 id=\"为什么要引入属性文法\"><a class=\"anchor\" href=\"#为什么要引入属性文法\">#</a> 为什么要引入属性文法</h3>\n<p>之前引入上下文无关文法的时候，是因为正则表达式无法表达 a<sup>nb</sup>n 这样的表达式，但是上下文无关文法也有局限，<strong>无法帮助我们进行语义相关的检查</strong>。于是引入 Knuth 发明的属性文法。</p>\n<p><img data-src=\"image-20230421140916771.png\" alt=\"image-20230421140916771\"></p>\n<p>接下来以实现一个<strong>交互式</strong>的简易计算器为例</p>\n<p>前几节课写的简易计算器采用的是 offline 的方法：<br>\n<img data-src=\"image-20230421141650214.png\" alt=\"image-20230421141650214\"></p>\n<p>本次将采用 online 的方式实现，即在构建语法分析树的过程中加入我们想实现的 action。</p>\n<p><img data-src=\"image-20230421142018201.png\" alt=\"image-20230421142018201\"></p>\n<p>之前实现计算器的时候遇到了一个问题，listener 模式下，访问某个节点的 enterXXX 与 exitXXX 方法没有返回值，而当前节点的 value 依赖于子节点 value 的值，当时采用了标注语法树的方法。</p>\n<p>antlr4 的另一个解决方案：</p>\n<p><img data-src=\"image-20230421143635663.png\" alt=\"image-20230421143635663\"></p>\n<p>在.g4 文件的 expr 定义后 加上 returns [int val] 后，在 antlr4 生成的 expr 对应的节点类中会附带一个 val 属性。</p>\n<p>每一行后大括号裹起来的黑体字是会在语法分析时我们加入的 java 代码，具体可在生成的 parser 类中查看。之后在 @package 中加入需要的头文件并在 @members 中加入 eval，memory 等的 java 实现。(实际上可在 @parser::members 中加入，这样在 lexer 中就不会生成这些无用的代码)</p>\n<p>像 expr 这种从子节点的 expr 值计算得到的属性，叫做综合属性。</p>\n<p>至于 “交互式” 的实现，主要是 main 函数的实现方式，参照代码仓库。</p>\n<p>第二个例子：类型声明文法：</p>\n<p><img data-src=\"image-20230421145230801.png\" alt=\"image-20230421145230801\"></p>\n<p>第一条语义规则的问题：将 L 的类型赋值为 T 的类型，可是在递归调用的时候，L 并不知道 T 返回了一个类型是 float 还是 int。</p>\n<p>解决方法，给 L 一个 inh (inherit) 属性值，这种从左兄弟或者父节点继承来的值，叫做继承属性。</p>\n<p><img data-src=\"image-20230421151150679.png\" alt=\"image-20230421151150679\"></p>\n<p>antlr4 实现的语法：<br>\n<img data-src=\"image-20230421151912395.png\" alt=\"image-20230421151912395\"></p>\n<p>vars [String typeStr] 代表 vars 节点将携带一个属性 TypeStr。</p>\n<h3 id=\"语法制导定义\"><a class=\"anchor\" href=\"#语法制导定义\">#</a> 语法制导定义</h3>\n<p><img data-src=\"image-20230421152800113.png\" alt=\"image-20230421152800113\"></p>\n<p>像上面的 g4 语法定义都属于 SDD，每个节点可以有多个属性</p>\n<p><img data-src=\"image-20230421153313913.png\" alt=\"image-20230421153313913\"></p>\n<p><img data-src=\"image-20230421153702902.png\" alt=\"image-20230421153702902\"></p>\n<p>继承属性用于在表达式中从左向右传递中间计算结果</p>\n<p>比如：累乘的右递归文法</p>\n<p><img data-src=\"image-20230421154158430.png\" alt=\"image-20230421154158430\"></p>\n<p><img data-src=\"image-20230421154959302.png\" alt=\"image-20230421154959302\"></p>\n<p>信息流向：先从左到右利用继承属性传递信息，再利用综合属性从下到上传递信息。</p>\n<p>属性文法的本质：信息的有序流动</p>\n<h3 id=\"l属性定义\"><a class=\"anchor\" href=\"#l属性定义\">#</a> L 属性定义</h3>\n<p><img data-src=\"image-20230426140830620.png\" alt=\"image-20230426140830620\"></p>\n<p>例子 1：</p>\n<p>用属性文法实现得到表达式的后缀表示形式</p>\n<p><img data-src=\"image-20230426141239902.png\" alt=\"image-20230426141239902\"></p>\n<p><img data-src=\"image-20230426141906728.png\" alt=\"image-20230426141906728\"></p>\n<p>例子 2：得到数组的类型表达式</p>\n<p><strong>比如 int [2] [3] -&gt; (2,(3,int))</strong></p>\n<p><img data-src=\"image-20230504101715454.png\" alt=\"image-20230504101715454\"></p>\n<p><img data-src=\"image-20230426142516412.png\" alt=\"image-20230426142516412\"></p>\n<p>antlr4 实现文法：<br>\n<img data-src=\"image-20230426143619377.png\" alt=\"image-20230426143619377\"></p>\n<p>例子 3：判断赋值号左右类型是否相等</p>\n<p><img data-src=\"image-20230426151226852.png\" alt=\"image-20230426151226852\"></p>\n<p>数组声明相关文法已经在例子 2 中完成了。</p>\n<p><img data-src=\"image-20230504121851839.png\" alt=\"image-20230504121851839\"></p>\n<p>具体代码可在 github 代码仓库中查找。</p>\n<p>属性文法缺点：要在 antlr 中编写 java 代码，而且要完成编译器的话会需要很多代码，这些代码与 antlr 的文法混合在一起。</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"image-20230426152847006.png\" alt=\"image-20230426152847006\"></p>\n<p>两种语义分析方法，各有优势。Offline 简单，Online 性能更高。</p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2023/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8602-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/",
            "url": "http://example.com/2023/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8602-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/",
            "title": "编译原理02-语法分析",
            "date_published": "2023-03-24T06:05:42.000Z",
            "content_html": "<h1 id=\"编译原理02-语法分析\"><a class=\"anchor\" href=\"#编译原理02-语法分析\">#</a> 编译原理 02 - 语法分析</h1>\n<p>主要内容：如何用 antlr4 生成一个语法分析器。手写语法分析器比较困难，不作要求。</p>\n<p>lesson1 任务： 用 cymbol 语言（龙书中提供的一种简化版 c 语言）写一段程序，并生成如下的函数调用关系图。</p>\n<p><img data-src=\"image-20230326120955042.png\" alt=\"image-20230326120955042\"></p>\n<p>lesson2 任务：写一个简单的计算器</p>\n<p>在为自己的语言编写语法分析器时，可能会遇到一些问题。</p>\n<h2 id=\"问题一二义性文法\"><a class=\"anchor\" href=\"#问题一二义性文法\">#</a> 问题一：二义性文法</h2>\n<p>考虑下列定义：</p>\n<p><img data-src=\"image-20230324142546278.png\" alt=\"image-20230324142546278\"></p>\n<p><code>if a then if b then c else d</code>  可以有两种解释</p>\n<p><img data-src=\"image-20230324142701632.png\" alt=\"image-20230324142701632\"></p>\n<p>龙书上给的无二义性语法：</p>\n<p><img data-src=\"image-20230324143323221.png\" alt=\"image-20230324143323221\"></p>\n<p>难题是如何证明没有二义性（见龙书）</p>\n<p>在 antlr4 中，写在前面的定义如果能被匹配到，就会优先选择写在前面的定义，以防止歧义出现的错误。</p>\n<h3 id=\"运算符的结合性带来的二义性\"><a class=\"anchor\" href=\"#运算符的结合性带来的二义性\">#</a> 运算符的结合性带来的二义性</h3>\n<p><img data-src=\"image-20230324143744282.png\" alt=\"image-20230324143744282\"></p>\n<p>没有规定是左结合还是右结合，可以有两种解释，导致结果不一样。</p>\n<p>antlr4 规定运算符默认是左结合的，以消除这种歧义。</p>\n<p>如何明确指明是右结合的（如乘方运算符要规定为右结合的）：</p>\n<p><img data-src=\"image-20230324143947465.png\" alt=\"image-20230324143947465\"></p>\n<h3 id=\"运算符优先级带来的二义性\"><a class=\"anchor\" href=\"#运算符优先级带来的二义性\">#</a> 运算符优先级带来的二义性</h3>\n<p><img data-src=\"image-20230324144400266.png\" alt=\"image-20230324144400266\"></p>\n<p>在 antlr4 里，写在前面的运算符优先级更高。</p>\n<p>如果不是 antlr4，比如在某些比较古老的工具中，需要我们自己处理。</p>\n<h2 id=\"如何根据代码生成函数调用图\"><a class=\"anchor\" href=\"#如何根据代码生成函数调用图\">#</a> 如何根据代码生成函数调用图</h2>\n<p>先用 antlr4 生成语法分析树，然后用 dfs 方法遍历语法树。</p>\n<h3 id=\"铺垫\"><a class=\"anchor\" href=\"#铺垫\">#</a> 铺垫</h3>\n<p>antlr4 提供了 listener, 在 antlr 帮我们遍历语法树时，当 antlr4 进入一类节点时，会触发 enter 节点事件，离开时会触发 exit 节点事件。</p>\n<p>问题：需要细分，比如函数调用和 赋值语句都是 expr，那么进入 expr 节点的时候都会触发 enterExpr 事件，不好针对特定情况处理。</p>\n<p>情况一：</p>\n<p>​\tfunction call 和 赋值语句都是 expr，因此触发了 enterExpr 时间后也无法细分是哪类 expr。</p>\n<p>解决方法：在 g4 文件对应的定义后加上  <code># fuctioncall</code> , 要加的话后面的也要加上</p>\n<p>情况二： <code>expr ('*' |  '/') expr</code>  被定义为 MutiDiv, 则进入 MutiDiv 的时候不知道是还是除法。</p>\n<p>解决方法：</p>\n<p><code> expr (op = '*' | op = '/') expr</code>  进入时判断变量 op 的值是什么便可</p>\n<h2 id=\"如何生成一个调用图\"><a class=\"anchor\" href=\"#如何生成一个调用图\">#</a> 如何生成一个调用图</h2>\n<p>按 Graphviz 语法编写.dot 文件，会自动生成调用图</p>\n<p><img data-src=\"image-20230326201151771.png\" alt=\"image-20230326201151771\"></p>\n<h2 id=\"实现一个简单的计算器\"><a class=\"anchor\" href=\"#实现一个简单的计算器\">#</a> 实现一个简单的计算器</h2>\n<h3 id=\"listener模式的一个弊端\"><a class=\"anchor\" href=\"#listener模式的一个弊端\">#</a> listener 模式的一个弊端</h3>\n<p>antlr 提供的 listener 模式方法的返回值是 void，但是我们想实现一个计算器的话，在 dfs 语法树的时候就必须利用子节点的值来计算。为了解决这个问题，antlr4 提供了一个标注（Annotate) 语法树的功能。</p>\n<p>eg:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//calcuListener 里的方法</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">exitParens</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CymbolParser<span class=\"token punctuation\">.</span>ParensContext</span> ctx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tvalues<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span>values<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span><span class=\"token function\">expr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">exitAddSub</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CymbolParser<span class=\"token punctuation\">.</span>AddSubContext</span> ctx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token keyword\">int</span> lvalue <span class=\"token operator\">=</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span>lhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//lhs (left hand side) 在.g4 文件中赋值为前面的 expr</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">int</span> rvalue <span class=\"token operator\">=</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span>rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">.</span>op<span class=\"token punctuation\">.</span><span class=\"token function\">getType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token constant\">ADD</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\tvalues<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> lvalue<span class=\"token operator\">+</span>rvalue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\tvalues<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span>lvalue<span class=\"token operator\">-</span>rvalue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"上下文无关文法\"><a class=\"anchor\" href=\"#上下文无关文法\">#</a> 上下文无关文法</h2>\n<p><img data-src=\"image-20230329150049799.png\" alt=\"image-20230329150049799\"></p>\n<p>编写 g4 文件时实际上用的就是上下文无关文法</p>\n<h3 id=\"什么是上下文相关文法\"><a class=\"anchor\" href=\"#什么是上下文相关文法\">#</a> 什么是上下文相关文法</h3>\n<p><img data-src=\"image-20230329150412566.png\" alt=\"image-20230329150412566\"></p>\n<p>以第三行与第七行为例：B 是展开为 Z 还是 b 与它的上下文（这里是前面的字符）有关</p>\n<p>这段文法表示的是 a<sup>n*b</sup>n*c^n ，可以证明用上下文无关文法是无法描述这个语言的。</p>\n<h3 id=\"推导\"><a class=\"anchor\" href=\"#推导\">#</a> 推导</h3>\n<p><img data-src=\"image-20230329150648976.png\" alt=\"image-20230329150648976\"></p>\n<p><img data-src=\"image-20230329150810626.png\" alt=\"image-20230329150810626\"></p>\n<h3 id=\"为什么不使用正则表达式去描述语法\"><a class=\"anchor\" href=\"#为什么不使用正则表达式去描述语法\">#</a> 为什么不使用正则表达式去描述语法</h3>\n<p><img data-src=\"image-20230329153448085.png\" alt=\"image-20230329153448085\"></p>\n<p>证明如下：</p>\n<p><img data-src=\"image-20230329153850498.png\" alt=\"image-20230329153850498\"></p>\n<p>其中 Ai 对应的是 DFA 中的第 i-1 个状态</p>\n<p><img data-src=\"image-20230329154356116.png\" alt=\"image-20230329154356116\"></p>\n<p>因为 m &gt; k, 所以一定存在状态 si ，在 si 停留了两次，假设又经过了 j 步能够到达第二次 si</p>\n<p>根据假设，a<sup>ib</sup>i 能够到达终止状态，那么 a<sup>(i+j)b</sup>i 也能到达终止状态，与假设矛盾，证明完毕。</p>\n<h2 id=\"ll1语法分析器\"><a class=\"anchor\" href=\"#ll1语法分析器\">#</a> LL (1) 语法分析器</h2>\n<h3 id=\"总览\"><a class=\"anchor\" href=\"#总览\">#</a> 总览</h3>\n<p><img data-src=\"image-20230411205542981.png\" alt=\"image-20230411205542981\"></p>\n<p><img data-src=\"image-20230331143754540.png\" alt=\"image-20230331143754540\"></p>\n<h3 id=\"自顶向下的含义\"><a class=\"anchor\" href=\"#自顶向下的含义\">#</a> 自顶向下的含义</h3>\n<p><img data-src=\"image-20230331140837017.png\" alt=\"image-20230331140837017\"></p>\n<h3 id=\"两个l的含义\"><a class=\"anchor\" href=\"#两个l的含义\">#</a> 两个 L 的含义</h3>\n<p><img data-src=\"image-20230331141034044.png\" alt=\"image-20230331141034044\"></p>\n<h3 id=\"递归下降的含义\"><a class=\"anchor\" href=\"#递归下降的含义\">#</a> 递归下降的含义</h3>\n<p><img data-src=\"image-20230331141214747.png\" alt=\"image-20230331141214747\"></p>\n<p>eg: 先默认选择产生式的问题已经被解决了，只演示递归下降的过程</p>\n<p><img data-src=\"image-20230331141731554.png\" alt=\"image-20230331141731554\"></p>\n<p><img data-src=\"image-20230331142317647.png\" alt=\"image-20230331142317647\"></p>\n<h3 id=\"如何选择产生式\"><a class=\"anchor\" href=\"#如何选择产生式\">#</a> 如何选择产生式</h3>\n<p><img data-src=\"image-20230331142728269.png\" alt=\"image-20230331142728269\"></p>\n<p><img data-src=\"image-20230331142916987.png\" alt=\"image-20230331142916987\"></p>\n<h3 id=\"什么是ll1文法\"><a class=\"anchor\" href=\"#什么是ll1文法\">#</a> 什么是 LL (1) 文法</h3>\n<p><img data-src=\"image-20230331143057195.png\" alt=\"image-20230331143057195\"></p>\n<p><strong>LL（1）中 1 的含义：只需要查看当前的输入符号就可以确定选择哪条产生式进行展开</strong></p>\n<h3 id=\"ll1的伪代码\"><a class=\"anchor\" href=\"#ll1的伪代码\">#</a> LL (1) 的伪代码</h3>\n<p><strong>假设预测分析表已经有了</strong></p>\n<p><img data-src=\"image-20230331143540005.png\" alt=\"image-20230331143540005\"></p>\n<p><img data-src=\"image-20230331143718582.png\" alt=\"image-20230331143718582\"></p>\n<h3 id=\"难点如何生成预测分析表\"><a class=\"anchor\" href=\"#难点如何生成预测分析表\">#</a> 难点：如何生成预测分析表</h3>\n<p><img data-src=\"image-20230331150322238.png\" alt=\"image-20230331150322238\"></p>\n<p>竖着看：什么时候选择展开为 func_call, 还是 decl。很简单，看当前输入的前面是 int 还是 ID。</p>\n<p>横着看：如何确定 optional_init 是否展开为空串</p>\n<p>问题：什么时候可以选择空串展开？ 见后</p>\n<p><img data-src=\"image-20230331151147854.png\" alt=\"image-20230331151147854\"></p>\n<p><img data-src=\"image-20230331151439293.png\" alt=\"image-20230331151439293\"></p>\n<p><img data-src=\"image-20230331151512669.png\" alt=\"image-20230331151512669\"></p>\n<p><img data-src=\"image-20230331152131492.png\" alt=\"image-20230331152131492\"></p>\n<p>为什么中间两步要去除空串，比如：因为即使 Y1 可以被展开为空串，后面的 Y2-YK 不一定能展开为空串，X 的开头不一定是空串。空串要单独判断</p>\n<p><img data-src=\"image-20230331152345075.png\" alt=\"image-20230331152345075\"></p>\n<p><img data-src=\"image-20230411223059716.png\" alt=\"image-20230411223059716\"></p>\n<p>dollar 符是文件结束符号</p>\n<p>因为 follow 集合考虑的是终结符，所以规则 3 要去掉空串</p>\n<p><img data-src=\"image-20230407140712901.png\" alt=\"image-20230407140712901\"></p>\n<p>例子：</p>\n<p><img data-src=\"image-20230407140907285.png\" alt=\"image-20230407140907285\"></p>\n<p>这个例子中只看 c 无法确定 Y 是由 3 号还是 4 号规则展开，则不是 LL (1) 文法</p>\n<h3 id=\"非递归的预测分析算法不作要求\"><a class=\"anchor\" href=\"#非递归的预测分析算法不作要求\">#</a> 非递归的预测分析算法（不作要求）</h3>\n<p><img data-src=\"image-20230407141535578.png\" alt=\"image-20230407141535578\"></p>\n<h2 id=\"改造为ll1文法\"><a class=\"anchor\" href=\"#改造为ll1文法\">#</a> 改造为 LL (1) 文法</h2>\n<p><img data-src=\"image-20230407141907838.png\" alt=\"image-20230407141907838\"></p>\n<p>为什么左递归不是 LL (1) 文法：</p>\n<p>LL (1) 的递归下降算法会出问题：</p>\n<p>E 展开为 E+T，然后 E+T 中的 E 展开为 E+T。。。</p>\n<p><img data-src=\"image-20230407142036246.png\" alt=\"image-20230407142036246\"></p>\n<p><img data-src=\"image-20230407142224345.png\" alt=\"image-20230407142224345\"></p>\n<p>问题：改写成右递归比较复杂，而且改造后可读性较差</p>\n<h3 id=\"直接左递归的改造\"><a class=\"anchor\" href=\"#直接左递归的改造\">#</a> 直接左递归的改造</h3>\n<p>改造的模板：</p>\n<p><img data-src=\"image-20230407142538910.png\" alt=\"image-20230407142538910\"></p>\n<h3 id=\"间接左递归的改造\"><a class=\"anchor\" href=\"#间接左递归的改造\">#</a> 间接左递归的改造</h3>\n<p><img data-src=\"image-20230407142905861.png\" alt=\"image-20230407142905861\"></p>\n<p>思路：改造后的文法中的每一条展开式都应该满足红框里的条件 因为展开后的编号越来越大，就永远回不到自己。</p>\n<p>例子：</p>\n<ol>\n<li>首先对所有的非终结符编号： S：A1， A：A2， B：A3</li>\n<li>看所有的非终结符的展开式是否满足单调递增性质</li>\n</ol>\n<p><img data-src=\"image-20230407143533868.png\" alt=\"image-20230407143533868\"></p>\n<ol start=\"3\">\n<li>发现 B-&gt; Sa|a 不满足改造条件， 将非终结符慢慢展开，发现展开为最后一行时变成了直接左递归，直接左递归用上面的方法处理。</li>\n</ol>\n<h3 id=\"左递归改造算法要求\"><a class=\"anchor\" href=\"#左递归改造算法要求\">#</a> 左递归改造算法要求：</h3>\n<p><img data-src=\"image-20230407143729991.png\" alt=\"image-20230407143729991\"></p>\n<h3 id=\"左公因子的改造\"><a class=\"anchor\" href=\"#左公因子的改造\">#</a> 左公因子的改造</h3>\n<p><img data-src=\"image-20230407144035629.png\" alt=\"image-20230407144035629\"></p>\n<p>为什么左公因子不行 ，比如第八行原来的 decl 内容，两个展开式开头都是 'int'。</p>\n<p>改造方法简单，如第 13 行的定义</p>\n<h2 id=\"adaptive-ll语法分析算法\"><a class=\"anchor\" href=\"#adaptive-ll语法分析算法\">#</a> Adaptive LL (*) 语法分析算法</h2>\n<p>也称 ALL STAR 算法，antrl4 采用这种算法</p>\n<p>ChatGPT 评价：</p>\n<p><img data-src=\"image-20230407144342359.png\" alt=\"image-20230407144342359\"></p>\n<p>第 2,3 行 含有 LL (1) 的特性：不用猜测 自顶向下</p>\n<p>第 4 行： 解决二义性</p>\n<p>第 7 行：解决左递归</p>\n<p><img data-src=\"image-20230407145002698.png\" alt=\"image-20230407145002698\"></p>\n<h3 id=\"antrl4对左递归的改造将左递归改造成循环迭代\"><a class=\"anchor\" href=\"#antrl4对左递归的改造将左递归改造成循环迭代\">#</a> antrl4 对左递归的改造，将左递归改造成循环 (迭代)</h3>\n<p><img data-src=\"image-20230407150629592.png\" alt=\"image-20230407150629592\"></p>\n<p>参数_p 指的是优先级，优先级按下面书写的顺序（ID 1,INT 2, 加法 3 乘法 4） 当 3 &gt;= _p 时 才能展开为加法。展开后变成了 expr [4]，优先级升了一级（优先级上升算法名称的由来）</p>\n<p><img data-src=\"image-20230407152404434.png\" alt=\"image-20230407152404434\"></p>\n<p>以 1+2+3 为例，右侧手写部分为算法伪代码</p>\n<p><img data-src=\"image-20230407152625774.png\" alt=\"image-20230407152625774\"></p>\n<p>以 1+2*3 为例</p>\n<h3 id=\"右结合运算符的处理\"><a class=\"anchor\" href=\"#右结合运算符的处理\">#</a> 右结合运算符的处理</h3>\n<p>想让一个运算符为右结合，再递归调用的时候传入的优先级应该不变。</p>\n<h2 id=\"antlr4是如何进行错误报告的\"><a class=\"anchor\" href=\"#antlr4是如何进行错误报告的\">#</a> antlr4 是如何进行错误报告的</h2>\n<p><img data-src=\"image-20230407154816857.png\" alt=\"image-20230407154816857\"></p>\n<p>LexerNoViableAltException: 词法分析的时候遇到未知字符，出现错误</p>\n<p>NoViableAltException: 面对当前的输入时，要展开当前的非终结符，发现没有备选分支可选</p>\n<p>InputMismatchException: 根据选择好的备选分支展开时，发生终结符不匹配错误。</p>\n<p><strong>antlr4 的强大之处在于其报错之后不会马上结束程序，而是以报错， 恢复， 继续分析的流程来解析程序</strong></p>\n<h3 id=\"antlr4的基本策略\"><a class=\"anchor\" href=\"#antlr4的基本策略\">#</a> antlr4 的基本策略</h3>\n<p><img data-src=\"image-20230412141343590.png\" alt=\"image-20230412141343590\"></p>\n<p><strong>四项基本原则</strong>：</p>\n<ul>\n<li>特殊情况，特殊处理</li>\n<li>一般情况，统一处理</li>\n<li>统一处理，精细控制</li>\n<li>自定义错误处理策略</li>\n</ul>\n<h3 id=\"特殊情况特殊处理\"><a class=\"anchor\" href=\"#特殊情况特殊处理\">#</a> 特殊情况，特殊处理</h3>\n<p><img data-src=\"image-20230412141619597.png\" alt=\"image-20230412141619597\"></p>\n<p>单词法符号移除： class <strong>9</strong> T {int i;} 9 会被移除</p>\n<p>单词法符号补全： class {int i;} 会在 class 后面补一个符号</p>\n<h3 id=\"一般情况统一处理\"><a class=\"anchor\" href=\"#一般情况统一处理\">#</a> 一般情况，统一处理</h3>\n<p><img data-src=\"image-20230417235837973.png\" alt=\"image-20230417235837973\"></p>\n<p>例子：</p>\n<p><img data-src=\"image-20230412142107657.png\" alt=\"image-20230412142107657\"></p>\n<p>antlr4 看到一个中括号，可以报错：中间缺失一个 expr</p>\n<p>antlr 通过递归调用匹配，发现当前终结符匹配不了，于是递归返回，每一层看当前符号是不是一个<strong>想要的符号</strong>（所谓想要的符号，即假装当前想匹配的非终结符已经匹配成功，接下来应该遇到什么终结符，类似 Follow 集合，但不等价，称为 Following 集合）, 恢复到 expr 层，假装 expr 已经匹配成功，右中括号可以匹配，然后继续解析后面的。</p>\n<p>注意 Follow（静态）集合与 Following（动态）集合的区别。</p>\n<p>恢复时的动作是：丢弃词法单元直到碰到当前 Following 集合中的某个词法单元，然后从当前规则中恢复，也就是返回上一层，继续分析。比如，在 [] 例子中（见上图），atom 期望 INT/ID，与] 不匹配，则不断丢弃输入中的词法单元，直到遇到 ^ 或者 ]。对于这个例子，恰巧当前词法单元就是 ]，所以并没有丢弃任何词法单元，就能从 atom 中恢复，返回到 expr 层。expr 期望看到 ^，与 ] 也不匹配，则不断丢弃词法单元直到遇到 ]。这里同样也没有丢弃任何词法单元，就能从 expr 中恢复，返回到 group 层。group 期望看到 ]，与当前词法单元匹配，成功恢复。</p>\n<h3 id=\"统一处理精细控制\"><a class=\"anchor\" href=\"#统一处理精细控制\">#</a> 统一处理，精细控制</h3>\n<p><img data-src=\"image-20230412143257921.png\" alt=\"image-20230412143257921\"></p>\n<p>所谓优雅：即以最小的代价恢复过来</p>\n<p>例子：</p>\n<p><img data-src=\"image-20230412143706102.png\" alt=\"image-20230412143706102\"></p>\n<p>类的文法定义为 <em><strong>class ID { member+ }</strong></em></p>\n<p>不优雅的错误恢复：匹配 member 的时候，看到 y 不属于一个 member，直接退出 while 循环，即整个 member + 匹配失败。</p>\n<p>优雅的错误恢复，相当于在匹配 member 的 while 循环中加了一个 continue，继续匹配之后的 member。</p>\n<h3 id=\"自定义错误处理策略\"><a class=\"anchor\" href=\"#自定义错误处理策略\">#</a> 自定义错误处理策略</h3>\n<p>比如，（已知语法正确）关闭默认错误处理功能，提高运行效率</p>\n<p>比如，（出错代价太大）在遇到第一个语法错误时，就停止分析</p>\n<p>使用 antrl4 提供的 strategy 模式：</p>\n<p><img data-src=\"image-20230412144102502.png\" alt=\"image-20230412144102502\"></p>\n<h2 id=\"all-star算法的基本思想-构建lookahead-dfa\"><a class=\"anchor\" href=\"#all-star算法的基本思想-构建lookahead-dfa\">#</a> All Star 算法的基本思想  构建 lookahead DFA</h2>\n<p>例子：</p>\n<p><img data-src=\"image-20230418234205988.png\" alt=\"image-20230418234205988\"></p>\n<p>这个文法不属于 LL（k) 文法 因为它表示的字符串为 **(a*b)(c|d)**。但给出 bc 或 bd antlr4 能判断出从 Ac 和 Ad 哪条展开式展开。</p>\n<p><img data-src=\"image-20230412150939866.png\" alt=\"image-20230412150939866\"></p>\n<p>对每一个非终结符都画一个增强迁移网络 ATN (Augmented Transitjion Network), 如上图所示。All star 算法的核心思想: **Incrementally and dynamically build up a lookahead DFA that map lookahead phrases to predicated productions.** 关键：增量式构造，“向前看” DFA。</p>\n<p>lookahead DFA 作用：帮助选择备选分支。（比如当看到 S 不知道选哪条展开式，使用 DFA 辅助判断）。</p>\n<p>策略：既然不知道要选哪条备选分支，就并行地探索所有的备选分支。</p>\n<p><img data-src=\"image-20230412151956767.png\" alt=\"image-20230412151956767\"></p>\n<p>期望情况：只有一条路径成功走到了最后</p>\n<p>有歧义问题：多条路径还在走的时候，没有了输入，或者多条路径处理时汇合。</p>\n<p><img data-src=\"image-20230412154019808.png\" alt=\"image-20230412154019808\"></p>\n<p>每个状态有三个分量：第一个是状态名，第二个是选择的备选分支，第三个分量表示递归调用完当前 DFA 后到达的状态。状态是怎么定的：注意通过 ε 能到达的节点是分不开的。（求每个节点的 ε 闭包）</p>\n<p>看到 d 和 c 后就能发现第二个分量分离了，即能确定用哪条分支展开了。</p>\n<h2 id=\"lr0-语法分析器\"><a class=\"anchor\" href=\"#lr0-语法分析器\">#</a> LR (0) 语法分析器</h2>\n<p>LL (k) 的弱点：</p>\n<p>​\t在仅看到右部的前 k 个词法单元时就必须预测要使用哪条产生式</p>\n<p>LR (k) 的优点：</p>\n<p>​\t看到与正在考虑的这个产生式的整个右部对应的词法单元之后再决定</p>\n<p><img data-src=\"image-20230524141208555.png\" alt=\"image-20230524141208555\"></p>\n<p><img data-src=\"image-20230524141434136.png\" alt=\"image-20230524141434136\"></p>\n<p><img data-src=\"image-20230524141809217.png\" alt=\"image-20230524141809217\"></p>\n<p>rm： right most 最右推导</p>\n<p>为什么是最右推导：</p>\n<p>​\t\t因为规约的顺序实际上是一个反向最右推导的过程，为了我们要从左往右扫描输入相匹配</p>\n<p><img data-src=\"image-20230524142410243.png\" alt=\"image-20230524142410243\"></p>\n<p><img data-src=\"image-20230524142507347.png\" alt=\"image-20230524142507347\"></p>\n<p><img data-src=\"image-20230524143658693.png\" alt=\"image-20230524143658693\"></p>\n<p>在栈中，交替进行移入和规约操作</p>\n<p>问题转化为：</p>\n<p><img data-src=\"image-20230524143738090.png\" alt=\"image-20230524143738090\"></p>\n<p><img data-src=\"image-20230524143946746.png\" alt=\"image-20230524143946746\"></p>\n<p>利用 LR 分析表指导语法分析过程：</p>\n<p><img data-src=\"image-20230524144146911.png\" alt=\"image-20230524144146911\"></p>\n<p>一开始处于 0 号状态，看到当前词法单元为 id，进行 s5 操作。</p>\n<p>s5 操作含义：</p>\n<p>​\ts： shift 移入， 将 id 移入栈中</p>\n<p>​\t5： 调整当前语法分析器状态为 5</p>\n<p>​\t然后要右移指向当前词法单元的指针（小点）</p>\n<p><img data-src=\"image-20230524144356599.png\" alt=\"image-20230524144356599\"></p>\n<p>右边 “GOTO” 的小表中的数字前应该有一个 g</p>\n<p>比如 0 号状态下压入一个 F ，查表发现应该实现 g3，即将 F 压入栈，转向 3 号状态。</p>\n<h3 id=\"栈上操作\"><a class=\"anchor\" href=\"#栈上操作\">#</a> “栈” 上操作</h3>\n<p><img data-src=\"image-20230623163900518.png\" alt=\"image-20230623163900518\"></p>\n<p>一开始栈中不为空，要压入一个 s0，表示起始处于 0 号状态，s 表示开始。</p>\n<ol>\n<li>遇到 id 查表发现 0 号状态遇到 id 是 s5，则将 id 压入栈中，并在右边加上数字 5 表示当前处于 5 号状态。即压入 id5。指针右移指向 * 号。</li>\n<li>查表，5 号状态遇到 * 号，做 r6 操作。用 6 号产生式规约，将栈顶的 id5 弹出，此时底下剩一个 s0，处于 0 号状态，然后要压入 F，查表，0 号状态移入 F 要 g3，压入 F3，转向 3 号状态。<strong>指针不变</strong>。</li>\n<li>。。。</li>\n</ol>\n<h3 id=\"lr分析表如何生成\"><a class=\"anchor\" href=\"#lr分析表如何生成\">#</a> LR 分析表如何生成</h3>\n<p><img data-src=\"image-20230524151050006.png\" alt=\"image-20230524151050006\"></p>\n<p>什么是句柄：</p>\n<p><img data-src=\"image-20230524151111643.png\" alt=\"image-20230524151111643\"></p>\n<h3 id=\"一个永远正确的定理\"><a class=\"anchor\" href=\"#一个永远正确的定理\">#</a> 一个永远正确的定理</h3>\n<p><strong>这个定理的推导不需掌握，但是这个定理是正确的</strong></p>\n<p><img data-src=\"image-20230524151625361.png\" alt=\"image-20230524151625361\"></p>\n<p><img data-src=\"image-20230524152213719.png\" alt=\"image-20230524152213719\"></p>\n<p>LR 自动机在追踪所有产生式的状态</p>\n<p>小点表示当前追踪到了哪一个位置</p>\n<p><img data-src=\"image-20230623170950451.png\" alt=\"image-20230623170950451\"></p>\n<h3 id=\"增广文法\"><a class=\"anchor\" href=\"#增广文法\">#</a> 增广文法</h3>\n<p><img data-src=\"image-20230524152728413.png\" alt=\"image-20230524152728413\"></p>\n<p>S 是开始符号，仅仅是技术上的一些处理。</p>\n<h3 id=\"lr0状态机的构造\"><a class=\"anchor\" href=\"#lr0状态机的构造\">#</a> LR (0) 状态机的构造</h3>\n<p><img data-src=\"image-20230524153005769.png\" alt=\"image-20230524153005769\"></p>\n<p><strong>如果要期望看到的文法符号串开头是一个非终结符，要做闭包！</strong></p>\n<p>比如 0 号状态一开始只有 E'-&gt; . E</p>\n<p>下面想要看到一个 E，但是 E 是一个非终结符，它可以展开为 1 号和 2 号产生式，2 号产生式又可以做闭包，直到所有产生式都包含进来了。</p>\n<p>LR (0) 语法分析器在做句柄识别的时候，依赖的是一个 LR (0) 句柄识别有穷状态机</p>\n<p>eg：</p>\n<p><strong>I1 状态是怎么构造的？</strong></p>\n<p>I0 看到一个 E，发现满足第一行和第二行的需求，于是将第一行与第二行移入 I1，并将小点右移。</p>\n<p><strong>I4 状态是怎么构造的？</strong></p>\n<p>I0 状态看到（ ，发现倒数第二行满足，于是将倒数第二行移入 I4，并将小点右移，然后发现接下来期望看到的 E 是一个非终结符，于是对 E 进行闭包展开。</p>\n<p><img data-src=\"image-20230623173005062.png\" alt=\"image-20230623173005062\"></p>\n<p>哪些是接受状态？ 图中红框圈出来的是，因为其中包含了一些项，小点已经走到了末尾，表示发现了一个完整的句柄。而至于要不要规约，是接下来的事。</p>\n<h3 id=\"根据lr0自动机怎么构建分析表\"><a class=\"anchor\" href=\"#根据lr0自动机怎么构建分析表\">#</a> 根据 LR (0) 自动机怎么构建分析表</h3>\n<p><img data-src=\"image-20230524154927521.png\" alt=\"image-20230524154927521\"></p>\n<p>可以看到，这张表与之前的那张表不太一样。之前的表是在构造了 LR (0) 语法分析器后，<strong>利用 SLR</strong> 的语法规范构造的表。而上图的表是利用 LR (0) 的规范构造的。</p>\n<p>如何填写右边的表？</p>\n<p>先填所有的 s 和 g。比如 0 号状态碰到 id 变到 5 号状态，则在 action 对应位置填入 s5。0 号状态碰到 E 进入 1 号状态，则在 goto 表中填入 g1。这是前两条规则。</p>\n<p>填 r 的规则如下图的规则 3，在 LR (0) 中，如果碰到了可以做规约的第 k 个表达式，并且表达式的左部不是增广文法中的开始条件，则在 action 表对应位置填入 rk。</p>\n<p>比如下图中的 I2 状态有一个可以规约的 E-&gt;T. 其中 E—&gt;T 对应 2 号产生式，则在 2 号状态下遇到所有的符号都做规约，即 2 号产生式对应的行都填入 r2。同理 10 号产生式对应的行都填入 r3</p>\n<p><img data-src=\"image-20230531140938844.png\" alt=\"image-20230531140938844\"></p>\n<p>之前规定了 A 不能是开始符号，如果是开始符号，采用规则 4。</p>\n<p><img data-src=\"image-20230531141121981.png\" alt=\"image-20230531141121981\"></p>\n<p>四条规则总结：</p>\n<p><img data-src=\"image-20230531141214903.png\" alt=\"image-20230531141214903\"></p>\n<p>要求 A 不是增广文法中扩展的 S'</p>\n<p><img data-src=\"image-20230531141304037.png\" alt=\"image-20230531141304037\"></p>\n<p>上表中 s7,s2 s7,s1 有移入规约冲突，所以不是 LR (0) 文法</p>\n<p>以 2 号产生式 E-&gt;T 为例，可以求出 FOLLOW (E) = {+,),$} 如果在二号状态遇到了 * 号，如果进行 r2 操作，即将栈里的 T 变成 E，则现在 E 的后边就跟着一个 * 号了 这是错误的。</p>\n<h2 id=\"lr1语法分析器\"><a class=\"anchor\" href=\"#lr1语法分析器\">#</a> LR (1) 语法分析器</h2>\n<h3 id=\"slr1语法分析器\"><a class=\"anchor\" href=\"#slr1语法分析器\">#</a> SLR (1) 语法分析器</h3>\n<p>S 的含义：simple</p>\n<p>把 L (0) 语法分析表构建的第三条规则修改后，就可以得到 SLR (1) 分析表</p>\n<p +，),$>可算出 FOLLOW (E)=</p>\n<p><img data-src=\"image-20230531141739236.png\" alt=\"image-20230531141739236\"><br>\n<img data-src=\"image-20230531142412456.png\" alt=\"image-20230531142412456\"></p>\n<p><img data-src=\"image-20230531143303240.png\" alt=\"image-20230531143303240\"></p>\n<p><img data-src=\"image-20230531144019374.png\" alt=\"image-20230531144019374\"></p>\n<p>为什么优于 SLR (1)， 因为 FIRST (gamma) 包含于 FOLLOW (A)</p>\n<p><img data-src=\"image-20230531150929602.png\" alt=\"image-20230531150929602\"></p>\n<p>为什么 β 后面跟着 a，因为 β 可能是空串</p>\n<p><img data-src=\"image-20230531152400747.png\" alt=\"image-20230531152400747\"></p>\n<p><img data-src=\"image-20230531153030143.png\" alt=\"image-20230531153030143\"></p>\n<p>LR(0) &lt; LALR(1) &lt; LR(1)</p>\n<p>问题：合并后会不会影响到关联的其它状态？</p>\n<p>不会，LR (0) 项相同，出边和对应的到达状态也是可以合并的</p>\n<p>但是合并还是可能引起冲突的</p>\n<p><img data-src=\"image-20230531154243826.png\" alt=\"image-20230531154243826\"></p>\n<p><img data-src=\"image-20230531154844166.png\" alt=\"image-20230531154844166\"></p>\n<h2 id=\"lr算法的特点\"><a class=\"anchor\" href=\"#lr算法的特点\">#</a> LR 算法的特点</h2>\n<p><img data-src=\"image-20230602141654975.png\" alt=\"image-20230602141654975\"></p>\n<p>为什么？ 因为一个 L 语言可以用 G1 文法和 G2 文法表示，这时 G1 可能刚好满足 SLR（1），G2 刚好满足 LR（1）</p>\n<p>要区分 <strong>文法</strong> 和 <strong>语言</strong></p>\n<p>也就是一个语言能写出 LR (1) 的文法，就一定能写出 SLR (1) 的文法</p>\n<p><img data-src=\"image-20230602142434949.png\" alt=\"image-20230602142434949\"></p>\n<p><img data-src=\"image-20230602142715980.png\" alt=\"image-20230602142715980\"></p>\n<p>{+,*} 属于 FOLLOW (E)</p>\n<p>譬如这里的 I7 状态： + 号即属于 Follow (E) 也是当前看到的下一个符号，因此看到＋号既可以规约也可以移入，产生冲突。</p>\n<p>这里根据实际地考量（优先级与结合性），即如果碰到 E+E+E 应该先算出左边两个 E 相加的结果，因此 E+E . 碰到＋号应该选择规约</p>\n<h2 id=\"lab2\"><a class=\"anchor\" href=\"#lab2\">#</a> lab2</h2>\n<h3 id=\"实验内容\"><a class=\"anchor\" href=\"#实验内容\">#</a> 实验内容</h3>\n<ul>\n<li>本次实验需要完成语法分析与高亮，要求如下\n<ul>\n<li>根据实验指导内提供的文档完成 SysyParser.g4 并将 SysYParser.g4 中按下面已经给出的写法将 exp 和 cond 写成左递归</li>\n<li>当<strong>输入文件存在语法错误时</strong>：输出语法错误在哪一行，格式为 <code>Error type B at Line [lineNo]:[errorMessage]</code>  其中 lineNo 为出错的 token 首个字符所在行的行号，errorMessage 可自行定义，本实验不做要求，只要冒号前的信息正确即可，需要输出所有的错误</li>\n<li>当<strong>输入文件不存在语法错误时</strong>：按照规定格式输出语法树 (含高亮)，输出格式详见<strong>样例一</strong></li>\n<li>使用 ** 标准错误输出（System.err）** 打印所有运行结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实验过程\"><a class=\"anchor\" href=\"#实验过程\">#</a> 实验过程</h3>\n<p>仍然需要重写 BaseErrorListener 实现一个自己的 myErrorListener。与实验一不同的是，除法 ErrorListener 的方式不同，本次实验要在语法分析的过程中进行错误检查。改写的 main 函数如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"input path is required\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token class-name\">String</span> source <span class=\"token operator\">=</span> args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token class-name\">CharStream</span> input <span class=\"token operator\">=</span> <span class=\"token class-name\">CharStreams</span><span class=\"token punctuation\">.</span><span class=\"token function\">fromFileName</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//\t\tSysYLexer sysYLexer = new SysYLexer(input);</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">//\t\tsysYLexer.removeErrorListeners();</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//\t\tsysYLexer.addErrorListener(new myErrorListener());</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">//\t\tList&lt;Token> tokens = (List&lt;Token>) sysYLexer.getAllTokens();</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token class-name\">SysYLexer</span> sysYLexer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SysYLexer</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t<span class=\"token class-name\">CommonTokenStream</span> tokens <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CommonTokenStream</span><span class=\"token punctuation\">(</span>sysYLexer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token class-name\">SysYParser</span> parser <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SysYParser</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\tparser<span class=\"token punctuation\">.</span><span class=\"token function\">removeErrorListeners</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\tparser<span class=\"token punctuation\">.</span><span class=\"token function\">addErrorListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">myErrorListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token class-name\">ParseTree</span> tree <span class=\"token operator\">=</span> parser<span class=\"token punctuation\">.</span><span class=\"token function\">program</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token class-name\">Visitor</span> visitor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Visitor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\tvisitor<span class=\"token punctuation\">.</span><span class=\"token function\">visit</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">//\t\tString[] rulenames = sysYLexer.getRuleNames();</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">//\t\tfor (Token token : tokens) &#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">//\t\t\tString tokenType = rulenames[token.getType()-1];</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">//\t\t\tString tokenText = toDemical(token.getText());</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">//\t\t\tString tokenLine = \"\"+token.getLine();</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">//\t\t\tSystem.err.println(tokenType + \" \" + tokenText + \" at Line \"+tokenLine+'.');</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">//\t\t&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>其中注释掉的部分是实验一的代码。这次要将 errorlistener 加到语法分析器 parser 上 并且利用 parser.program () 触发错误检查并生成语法树。注意，之所以用 program () 方法当做入口方法是因为 SysYParser.g4 的定义中 program 是最高的语言层次。</p>\n<p>本次实验最重要的内容就是重写了一个继承自 SysYParserBaseVisitor 的类 Vistor 代码如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Visitor</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SysYParserBaseVisitor</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Void</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> depth <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Void</span> <span class=\"token function\">visitChildren</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RuleNode</span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t<span class=\"token class-name\">Void</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">defaultResult</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\t<span class=\"token class-name\">StringBuilder</span> sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\tsb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"  \"</span><span class=\"token punctuation\">.</span><span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> depth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t<span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">getRuleContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRuleIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\t<span class=\"token class-name\">String</span> ruleName <span class=\"token operator\">=</span> <span class=\"token class-name\">SysYParser</span><span class=\"token punctuation\">.</span>ruleNames<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\truleName <span class=\"token operator\">=</span> <span class=\"token class-name\">Character</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span>ruleName<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> ruleName<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\tsb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>ruleName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>sb<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\t<span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">shouldVisitNextChild</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\t\tdepth <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\t\t<span class=\"token class-name\">ParseTree</span> c <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">getChild</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\t\t<span class=\"token class-name\">Void</span> childResult <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t\t\tresult <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">aggregateResult</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> childResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\t\tdepth <span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t<span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Void</span> <span class=\"token function\">visitTerminal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TerminalNode</span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\t\t<span class=\"token class-name\">StringBuilder</span> sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t\tsb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"  \"</span><span class=\"token punctuation\">.</span><span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> depth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t\t<span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">getSymbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>ruleNames<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\t\t\tsb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token function\">toDemical</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span><span class=\"token function\">getText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\t\t\tsb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>ruleNames<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>sb<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> ruleNames <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t\t\t\t<span class=\"token string\">\"CONST[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"INT[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"VOID[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"IF[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ELSE[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"WHILE[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"BREAK[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"CONTINUE[orange]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"RETURN[orange]\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t\t\t\t<span class=\"token string\">\"PLUS[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"MINUS[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"MUL[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"DIV[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"MOD[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ASSIGN[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"EQ[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"NEQ[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"LT[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"GT[blue]\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\t\t\t\t<span class=\"token string\">\"LE[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"GE[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"NOT[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"AND[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"OR[blue]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t\t\t\t<span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"IDENT[red]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"INTEGER_CONST[green]\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t\t\t\t<span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t\t\t\t<span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>visitChildren 是当 dfs 遍历每个语法节点时都会触发的方法，一开始没有想到在遍历某个节点时如何得到该节点的深度，后面通过维护一个全局变量 depth 来实现。当进入节点前 depth 会 + 1 退出时会 - 1。</p>\n<p><img data-src=\"image-20230328210917158.png\" alt=\"image-20230328210917158\"></p>\n<p>这里简单的把 accept 方法理解为会调用 visitor.visitChildren (currentnode) 的函数就好了。</p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2023/03/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8601-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/",
            "url": "http://example.com/2023/03/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8601-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/",
            "title": "编译原理01-词法分析",
            "date_published": "2023-03-09T02:58:10.000Z",
            "content_html": "<h1 id=\"编译原理01-词法分析\"><a class=\"anchor\" href=\"#编译原理01-词法分析\">#</a> 编译原理 01 - 词法分析</h1>\n<p>词法分析： 输入（程序文本 / 字符串 s）--&gt; 输出（词法单元流）</p>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"image-20230309110603730.png\" alt=\"image-20230309110603730\"></p>\n<h2 id=\"词法分析器的三种设计方法由易到难\"><a class=\"anchor\" href=\"#词法分析器的三种设计方法由易到难\">#</a> 词法分析器的三种设计方法（由易到难）</h2>\n<ol>\n<li>词法分析器生成器（如 ANTLR）</li>\n<li>手写词法分析器</li>\n<li>自动化词法分析器 (自己实现一个词法分析器生成器)</li>\n</ol>\n<p>生产环境下的编译器（如 gcc）通常选择手写词法分析器</p>\n<h2 id=\"antrl的使用\"><a class=\"anchor\" href=\"#antrl的使用\">#</a> antrl 的使用</h2>\n<p>输入： 词法单元的规约 -<strong>SimpleExpr.g4</strong></p>\n<p>输出：词法分析器 -  <strong>SimpleExprLexer.java</strong></p>\n<p>​\t\t\t\tSimpleExprLexer.java 编译后 接受输入文件 并输出 token 流</p>\n<h2 id=\"g4文件的结构\"><a class=\"anchor\" href=\"#g4文件的结构\">#</a> .g4 文件的结构</h2>\n<p>第一行： <code>grammar SimpleExpr ;</code>  给接下来的文法起个名字 名字要与文件名一致</p>\n<p>​\t\t\t\t\t** 如果文件里只包含词法部分 用 lexer grammar SysYLexer **</p>\n<p>​\t\t\t\t\t 每一行都要以分号结尾</p>\n<p>@header {} 括号里的东西会自动拷贝到到 java 文件中</p>\n<p>语法规则见下面示例</p>\n<p>SimpleExpr.g4:</p>\n<pre><code class=\"language-Antlr\">grammar SimpleExpr;\n\nimport SimpleExprRules;\n\n@header&#123;\npackage simpleexpr;\n&#125;\n\nprog : stat* EOF ;\n\nstat : expr ';'\n     | ID '=' expr ';'\n     | 'if' expr ';'\n     ;\n\nexpr : expr ('*' | '/') expr\n     | expr ('+' | '-') expr\n     | '(' expr ')'\n     | ID\n     | INT\n     | FLOAT\n     ;\n    // 到这里描述的其实还是语法结构\n</code></pre>\n<p>SimpleExprRules.g4:</p>\n<pre><code class=\"language-Antlr\">lexer grammar SimpleExprRules;\n\nSEMI : ';' ;\nASSIGN : '=' ;\nIF : 'if' ;\nMUL : '*' ;\nDIV : '/' ;\nADD : '+' ;\nSUB : '-' ;\nLPAREN : '(' ;\nRPAREN : ')' ;\n\nID : (LETTER | '_') WORD* ;\nINT : '0' | ([1-9] DIGIT*) ;\nFLOAT : INT '.' DIGIT*\n      | '.' DIGIT+\n      ;\n\nWS : [ \\t\\r\\n]+ -&gt; skip ;\n\n//SL_COMMENT : '//' .*? '\\n' -&gt; skip ;\nSL_COMMENT2 : '//' ~[\\n]* '\\n' -&gt; skip;\nDOC_COMMENT : '/**' .*? '*/' -&gt; skip ;\nML_COMMENT : '/*' .*? '*/' -&gt; skip ;\n\nfragment LETTER : [a-zA-Z] ;\nfragment DIGIT : [0-9] ;\nfragment WORD : LETTER | DIGIT | '_' ;\n//以上才是真正的词法部分\n\n</code></pre>\n<h2 id=\"用编程方式使用antlr-4-生成的xxxlexerjava\"><a class=\"anchor\" href=\"#用编程方式使用antlr-4-生成的xxxlexerjava\">#</a> 用编程方式使用 ANTLR 4 生成的 xxxlexer.java</h2>\n<pre><code>package simpleexpr;\n\nimport org.antlr.v4.runtime.CharStream;\nimport org.antlr.v4.runtime.CharStreams;\nimport org.antlr.v4.runtime.CommonTokenStream;\nimport org.antlr.v4.runtime.Token;\nimport org.antlr.v4.runtime.tree.ParseTree;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SimpleExprTest &#123;\n  public static void main(String[] args) throws IOException &#123;\n    System.out.println(&quot;SimpleExprTest ...&quot;);\n\n    InputStream is = System.in;\n\n    String file;\n    if (args.length &gt; 0) &#123;\n      file = args[0];\n      is = new FileInputStream(file);\n    &#125;\n\n    CharStream input = CharStreams.fromStream(is);\n    //SimpleExprLexer 是.g4文件生成的java类 input必须是CharStream格式\n    SimpleExprLexer lexer = new SimpleExprLexer(input);\n\t\n    lexer.getAllTokens().forEach(System.out::println);\n  &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"正则表达式\"><a class=\"anchor\" href=\"#正则表达式\">#</a> 正则表达式</h2>\n<p>基本的知识就不记录了 记录一些重要的</p>\n<ul>\n<li>非贪婪匹配  <code>.*?</code></li>\n<li>反向引用 要引用的用（）括起来，后面引用通过子表达式下标访问，如 \\1，下标从 1 开始</li>\n<li>look ahead ?&lt;= 符号，表示前面字符要满足 xxx，但不匹配 xxx</li>\n<li>look back  ?= 符号，表示后面字符要满足 xxx，但不匹配 xxx</li>\n</ul>\n<h2 id=\"nfa与dfa\"><a class=\"anchor\" href=\"#nfa与dfa\">#</a> NFA 与 DFA</h2>\n<p>NFA：非确定性自动机  DFA: 确定性有穷自动机（Deterministic Finite Automaton)</p>\n<p><img data-src=\"image-20230320200945838.png\" alt=\"image-20230320200945838\"></p>\n<p>区别：</p>\n<ul>\n<li>NFA 简洁易于理解，便于描述语言 L (A)</li>\n<li>DFA 易于判断 x 属于 L (A)，适合产生词法分析器</li>\n</ul>\n<p>​    其中 L (A) 是使当前自动机能进入接受状态的输入集合</p>\n<p>一般用 NFA 描述语言，用 DFA 实现词法分析器</p>\n<p><strong>实现词法分析器的步骤：RE --&gt; NFA --&gt; DFA --&gt; 词法分析器</strong></p>\n<p>如图： 根据 DFA 生成 RE 不需要掌握</p>\n<p><img data-src=\"image-20230320201739378.png\" alt=\"image-20230320201739378\"></p>\n<h2 id=\"thompson构造法从re-到-nfa\"><a class=\"anchor\" href=\"#thompson构造法从re-到-nfa\">#</a> Thompson 构造法（从 RE 到 NFA）</h2>\n<p><img data-src=\"image-20230315141912075.png\" alt=\"image-20230315141912075\"></p>\n<p>构造方法如下：</p>\n<p><img data-src=\"image-20230320203523098.png\" alt=\"image-20230320203523098\"></p>\n<p><img data-src=\"image-20230320203542881.png\" alt=\"image-20230320203542881\"></p>\n<p><img data-src=\"image-20230320203600728.png\" alt=\"image-20230320203600728\"></p>\n<p><img data-src=\"image-20230320203629409.png\" alt=\"image-20230320203629409\"></p>\n<p>这里是 “一边做构造 一边做证明”，只要保证从最基本的情况开始，每一步 NFA 的构造都保证只会有唯一的开始状态和接受状态即可。综合所有情况下的构造方法，可以看到这一点是正确的。</p>\n<p><img data-src=\"image-20230320203705399.png\" alt=\"image-20230320203705399\"></p>\n<p><img data-src=\"image-20230320203721076.png\" alt=\"image-20230320203721076\"></p>\n<p><img data-src=\"image-20230315142444609.png\" alt=\"image-20230315142444609\"></p>\n<p>关于第三点中的运算符合运算分量 gpt 的解释：</p>\n<p>正则表达式语言 r 的运算符和运算分量：</p>\n<p>常见运算符：</p>\n<ul>\n<li>|：或运算符，用于匹配两种情况中的一种。</li>\n<li>()：分组运算符，用于将多个运算分量组合起来形成一个单元，进行整体匹配或量词修饰。</li>\n<li>[]：字符类运算符，用于匹配方括号内任意一个字符。</li>\n<li>{}：重复运算符，用于指定运算分量重复出现的次数。</li>\n</ul>\n<p>运算分量：</p>\n<ul>\n<li>字符：指定具体的字符，例如 a、b、c 等。</li>\n<li>元字符：具有特殊意义的字符，例如 *、?、+ 等。</li>\n<li>点号：匹配除换行符以外的任意字符。</li>\n</ul>\n<p>这些运算符和运算分量可以组合在一起形成复杂的正则表达式，用于模式匹配和字符串搜索。</p>\n<p><strong>在每一步构造的时候，最多加一个起始状态，一个终止状态，总共进行了 | r | 次，所以第三点正确</strong></p>\n<p>举个例子：(a|b)*abb 的构造（考试会考）</p>\n<p><img data-src=\"image-20230315142551213.png\" alt=\"image-20230315142551213\"></p>\n<h2 id=\"子集构造法从nfa到dfa的转换\"><a class=\"anchor\" href=\"#子集构造法从nfa到dfa的转换\">#</a> 子集构造法 (从 NFA 到 DFA 的转换)：</h2>\n<p><img data-src=\"image-20230315142711571.png\" alt=\"image-20230315142711571\"></p>\n<p>举个例子： 可以看出简化了很多，并且遇到某一词法单元改走到那一步更加明确了</p>\n<p><img data-src=\"image-20230610165958021.png\" alt=\"image-20230610165958021\"></p>\n<p>从 0 号状态开始，通过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span> 转移可以到达 1,2,4,7 因此这 5 个状态合为一个状态 A，然后看 A 状态下可以通过 a 字符和 b 字符转移到哪些状态，即下图的规则三，然后利用规则二和规则一求可到达状态的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span> 闭包，这个过程循环下去直到结束。</p>\n<p><strong>什么时候算结束？</strong></p>\n<p>只要 DFA 的某个状态所对应的 NFA 中的状态集合中含有接受状态，则 DFA 的这个状态是接受状态</p>\n<p><img data-src=\"image-20230610174226627.png\" alt=\"image-20230610174226627\"></p>\n<p>这里 E 对应的 NFA 状态中有 10 号状态，而 10 号状态是 NFA 的接受状态，所以 E 也是接受状态</p>\n<p>三个基本规则如下 其中 s 是单个状态 T 是一个状态子集</p>\n<p>这个过程一定会有一个终点</p>\n<p><img data-src=\"image-20230315143847385.png\" alt=\"image-20230315143847385\"></p>\n<p>原理如下：</p>\n<p><img data-src=\"image-20230315143949988.png\" alt=\"image-20230315143949988\"></p>\n<p><strong>复杂度：NFA 有 n 个状态 DFA 最多有 2 的 n 次方个状态 指数爆炸</strong></p>\n<h2 id=\"dfa最小化算法\"><a class=\"anchor\" href=\"#dfa最小化算法\">#</a> DFA 最小化算法</h2>\n<p>问题一： 如何定义等价状态</p>\n<p>想法一： 其中波浪号意为等价</p>\n<p>​\t\t\t\t\t即 s 状态等价与 t 状态 当且仅当 任意 a 属于字母表 s 与 t 在 a 输入下发生转移后的状态是等价的</p>\n<p><img data-src=\"image-20230320210948252.png\" alt=\"image-20230320210948252\"></p>\n<p>但是这个定义是错误的 课件上有反例</p>\n<p>反过来是正确做法：</p>\n<p>核心思想<strong>做划分而非合并</strong></p>\n<p>接受状态与非接受状态必定不等价 ，然后接着划分，直到不能再分为止。每一步做迭代 对一个状态集合的任意两个状态，如果在字符 a 的驱动下跑到了不同的组，则这两个状态一定不等价。</p>\n<p><strong>做之前要补齐死状态。</strong></p>\n<p>因为这是所谓的 DFA 最小化算法 首先得保证最小化的是一个 DFA。比如下图中如果一开始只有红字部分，需要加上黄字部分补成一个 DFA。</p>\n<p><img data-src=\"image-20230622220426917.png\" alt=\"image-20230622220426917\"></p>\n<p>如果某个等价类包含初始状态，那么合并后这个等价类就是初始状态，如果某个等价类包含结束状态，那么合并后这个等价类就是合并状态。</p>\n<p><img data-src=\"image-20230610182322478.png\" alt=\"image-20230610182322478\"></p>\n<h3 id=\"复杂度\"><a class=\"anchor\" href=\"#复杂度\">#</a> 复杂度</h3>\n<p>太复杂了</p>\n<h2 id=\"从dfa得到词法分析器\"><a class=\"anchor\" href=\"#从dfa得到词法分析器\">#</a> 从 DFA 得到词法分析器</h2>\n<p>需要消除死状态 ，避免徒劳消耗输入流</p>\n<p>模拟运行该 DFA, 直到无法继续为止（输入结束或状态无转移）：假设此时状态为 s，若 s 为接受状态，则识别成功，否则，回溯（包括状态与输入流）至最近一次经过的接受状态，识别成功；若没有经过任何接受状态，则报错（忽略第一个字符，重新开始）</p>\n<p>用在词法分析器场景下的 DFA 的最小化第一步不同，所有的接受状态一定不等价</p>\n<h2 id=\"根据dfa得到re非重点\"><a class=\"anchor\" href=\"#根据dfa得到re非重点\">#</a> 根据 DFA 得到 RE (非重点)</h2>\n<h2 id=\"lab-1\"><a class=\"anchor\" href=\"#lab-1\">#</a> lab 1</h2>\n<p>编程一小时 配置环境一天的典型代表。</p>\n<h3 id=\"实验输入\"><a class=\"anchor\" href=\"#实验输入\">#</a> 实验输入</h3>\n<p>本次实验的输入是一个包含了 <code>SysY</code>  源代码的文件，你的程序需要接受一个文件名作为参数</p>\n<h3 id=\"实验内容\"><a class=\"anchor\" href=\"#实验内容\">#</a> 实验内容</h3>\n<h3 id=\"part1-词法分析\"><a class=\"anchor\" href=\"#part1-词法分析\">#</a> <span class=\"exturl\" data-url=\"aHR0cDovLzQ3LjEyMi4zLjQwOjgwODEvIy8yMDIzL2xhYjEtbGV4ZXIvbGFiMS1sZXhlcj9pZD1wYXJ0MS0lRTglQUYlOEQlRTYlQjMlOTUlRTUlODglODYlRTYlOUUlOTA=\">Part1 词法分析</span></h3>\n<ul>\n<li>本次实验你需要完成一个词法分析器对使用 SysY 语言书写的源代码进行词法分析，要求如下\n<ul>\n<li>本次实验要求通过<strong>标准错误输出（stderr, 如 System.err 等）</strong>， 打印程序的 <strong>所有</strong> 运行结果。</li>\n<li>当<strong>包含词法错误时</strong>：对于包含词法错误的文件，你需要打印<strong>所有</strong>错误信息，格式为： <code>Error type A at Line [lineNo]:[errorMessage]</code> ，其中 <code>lineNo</code>  为出错的 <code>token</code>  首个字符所在行的行号， <code>errorMessage</code>  可自行定义，本实验不做要求，只要冒号前的信息正确即可。</li>\n<li>当<strong>不包含词法错误时</strong>：对于没有任何词法错误的文件，你需要打印所有识别到的 <code>Tokens</code>  信息，具体输出格式可以参见<strong>样例一</strong>。特别要求：输出时忽略所有注释，对十六进制和八进制数字常量输出 <code>token</code>  文本时需输出其十进制的值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"样例\"><a class=\"anchor\" href=\"#样例\">#</a> 样例</h3>\n<p>输入</p>\n<pre><code class=\"language-SysY\">int main() \n&#123;\n   // line comment\n   /* \n     block comment\n   */\n   int i = 0x1;\n&#125;\n</code></pre>\n<p>输出</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token constant\">INT</span> <span class=\"token keyword\">int</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">1.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token constant\">IDENT</span> main at <span class=\"token class-name\">Line</span> <span class=\"token number\">1.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token constant\">L_PAREN</span> <span class=\"token punctuation\">(</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">1.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token constant\">R_PAREN</span> <span class=\"token punctuation\">)</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">1.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token constant\">L_BRACE</span> <span class=\"token punctuation\">&#123;</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">2.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token constant\">INT</span> <span class=\"token keyword\">int</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">7.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token constant\">IDENT</span> i at <span class=\"token class-name\">Line</span> <span class=\"token number\">7.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token constant\">ASSIGN</span> <span class=\"token operator\">=</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">7.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token constant\">INTEGER_CONST</span> <span class=\"token number\">1</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">7.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token constant\">SEMICOLON</span> <span class=\"token punctuation\">;</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">7.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token constant\">R_BRACE</span> <span class=\"token punctuation\">&#125;</span> at <span class=\"token class-name\">Line</span> <span class=\"token number\">8.</span></pre></td></tr></table></figure><p>解释：</p>\n<p>每行输出一个 token 的信息，输出格式为</p>\n<pre><code>[token类型] [token文本] at Line [此token首个字符所在行的行号].复制到剪贴板复制失败复制成功!\n</code></pre>\n<p><strong>输出时忽略所有注释，对十六进制和八进制数字常量输出 token 文本时需输出其十进制的值</strong></p>\n<p>特别注意，遇到如 <code>int 2i = 08;</code>  这种输入时，请将 <code>2i</code>  识别为 <code>INTEGER_CONST</code>  和 <code>IDENT</code> ， <code>08</code>  识别为两个 <code>INTEGER_CONST</code> ，这种我们不认为是词法错误，这种错误将在后面的实验中处理</p>\n<h3 id=\"样例二\"><a class=\"anchor\" href=\"#样例二\">#</a> <span class=\"exturl\" data-url=\"aHR0cDovLzQ3LjEyMi4zLjQwOjgwODEvIy8yMDIzL2xhYjEtbGV4ZXIvbGFiMS1sZXhlcj9pZD0lRTYlQTAlQjclRTQlQkUlOEIlRTQlQkElOEM=\">样例二</span></h3>\n<p>输入:</p>\n<pre><code class=\"language-SysY\">int main()&#123;\n  int i = 1;\n  int j = ~i;\n&#125;复制到剪贴板复制失败复制成功!\n</code></pre>\n<p>输出：</p>\n<pre><code>Error type A at Line 3: Mysterious character &quot;~&quot;.\n</code></pre>\n<h2 id=\"实验过程\"><a class=\"anchor\" href=\"#实验过程\">#</a> 实验过程</h2>\n<ul>\n<li>\n<p>第一个难题就是怎么在 windows 里的 IDEA 编程，但是运行和调试环境是虚拟机中的 ubuntu20.04+lab0 配置好的环境 想法就是用 IDEA 的 remote deployment 功能，在网上搜索教程后发现我的 IDEA 竟然没有这个功能，原因是我的是 community 版本，所以卸载了之前的 IDEA 装了专业版。然后 remote deployment 原理应该是使用 ssh 连接，虽然虚拟机是装在电脑里，但其实和与远程服务器相连原理是一样的。</p>\n</li>\n<li>\n<p>然后编写.g4 文件比较顺利，生成了 SysYlexer.java 文件，但是在 main 函数中使用 SysYlexer 类也遇见了困难，首先是导入 antlr，IDEA 一直报错无法解析 symbol antlr，但是 lab0 中我应该是配好了 antlr 环境的，不知道为什么，所以还是用 IDEA 的 libraries 中导入了 antlr 才好   (回来再看，IDEA 是可以导入本地的 jar 包的)</p>\n</li>\n<li>\n<p>第三个难题就是删除 SysYLexer 中自带的 ErrorListeners, 使用自己编写的 errorlisteners，这里蚂蚁老师上课应该是没有讲的，所以也是无从下手。后面借助搜索引擎和 ChatGPT 学了很久才会。原理很简单，先放上自己实现的 myErrorListener 如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> myErrorListener <span class=\"token keyword\">extends</span> <span class=\"token class-name\">BaseErrorListener</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">syntaxError</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Recognizer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> recognizer<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token class-name\">Object</span> offendingSymbol<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token keyword\">int</span> line<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> charPositionInLine<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token class-name\">String</span> msg<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token class-name\">RecognitionException</span> e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error type A at Line \"</span><span class=\"token operator\">+</span>line<span class=\"token operator\">+</span><span class=\"token string\">\": \"</span><span class=\"token operator\">+</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\terror <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>主要是重写了 syntaxError 这个函数，他里面的参数应该是报错相关的信息，这里只用到了 line（出错的行）和 msg（具体的报错信息），其它的是什么意思忘记了。应该是每出现一个错误就会调用一次 syntaxError 函数。</p>\n</li>\n<li>\n<p>然后放一下 main 函数部分：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">org<span class=\"token punctuation\">.</span>antlr<span class=\"token punctuation\">.</span>v4<span class=\"token punctuation\">.</span>runtime<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Collection</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">List</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> error <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"input path is required\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token class-name\">String</span> source <span class=\"token operator\">=</span> args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token class-name\">CharStream</span> input <span class=\"token operator\">=</span> <span class=\"token class-name\">CharStreams</span><span class=\"token punctuation\">.</span><span class=\"token function\">fromFileName</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t<span class=\"token class-name\">SysYLexer</span> sysYLexer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SysYLexer</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\tsysYLexer<span class=\"token punctuation\">.</span><span class=\"token function\">removeErrorListeners</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\tsysYLexer<span class=\"token punctuation\">.</span><span class=\"token function\">addErrorListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">myErrorListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Token</span><span class=\"token punctuation\">></span></span> tokens <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Token</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span> sysYLexer<span class=\"token punctuation\">.</span><span class=\"token function\">getAllTokens</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> rulenames <span class=\"token operator\">=</span> sysYLexer<span class=\"token punctuation\">.</span><span class=\"token function\">getRuleNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Token</span> token <span class=\"token operator\">:</span> tokens<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t\t<span class=\"token class-name\">String</span> tokenType <span class=\"token operator\">=</span> rulenames<span class=\"token punctuation\">[</span>token<span class=\"token punctuation\">.</span><span class=\"token function\">getType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t\t<span class=\"token class-name\">String</span> tokenText <span class=\"token operator\">=</span> <span class=\"token function\">toDemical</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">.</span><span class=\"token function\">getText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\t\t<span class=\"token class-name\">String</span> tokenLine <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token operator\">+</span>token<span class=\"token punctuation\">.</span><span class=\"token function\">getLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>tokenType <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> tokenText <span class=\"token operator\">+</span> <span class=\"token string\">\" at Line \"</span><span class=\"token operator\">+</span>tokenLine<span class=\"token operator\">+</span><span class=\"token char\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> myErrorListener <span class=\"token keyword\">extends</span> <span class=\"token class-name\">BaseErrorListener</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">syntaxError</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Recognizer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> recognizer<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token class-name\">Object</span> offendingSymbol<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token keyword\">int</span> line<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> charPositionInLine<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token class-name\">String</span> msg<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t\t\t\t\t\t\t\t<span class=\"token class-name\">RecognitionException</span> e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t\t<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error type A at Line \"</span><span class=\"token operator\">+</span>line<span class=\"token operator\">+</span><span class=\"token string\">\": \"</span><span class=\"token operator\">+</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t\t\terror <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toDemical</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0[0-7]+\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0[xX][0-9a-fA-F]+\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span> text<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>反正做的时候除了文档里给的框架几乎每一行都想了很久。</p>\n</li>\n<li>\n<p>代码写完后上传又有问题，可能是之前 make compile , make clean 太多次了，导致压缩包超过了 10M 的限制，后来参考助教给的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaG9sbGlzY2h1YW5nLmNvbS9hcmNoaXZlcy8xNzA4\">记一次删除 Git 记录中的大文件的过程 - HollisChuang's Blog</span> 按里面的步骤一步步做才完成上传，比较幸运的是一次就 AC 了。（至于为什么压缩包会那么大，我的理解是改动了太多次代码 make compile 了太多次，且每次 git 都会保存版本信息以便于回退，所以改动的所有版本其实都还在 git 保存的隐藏文件夹下的，所以整个目录就会变得很大了）</p>\n</li>\n</ul>\n",
            "tags": [
                "编译原理"
            ]
        }
    ]
}