<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++：移动语义与右值引用</title>
    <url>/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="c的移动语义与右值引用"><a class="anchor" href="#c的移动语义与右值引用">#</a> C++ 的移动语义与右值引用</h1>
<p><span id="more"></span></p>
<p><img data-src="preview.jpg" alt="Gaze"></p>
<h2 id="移动语义"><a class="anchor" href="#移动语义">#</a> 移动语义</h2>
<h3 id="为何需要移动语义"><a class="anchor" href="#为何需要移动语义">#</a> 为何需要移动语义</h3>
<p>假设有如下代码：</p>
<pre><code class="language-c++">vector&lt;string&gt; vstr;// build up a vector of 20000 strings,each of 1000 characters
vector&lt;string&gt; vstr_copy1(vstr);
</code></pre>
<p>为了初始化 vstr_copy1 先调用 vector 的复制构造函数，使用 new 给 20000 个 string 对象分配内存，而每个 string 对象又调用 string 的复制构造函数，为 1000 个字符分配内存。这很浪费时间，但如果 vstr 与 vstr_copy1 都需要使用，这很难避免。</p>
<p>可有时候这样不太妥当，例如 vstr 不再被使用时。例如如下定义的函数：</p>
<pre><code class="language-c++">vector&lt;string&gt; allcaps(const vector&lt;string&gt; &amp; vs)
&#123;
    vector&lt;string&gt; temp;
    //让temp存储vs中string的大写版本的代码
    return temp;
&#125;
</code></pre>
<p>并这样使用它：</p>
<pre><code class="language-c++">vector&lt;string&gt; vstr;
vector&lt;string&gt; vstr_copy1(vstr); //#1
vector&lt;string&gt; vstr_copy2(allcaps(vstr)); //#2
</code></pre>
<p>allcaps () 创建了对象 temp，该对象管理着 20000000 个字符；语句二使用 vector 和 string 的复制构造函数创建了一个 temp 的副本，然后删除了 temp，做了大量无用功。如果编译器直接把 temp 对数据的所有权转让给 vstr_copy2，将会更好。</p>
<p>实际上，我们可以把实际内容保留在原来地方，而之修改记录，这就是移动语义的本质，它避免了移动原始数据，而转为修改记录。</p>
<p>要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制。这就是右值引用发挥作用的地方。可定义两个构造函数，其中一个是常规复制构造函数，它使用 const 左值引用作为参数，如语句 #1。另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参，如语句 #2 中 allcaps (vstr) 的返回值。移动构造函数可能修改其实参，这意味着右值引用参数不应是 const。</p>
<h3 id="如何使用"><a class="anchor" href="#如何使用">#</a> 如何使用</h3>
<p>直接将变量的值赋值为参数的变量值，如果变量为指针，为了防止 double free，还需将参数的指针改为 nullptr。</p>
<p>例如：</p>
<pre><code>Useless(Useless &amp;&amp; f) : n(f.n)
&#123;
	++ct;
	pc = f.pc;
	f.pc = nullptr;
	f.n = 0;
&#125;
</code></pre>
<h3 id="强制移动"><a class="anchor" href="#强制移动">#</a> 强制移动</h3>
<p>移动构造函数和移动赋值运算符使用右值，如果要让它们使用左值，该怎么办？例如，将一个左值变量赋值给一个对象，并立刻丢弃这个变量。此时可以使用头文件 utility 中声明的函数 std::move。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Efective Modern C++读书笔记</title>
    <url>/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本书主要设计 C++11/14 的新语言特性，Modern C++ 带来的各种改变是亡羊补牢，还是脱胎换骨，通过阅读本书可能会得到答案。</p>
<p>看书是一件乐趣，写读书笔记可不是😢。但是就阅读《Efective C++》的经历而言，减慢阅读速度而留下记录是很重要的，不知本篇何时才能完成。</p>
<p><span id="more"></span></p>
<h2 id="chapter-1-类型推导"><a class="anchor" href="#chapter-1-类型推导">#</a> chapter 1 类型推导</h2>
<h3 id="item1-理解模板类型推导"><a class="anchor" href="#item1-理解模板类型推导">#</a> item1 理解模板类型推导</h3>
<p>模板类型推导，是 C++ 一个广泛应用的特性，并且可以被称为一个良好的设计，因为很多程序员都在完全不了解其底层运行机制的情况下，获得了满意的结果。C++ 11 带来了 <code>auto</code> ，模板类型推导也是其运行的基础，一个坏消息是有些时候它的应用并不符合直觉，因此了解模板类型推导的一些细节就有些重要了。</p>
<p>考虑如下一个函数模板：</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(ParamType param)
</code></pre>
<p>这里的 ParamType 是与 T 有关的一个类型，比如 <code>const T</code>  , <code>T &amp;</code>  等</p>
<p>对于某一次调用 <code>f(expr)</code>  , T 的推导结果会是什么呢，答案是，<strong>既与 expr 的类型有关也和 ParamType 有关</strong>，具体要分为三种情况讨论。</p>
<h4 id="情况1-paramtype是一个指针或引用但不是一个万能引用"><a class="anchor" href="#情况1-paramtype是一个指针或引用但不是一个万能引用">#</a> 情况 1： ParamType 是一个指针或引用，但不是一个万能引用</h4>
<p>这种情况下，类型推导会这样运作：</p>
<ol>
<li>若 expr 具有引用类型，先将引用部分忽略</li>
<li>然后，对 <code>expr</code>  的类型和 <code>ParamType</code>  的类型执行模式匹配，来决定 T 的类型。</li>
</ol>
<p>for example:</p>
<pre><code class="language-c++">// 对与如下模式
template&lt;typename T&gt;
void f(T&amp; param) // param 是一个引用

int x = 27;
const int cx = x;
const int&amp; rx = x;

f(x);                           //T是int，param的类型是int&amp;
f(cx);                          //T是const int，param的类型是const int&amp;
f(rx);                          //T是const int，param的类型是const int&amp;

</code></pre>
<p>这些例子只展示了左值引用，但是类型推导会如左值引用一样对待右值引用。</p>
<h4 id="情况2-paramtype-是一个万能引用"><a class="anchor" href="#情况2-paramtype-是一个万能引用">#</a> 情况 2： ParamType 是一个万能引用</h4>
<p>对于使用万能引用形参的模板而言，规则就没那么显明了：</p>
<ol>
<li>如果 expr 是左值， <code>T</code>  和 ParamType 都会被推导为左值引用。这个结果又两点比较奇怪：首先，这是在模板类型推导中，T 被推导为引用类型的唯一情形。其次，尽管在声明时使用的是右值引用语法，它的类型推导结果却是左值引用。</li>
<li>如果 expr 是一个右值，则应用情况 1 中的规则</li>
</ol>
<p>例如：</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp;&amp; param);              //param现在是一个通用引用类型
        
int x=27;                       //如之前一样
const int cx=x;                 //如之前一样
const int &amp; rx=cx;              //如之前一样

f(x);                           //x是左值，所以T是int&amp;，
                                //param类型也是int&amp;

f(cx);                          //cx是左值，所以T是const int&amp;，
                                //param类型也是const int&amp;

f(rx);                          //rx是左值，所以T是const int&amp;，
                                //param类型也是const int&amp;

f(27);                          //27是右值，所以T是int，
                                //param类型就是int&amp;&amp;
</code></pre>
<p>item24 详细解释了为什么这些例子是像这样发生的。这里关键在于通用引用的类型推导规则是不同于普通的左值或者右值引用的。尤其是，当通用引用被使用时，类型推导会区分左值实参和右值实参，但是对非通用引用时不会区分。</p>
<h3 id="情况3-paramtype既非指针也非引用"><a class="anchor" href="#情况3-paramtype既非指针也非引用">#</a> 情况 3： ParamType 既非指针，也非引用</h3>
<p>当 <code>ParamType</code>  既非引用也非指针时，我们面对的就是所谓的按值传递了，这意味着无论传入的是什么，param 都会是它的一个副本，即一个全新的对象。具体来说：</p>
<ol>
<li>和之前一样，如果 <code>expr</code>  的类型是一个引用，忽略这个引用部分</li>
<li>如果忽略 <code>expr</code>  的引用性之后，如果 <code>expr</code>  具有 <code>const</code>  或 <code>volatile</code>  属性，都会被忽略。</li>
</ol>
<p>例如：</p>
<pre><code class="language-c++">int x=27;                       //如之前一样
const int cx=x;                 //如之前一样
const int &amp; rx=cx;              //如之前一样

f(x);                           //T和param的类型都是int
f(cx);                          //T和param的类型都是int
f(rx);                          //T和param的类型都是int

</code></pre>
<p>这是因为根据按值传递的思想， <code>expr</code>  是 const 或者 volatile 不意为着它的拷贝也不能被修改。</p>
<p>认识到只有在传值给形参时才会忽略 <code>const</code> （和 <code>volatile</code> ）这一点很重要，正如我们看到的，对于 reference-to- <code>const</code>  和 pointer-to- <code>const</code>  形参来说， <code>expr</code>  的常量性在推导时会被保留。但是考虑这样的情况， <code>expr</code>  是一个 <code>const</code>  指针，指向 <code>const</code>  对象， <code>expr</code>  通过传值传递给 <code>param</code> ：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 仍然以传值的方式处理 param</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span>         <span class="token comment">//ptr 是一个常量指针，指向常量对象 </span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">"Fun with pointers"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 传递 const char * const 类型的实参</span></pre></td></tr></table></figure><p>在这里，解引用符号（*）的右边的 <code>const</code>  表示 <code>ptr</code>  本身是一个 <code>const</code> ： <code>ptr</code>  不能被修改为指向其它地址，也不能被设置为 null（解引用符号左边的 <code>const</code>  表示 <code>ptr</code>  指向一个字符串，这个字符串是 <code>const</code> ，因此字符串不能被修改）。当 <code>ptr</code>  作为实参传给 <code>f</code> ，组成这个指针的每一比特都被拷贝进 <code>param</code> 。像这种情况， <code>ptr</code> <strong> 自身的值会被传给形参</strong>，根据类型推导的第三条规则， <code>ptr</code>  自身的常量性将会被省略，所以 <code>param</code>  是 <code>const char*</code> ，也就是一个可变指针指向 <code>const</code>  字符串。在类型推导中，这个指针指向的数据的常量性将会被保留，但是当拷贝 <code>ptr</code>  来创造一个新指针 <code>param</code>  时， <code>ptr</code>  自身的常量性将会被忽略。</p>
<h4 id="数组实参与函数实参"><a class="anchor" href="#数组实参与函数实参">#</a> 数组实参与函数实参</h4>
<p>在模板类型推导过程中，数组或函数类型的实参会退化成对应的指针，除非它们被用来初始化引用</p>
<h3 id="item2-理解auto类型推导"><a class="anchor" href="#item2-理解auto类型推导">#</a> item2 理解 auto 类型推导</h3>
<p>继续使用上一节的这个例子来解释 auto 类型推导是如何和模板类型推导联系在一起的：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParmaType param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 使用一些表达式调用 f</span></pre></td></tr></table></figure><p>当变量采用 auto 来声明时，auto 扮演了模板中 T 的角色，变量的类型饰词扮演了 ParamType 的角色。</p>
<p>比如说：</p>
<pre><code class="language-c++">auto x = 27;	//类型饰词是auto
const auto cx = x;	//类型饰词是const auto
const auto&amp; rx = x;	//类型饰词是const auto &amp;
</code></pre>
<p>在这里例子中要推导 x，cx 和 rx 的类型，编译器的行为看起来就像是认为这里每个声明都有一个模板，然后使用合适的初始化表达式进行调用：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 x 的类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                                <span class="token comment">//param 的推导类型是 x 的类型</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 cx 的类型</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_cx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">func_for_cx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                                <span class="token comment">//param 的推导类型是 cx 的类型</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>            <span class="token comment">// 概念化的模板用来推导 rx 的类型</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">func_for_rx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">func_for_rx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 概念化调用：</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                                <span class="token comment">//param 的推导类型是 rx 的类型</span></pre></td></tr></table></figure><p>除了一个例外，就是使用初始化列表时。</p>
<p>例如：</p>
<pre><code class="language-c++">auto x = &#123; 11, 23, 9 &#125;;         //x的类型是std::initializer_list&lt;int&gt;

template&lt;typename T&gt;            //带有与x的声明等价的
void f(T param);                //形参声明的模板

f(&#123; 11, 23, 9 &#125;);               //错误！不能推导出T

</code></pre>
<p>C++\14 中允许 <code>auto</code>  用户函数返回值，也允许 lambda 函数的形参声明中使用 <code>auto</code> , 但在这些情况下 <code>auto</code>  实际上使用模板类型推导那一套规则在工作，因此下面的代码不会通过编译：</p>
<pre><code class="language-c++">auto createInitList()
&#123;
    return &#123; 1, 2, 3 &#125;;         //错误！不能推导&#123; 1, 2, 3 &#125;的类型
&#125;

std::vector&lt;int&gt; v;
…
auto resetV = 
    [&amp;v](const auto&amp; newValue)&#123; v = newValue; &#125;;        //C++14
…
resetV(&#123; 1, 2, 3 &#125;);            //错误！不能推导&#123; 1, 2, 3 &#125;的类型

</code></pre>
<p>总结：</p>
<ul>
<li>在一般情况下，auto 类型推导和模板类型推导是一模一样的，但是 auto 类型推导会假定用大括号扩起的初始化表达式代表一个 std::initializer_list, 但模板类型推导不会。</li>
<li>在函数返回值或 lambda 的形参中使用 auto，意思是使用模板类型推导规则而不是 auto 类型推导规则。</li>
</ul>
<h3 id="item3-理解decltype"><a class="anchor" href="#item3-理解decltype">#</a> item3 理解 decltype</h3>
<p>打了一大段但是忘保存了:😢, 不过相信作者的总结已经够用了。</p>
<blockquote>
<p>总结：</p>
<ul>
<li>绝大多数情况下，decltype 会得出变量或表达式的类型而不作任何修改。</li>
<li>对于类型为 T 的左值表达式，除非改表达式仅有一个名字，decltype 总是得出类型 T&amp;</li>
<li>C++14 支持 decltype (auto), 和 auto 一样，它会从其初始化表达式出发来推导类型，但是它的类型推导使用的是 decltype 的规则。</li>
</ul>
</blockquote>
<h3 id="item4-掌握查看类型推导结果的方法"><a class="anchor" href="#item4-掌握查看类型推导结果的方法">#</a> item4 掌握查看类型推导结果的方法</h3>
<p>比较推荐的方法：使用 IDE 编辑器直接查看，或者使用编译器诊断信息， 而作者提到的第三种方法，使用运行时输出方法的正确性和易读性方面都有缺陷。</p>
<p>对于使用编译器诊断信息这种方法，一个很好的方法是使用一个没有定义的类模板：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">// 只声明 TD (Type Displayer) 而不定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">TD</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>只要试图具现该模板，就会诱发一个错误信息，原因是找不到具现模板所需要的定义，如果想查看 x 和 y 的类型，用 x 和 y 的类型去具现 TD 即可：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span> xType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span> yType<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样，编译器就可能会给出这样的信息：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>error<span class="token operator">:</span> aggregate <span class="token char">'TD&lt;int> xType'</span> has incomplete type <span class="token operator">and</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>        cannot be defined</pre></td></tr><tr><td data-num="3"></td><td><pre>error<span class="token operator">:</span> aggregate <span class="token char">'TD&lt;const int *> yType'</span> has incomplete type <span class="token operator">and</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        cannot be defined</pre></td></tr></table></figure><p><strong>当然，即使有一些工具，理解 C++ 的类型推导规则也是很必要的。</strong></p>
<h2 id="chapter2-auto"><a class="anchor" href="#chapter2-auto">#</a> chapter2 auto</h2>
<p>从概念上来说， <code>auto</code>  要多简单有多简单，但是细究起来里面却大有文章。使用 <code>auto</code>  可以少打一些字，没错，但好处不止这些：它还能阻止那些由于手动指定类型带来的潜在错误和性能问题。还有，某些 <code>auto</code>  类型推导结果尽管是按部就班地符合标准规定的推导算法，然而从程序员的视角来看却是错误的。如果是这样的情况，那就很有必要知道如何去引导 <code>auto</code>  得出正确结果，因为退回手工指定类型的声明，是通常需要避免的途径。</p>
<p>这个小小的章节讨论了有关 <code>auto</code>  的一切。</p>
<h3 id="item5-优先选用auto而非显示类型声明"><a class="anchor" href="#item5-优先选用auto而非显示类型声明">#</a> item5 优先选用 <code>auto</code> , 而非显示类型声明</h3>
<p>使用 <code>auto</code>  的好处有无数条，但是它几乎唯一的一个缺点却难以说服一些人使用 <code>auto</code> ，即 <code>auto</code>  为代码可维护性和可读性的坏影响。但是，相比于全篇使用或根本不用，了解作者提到的一些优点，适当地使用 <code>auto</code> , 我认为是很有必要的。</p>
<ul>
<li>
<p><code>auto</code>  要求变量在定义的时候提供初始化，这能减少错误并提升性能。</p>
</li>
<li>
<p>在使用 <code>auto</code>  声明迭代器类型或者 lambda 表达式这种复杂类型的时候，能减轻很多负担</p>
</li>
<li>
<p>使用 <code>auto</code>  能减少一些隐式类型转换带来的问题，因为 programer 有时显式使用的类型与表达式实际类型并不完全相等。</p>
</li>
</ul>
<p>前两点易于理解，对于第三点，考虑下面这段代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>…</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    …                                   <span class="token comment">// 用 p 做一些事</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看起来合情合理，但是暗藏隐患。对于 <code>std::unordered_map</code>  来说，它的键值部分是 const，所以哈希表中的 <code>std::pair</code>  的类型并不是 <code>std::pair&lt;std::string,int&gt;</code> , 而是 std::pair&lt;const std::string,int&gt;。可是在上面的循环中，用来声明 <code>p</code>  的类型却不是这个。因此编译器就会想要使用某种方法把 <code>std::pair&lt;const std::string,int&gt;</code>  对象转换成 <code>std::pair&lt;std::string, int&gt;</code>  对象。这一步是可以成功的，方法是对 <code>m</code>  中的每个对象都做一次复制操作，形成一个 <code>p</code>  想要绑定的类型的临时对象，然后把 <code>p</code>  这个引用绑定到该临时对象。并且在循环的每次迭代结束时，该临时对象都会被析构一次，这之间带来的开销与使用 <code>const auto&amp;</code>  相比来说可太大了。</p>
<h3 id="item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom"><a class="anchor" href="#item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom">#</a> item6 auto 推导不符合要求时，使用显式类型初始化惯用法 (explicitly typed initializer idiom)</h3>
<p><code>auto</code>  在大多数情况下都很好用，但在遇到一些 &quot;代理&quot; 类型的时候，可能会带来意料之外的错误。</p>
<p>一个常见的例子是遇到 <code>vector&lt;bool&gt;</code>  的时候，对其它的 vector 容器，operator [] 通常会返回一个引用类型，可是 <code>vector&lt;bool&gt;</code>  不一样，它会返回一个 <code>std::vector&lt;bool&gt;::reference</code>  类型，原因是由于 bool 类型实际上通过 1bit 就可以表示， <code>vector&lt;bool&gt;</code>  为了节省空间，会对 bool 类型压缩为 1bit 来表示。但是这和 <code>vector&lt;bool&gt;</code>  不返回一个 <code>bool&amp;</code>  有什么关系呢，原因是，C++ 禁止返回对一个比特的引用，因此 <code>vector&lt;bool&gt;</code>  的 <code>operator[]</code>  不得不返回一个 <code>std::vector&lt;bool&gt;::reference</code>  对象，然后为了让它在使用其它所有 <code>bool&amp;</code>  的地方保证它能用，让其支持向 <code>bool</code>  类型隐式类型转换（虽然实际更复杂）。</p>
<p>嗯，但是既然 <code>std::vector&lt;bool&gt;::reference</code>  支持向 <code>bool</code>  类型的隐式转换了，那么 <code>auto</code>  将一个表达式推导为 <code>std::vector&lt;bool&gt;::reference</code>  或者 <code>bool</code>  类型又有什么关系呢？在下面的例子中，可能会引发问题：</p>
<p>假如我有一个函数，参数为 <code>Widget</code> ，返回一个 <code>std::vector&lt;bool&gt;</code> ，这里的 <code>bool</code>  表示 <code>Widget</code>  是否提供一个独有的特性。更进一步假设第 5 个<em> bit</em> 表示 <code>Widget</code>  是否具有高优先级，我们可以写这样的代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//w 高优先级吗？</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">processWidget</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>highPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 未定义行为！</span></pre></td></tr></table></figure><p>通过上面的讲述，我们知道这里的 <code>auto</code>  会将 <code>highPriority</code>  推导为 <code>std::vector&lt;bool&gt;::reference</code>  类型，并用一个<strong>临时的</strong> <code>vector&lt;bool&gt;</code>  类型的 <code>opertor[]</code>  返回的对象来初始化它。问题是， <code>std::vector&lt;bool&gt;::reference</code>  对象中可能包含一个指针，并指向一个机器字 (word), 该机器字中含有实际上被压缩的那个 1bit 的 <code>bool</code> 。但是随着临时 <code>vector&lt;bool&gt;</code>  对象的析构，这个指针指向的地方马上就会被析构，因此 <code>highPriority</code>  中也会包含一个野指针！对它的使用自然也会包含未定义行为了。</p>
<p>综上，程序员应该避免写出这样的代码:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> someVar <span class="token operator">=</span> expression of <span class="token string">"invisible"</span> proxy <span class="token keyword">class</span> <span class="token class-name">type</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这里， <code>auto</code>  本身并不是一个问题，而是其没有推导出想要的类型，一个解决方案是使用<strong>显式类型初始化惯用法</strong>，在上面那个例子中，可以这样操作：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>但是，这与下面这样的代码有何不同，况且还更简单：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>优势是，通过使用 static_cast&lt;bool&gt;，<strong>显式的指明了这里发生了一次类型转换</strong>，而让事情更加显而易见了。</p>
<p>总结：</p>
<ul>
<li>不可见的代理类可能会使 <code>auto</code>  从表达式中推导出 “错误的” 类型</li>
<li>显式类型初始化惯用法强制 <code>auto</code>  推导出你想要的结果</li>
</ul>
<h2 id="chapter3-转向现代c"><a class="anchor" href="#chapter3-转向现代c">#</a> chapter3 转向现代 C++</h2>
<h3 id="item7-在创建对象时注意区分和"><a class="anchor" href="#item7-在创建对象时注意区分和">#</a> item7 在创建对象时注意区分 () 和 {}</h3>
<p>总结：</p>
<ul>
<li>大括号初始化可以应用的语境最为广泛，可以阻止内建类型之间进行隐式窄化类型转换 (如 double 转 int)，还可以对最令人烦恼的解析语法免疫 (使用小括号初始化的时候要注意，C++ 会优先将表达式解释为声明，比如 <code>Widget w3();</code>  是一个函数声明)</li>
<li>在构造函数重载匹配期间，只要有任何可能，大括号初始化就会与带有 <code>std::initializer_list</code>  类型的形参相匹配，即使其他重载版本有这更加匹配的形参表</li>
<li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 <code>std::vector</code>  对象。</li>
<li>在模板内容进行对象创建时，到底应该使用小括号还是大括号是需要仔细考虑的。</li>
</ul>
<h3 id="item8-优先使用nullptr而非0或null"><a class="anchor" href="#item8-优先使用nullptr而非0或null">#</a> item8 优先使用 nullptr, 而非 0 或 NULL</h3>
<p>优先使用 nullptr 的主要原因是，0 和 NULL 实际上是一个整型，并非指针，这在重载了支持整型和指针类型参数的函数中有时会引起问题。</p>
<p>其次是在模板推导的时候，0 和 NULL 会被推导为 int 类型。</p>
<h3 id="item9-优先选用别名声明而非typedef"><a class="anchor" href="#item9-优先选用别名声明而非typedef">#</a> item9 优先选用别名声明，而非 typedef</h3>
<p>优先选用别名声明的主要优势在于别名声明可以模板化，而 <code>typedef</code>  不行。为了达到相同效果，C++98 程序员不得不使用嵌套在模板的 struct 中的 typedef。比如下面两个分别使用别名声明和 <code>typedef</code>  来达到相同效果的例子：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span>      <span class="token comment">// client </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">MyAllocList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token double-colon punctuation">::</span>type lw<span class="token punctuation">;</span> <span class="token comment">// client</span></pre></td></tr></table></figure><p>另一个优点是使用模板可以让人免写 &quot;::type&quot; 后缀，并且在模板内，对于内嵌 <code>typedef</code>  的使用经常要求加上 <code>typename</code>  前缀 (见 Effective C++ 对于依赖模板类型的说明)。</p>
<h3 id="item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型"><a class="anchor" href="#item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型">#</a> item10 优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3>
<p>总结：</p>
<ul>
<li>C++98 风格的枚举类型，现在称为不限范围的枚举类型。</li>
<li>限定作用域的枚举类型仅在枚举类型内可见。它们只能通过强制类型转换以转换至其他类型。</li>
<li>限定作用域的枚举类型和不限范围的枚举类型都支持底层类型指定。限定作用域的枚举类型的默认底层类型是 <code>int</code> , 而不限范围的枚举类型没有默认底层类型。</li>
<li>限定作用域的枚举类型总是可以进行前置声明，而不限范围的枚举类型却只有在指定了默认底层类型的前提下才可以进行前置声明。</li>
</ul>
<h3 id="item11-优先选用删除函数而非private未定义函数"><a class="anchor" href="#item11-优先选用删除函数而非private未定义函数">#</a> item11 优先选用删除函数，而非 <code>private</code>  未定义函数</h3>
<ul>
<li>优先选用删除函数，而非 <code>private</code>  未定义函数</li>
<li>任何函数都可以删除，包括非成员函数和模板具现。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ 读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作</title>
    <url>/2022/10/01/Git%E5%AD%A6%E4%B9%A001-%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="git学习01-基本操作"><a class="anchor" href="#git学习01-基本操作">#</a> Git 学习 01- 基本操作</h1>
<p><span id="more"></span></p>
<p><img data-src="%E4%B8%89%E5%8F%B6.jpg" alt="三叶"></p>
<h2 id="创建版本库"><a class="anchor" href="#创建版本库">#</a> 创建版本库</h2>
<p>版本库 (repository) 是一个目录，这个目录里的所有文件都可以被 Git 管理起来，每个文件的修改、删除、Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。</p>
<p>创建版本库步骤：</p>
<ol>
<li>选择一个合适地方，创建一个空目录</li>
<li>通过  <code>git init</code>  命令把这个目录变成 Git 可以管理的仓库</li>
</ol>
<h2 id="把文件添加到版本库"><a class="anchor" href="#把文件添加到版本库">#</a> 把文件添加到版本库</h2>
<p>把一个文件放到仓库只需要两步（如添加一个 readme.txt 文件）：</p>
<ol>
<li>
<p><code>git add readme.txt</code>   用命令 git add 告诉 Git， 把文件添加到暂存区。可反复多次使用，添加多个文件。</p>
</li>
<li>
<p><code>git commit -m &quot;wrote a readme file&quot;</code></p>
<p>git commit 告诉 Git, 把文件提交到仓库。-m 后面输入的是本次提交的说明，注意说明一定要有意义，如告诉仓库本次提交做了什么事，方便后续的版本控制。</p>
</li>
</ol>
<h2 id="查看工作区状态"><a class="anchor" href="#查看工作区状态">#</a> 查看工作区状态</h2>
<p>要查看当前工作区的状态，使用  <code>git status</code>  命令</p>
<p>如果有文件被修改过，你又想知道修改了什么 用 <code>git diff filename</code>  查看修改的内容。git diff 命令可以告诉你当前工作区的文件和仓库的有什么不同。</p>
<h2 id="版本回退"><a class="anchor" href="#版本回退">#</a> 版本回退</h2>
<ul>
<li><code>HEAD</code>  指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code> 。版号只要前几位就行了，只要能识别，也可以用 HEAD 和 ^ 表示回退到哪一版。</li>
<li>穿梭前，用 <code>git log</code>  可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>重返过去时未来的记录用 git log 就看不到了。要重返未来，用 <code>git reflog</code>  查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h2 id="撤销修改"><a class="anchor" href="#撤销修改">#</a> 撤销修改</h2>
<ul>
<li>场景 1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- filename</code> 。</li>
<li>场景 2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;filename&gt;</code> ，就回到了场景 1，第二步按场景 1 操作。</li>
<li>场景 3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ul>
<h2 id="删除文件"><a class="anchor" href="#删除文件">#</a> 删除文件</h2>
<p>如果你在文件管理器中把某个文件删了，或者用 <code>rm</code>  命令删了</p>
<pre><code>$ rm test.txt
</code></pre>
<p>这个时候，Git 知道你删了文件，因此，工作区和版本库就不一致了。</p>
<p>现在有两种情况。</p>
<ol>
<li>
<p>确实要从版本库中删除该文件，那就用命令  <code>git rm</code>  删掉 并且 git commit</p>
<pre><code>$ git rm test.txt
$ git commit -m &quot;remove test.txt&quot;
</code></pre>
<p>tips：先手动删除文件，然后使用 git rm &lt;file&gt; 和 git add&lt;file &gt; 效果是一样的。</p>
</li>
<li>
<p>删除错了，要从版本库中把误删的文件恢复到最新版本。</p>
<pre><code>$ git checkout -- test.txt
</code></pre>
<p>git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原。</p>
</li>
</ol>
<h2 id="添加远程库"><a class="anchor" href="#添加远程库">#</a> 添加远程库</h2>
<p>远程库既可以充当本地仓库的备份，又可以让其他人通过该仓库来协作，可谓一举多得。</p>
<p>创建远程库并将本地与远程库连接。</p>
<p>步骤：</p>
<ol>
<li>
<p>登录 github 创建一个新的仓库，复制该仓库的 SSH</p>
</li>
<li>
<p>在本地仓库上运行</p>
<pre><code>$ git remote add origin git@github.com:maoding1/learngit.git
</code></pre>
<p>(后面的一大串是复制的 SSH) 使本地仓库与远程库连接。</p>
<p>git 会把远程库的名字默认设为 origin</p>
</li>
<li>
<p>把本地内容推送到远程库上</p>
<pre><code>$ git push -u origin master
</code></pre>
<p>-u 参数实际上设置了远程仓库的默认值（比如有多个远程仓库） 之后就可以简化 git pull 和 git push 的命令</p>
</li>
</ol>
<p>现在只要本地做了提交，就可以通过  <code>git push origin master</code>  把本地分支的修改推送到 github</p>
<p>tips：要删除远程库 可以用 <code>git remote rm &lt;name&gt;</code>  命令，但这只是解除了本地与远程的绑定关系，要真正删除远程库，需要登陆 github 手动删除。</p>
<h2 id="克隆远程仓库"><a class="anchor" href="#克隆远程仓库">#</a> 克隆远程仓库</h2>
<p>知道仓库的 SSH 后，通过 <code>git clone SSH</code>  命令克隆到本地</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习02-分支管理</title>
    <url>/2022/10/02/Git%E5%AD%A6%E4%B9%A002-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="git学习02-分支管理"><a class="anchor" href="#git学习02-分支管理">#</a> Git 学习 02 - 分支管理</h1>
<p><span id="more"></span></p>
<p><img data-src="%E8%BD%BB%E9%9F%B3%E5%B0%91%E5%A5%B3.jpg" alt="轻音少女"></p>
<h2 id="创建与合并分支"><a class="anchor" href="#创建与合并分支">#</a> 创建与合并分支</h2>
<p>查看分支 ：  <code>git branch</code></p>
<p>创建分支：  <code>git branch &lt;name&gt;</code></p>
<p>切换分支：  <code>git switch &lt;name&gt;</code></p>
<p>创建 + 切换分支:  <code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支 ：  <code>git merge &lt;name&gt;</code>  这里的 name 使某分支的 name</p>
<p>删除分支：  <code>git branch -d &lt;name&gt;</code></p>
<h2 id="解决冲突"><a class="anchor" href="#解决冲突">#</a> 解决冲突</h2>
<p>eg：当你创建了一个 feature1 分支 其在 master 分支上添加了一些内容并进行提交，此时切换会 master 分支并使用  <code>git merge feature1</code>  合并分支是不会有问题的（Git 会在底层移动 master 的指针到 feature1 上）。但如果你在 feature1 上修改了某个文件并提交，在切换会 master 分支后修改了同一份文件并提交，那么此时 git merge 就会报错了。</p>
<p>此时可以：</p>
<ol>
<li>使用 <code>git status</code>  查看冲突的文件（如果你改了很多，分不清哪里冲突了）</li>
<li>手动解决冲突</li>
<li>再提交</li>
<li>最后删除分支（如删除 feature1)</li>
</ol>
<p>使用</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
</code></pre>
<p>可以形象地查看分支的合并情况（Git 会生成一副图）</p>
<h2 id="分支管理策略"><a class="anchor" href="#分支管理策略">#</a> 分支管理策略</h2>
<p><code>git merge --no-ff -m &quot;commit message&quot; &lt;branch name&gt;</code></p>
<p>通常 ，合并分支时，Git 会用 Fast forward 模式（移动指针） ，这种模式下，删除分支后，会丢掉分支信息</p>
<p>如果要强制禁用 Fast forward 模式， Git 就会再 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p>
<p>--no--ff 参数表示禁用 Fast forward</p>
<h2 id="git的更多操作"><a class="anchor" href="#git的更多操作">#</a> git 的更多操作</h2>
<p>Git 还有许多高级功能。如暂时储存当前工作、多人协作、标签管理等。考虑到目前还接触不到 ，上述功能等需要使用了再来学习更新吧。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 学习</title>
    <url>/2022/10/23/Maven-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id><a class="anchor" href="#">#</a> </h1>
<h1 id="maven-学习"><a class="anchor" href="#maven-学习">#</a> Maven  学习</h1>
<p><span id="more"></span></p>
<p>​																<img data-src="rebecca.jpg" alt="芝士rebecca"></p>
<h2 id="maven简介"><a class="anchor" href="#maven简介">#</a> Maven 简介</h2>
<p>Maven 是 Apache 组织下一个比较著名的开源项目，主要服务于基于 java 平台的项目构建，依赖管理和项目信息管理。</p>
<p>类比做糖醋排骨，传统需要自己配置酱料，比如加入多少克糖，多少克水，多少克... 而现在只用去超市购买酱料包就好。Maven 项目省去了开发者去各大网站下载 jar 包并解决相互间复杂依赖关系的时间。除此之外，除了编写源代码，我们有相当一部分时间花在了编译，运行单元测试，生成文档，打包和部署等工作上，这就是构建。手工做这些工作的成本太高了，于是可以用软件的方法让这一系列工作完全自动化，使得繁琐的步骤能够自动完成，很快得到最终结果。</p>
<h3 id="项目构建工具"><a class="anchor" href="#项目构建工具">#</a> 项目构建工具</h3>
<p>Ant 构建： 2000 年左右出现的构建工具，当时是最流行的 java 构建工具，不过它的 XML 脚本编写格式让 XML 文件特别大。对工程构建过程中的过程控制特别好。</p>
<p>Maven 构建：项目对象模型，通过其描述信息来管理项目的构建，报告和文档的软件项目管理工具，填补了 Ant 的缺点。Maven 第一次支持了从网络上下载的功能。Maven 专注的是依赖管理，使用 java 编写。</p>
<p>Gradle：谷歌的御用 Android 管理工具</p>
<p>Ant 比较老，目前 Maven 使用较多</p>
<h2 id="maven的四大特性"><a class="anchor" href="#maven的四大特性">#</a> Maven 的四大特性</h2>
<h3 id="依赖管理系统"><a class="anchor" href="#依赖管理系统">#</a> 依赖管理系统</h3>
<p>Maven 为 java 世界引入了一个新的依赖管理系统 ——jar 包管理。jar 升级时修改配置文件即可。在 java 世界中，可以用 **<em>groupId</em> **   、<em><strong>artifactId</strong></em>   、<em><strong>version</strong></em> 组成的 Coordination（坐标）唯一标识一个依赖</p>
<p>eg：</p>
<figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span> javax.servlet <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> //当前Maven项目隶属的实际项目或公司名称（jar包所在仓库路径）</pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span> javax.servlet-api <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> //定义实际项目中的一个Maven模块/项目名</pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span> 3.1.0 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> //Maven项目当前所处的版本</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><h3 id="多模块构建"><a class="anchor" href="#多模块构建">#</a> 多模块构建</h3>
<p>可以将一个项目分解为多个模块。</p>
<p>在 Maven 中定义一个 parent POM 作为一组 module 的聚合 POM，在该 POM 中可以使用 &lt;modules&gt; 标签来定义一组子模块。parent POM 中的 build 配置和依赖配置都会继承给子 module。</p>
<h3 id="一致的项目结构"><a class="anchor" href="#一致的项目结构">#</a> 一致的项目结构</h3>
<p>Maven 理念： Convension over configuration (约定大于配置)。其制定了一套项目目录结构作为标准的 java 项目结构，解决不同 IDE 带来的文件目录不一致问题。</p>
<h3 id="一致的构建模型和插件机制"><a class="anchor" href="#一致的构建模型和插件机制">#</a> 一致的构建模型和插件机制</h3>
<figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>	......</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>引入插件</p>
<h2 id="maven项目结构"><a class="anchor" href="#maven项目结构">#</a> Maven 项目结构</h2>
<pre><code>- src
	- main                   ：程序功能代码
		- Java               ：java代码
		- resource           ：资源代码、配置代码
	- test                   ：测试代码
		- Java               ：单元测试java代码
		- resource           ：资源代码、配置代码
	- pom.xml                ：项目对象模型

</code></pre>
<p>不用 IDE 的话上述结构都需要手动创建</p>
<p>pom 中的标签具体作用可以参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9tYXZlbi9tYXZlbi1wb20uaHRtbA==">https://www.runoob.com/maven/maven-pom.html</span></p>
<h2 id="在idea中使用maven"><a class="anchor" href="#在idea中使用maven">#</a> 在 IDEA 中使用 Maven</h2>
<p>IDEA 中默认捆绑了 Maven 可以在设置里更改 Maven 有关的配置</p>
<p>创建 Maven 项目：文件 -&gt; 新建 -&gt; 项目 构建系统选 Maven（上述是常规 Maven 项目）</p>
<p>​										可以选择生成器中的 Maven 中的 Archetype 选择模板（如 quickstart）</p>
<h2 id="maven仓库"><a class="anchor" href="#maven仓库">#</a> Maven 仓库</h2>
<p>对于 Maven 来说，仓库只有两类： 本地仓库和远程仓库</p>
<p>Maven 根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在，则直接使用；如果本地没有，Maven 就回去远程仓库查找，再下载到本地仓库再使用。如果本地和远程都没有就会报错。</p>
<p>远程仓库分为 3 种：</p>
<ol>
<li>
<p>中央仓库：默认下载 jar 包的地方，在国外，包含了 2000 多个开源项目，每天接收 1 亿次以上的访问。</p>
</li>
<li>
<p>私服：一种特殊的远程仓库，它是架设在局域网内的仓库服务。私服代理广域网上的远程仓库，供局域网内的 Maven 用户使用。当 Maven 需要下载构件时，它去私服当中找，如果私服没有，则从外部远程仓库下载，并缓存在私服上，再为 maven 提供。此外，一些无法从外部仓库下载的构件也能从本地上传到私服提供局域网中其他人使用。（在公司或学校内网中自己写的构件就可以上传到私服让别人使用了） 私服优点： 节省自己的外网带宽、 加速 Maven 构建、部署第三方控件、提高稳定性、降低中央仓库的负荷</p>
</li>
<li>
<p>其他公共库</p>
<p>如阿里云仓库，国内地址下载比中央仓库快。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++读书笔记</title>
    <url>/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>C++ 是我最喜欢的一门语言，C++ programer 一直为其拥有的非同寻常的能力范围和表现力而自豪（当然如果能正确使用的话）。正如 Scott Meyers, 本书作者所言：学习一种编程语言的基础是一回事；学习如何用那种语言设计和实现高效率的程序完全是另外一回事。断断续续学习了两年的 C++ programing language, 我的追求从学会语言基础，逐渐变为追求更加高效，并同时具备高可扩展性和可维护性的编程。</p>
<p>Effetive C++ 是一本主要面向 C++  03 标准及之前的 C++ 编程过程中的一些编程 guidelines 的，自 C++  11 以来，C++ 不断推陈出新，关于一些场景作者提出的解决方案也许有了更好的替代方案。但作为一切的基础，以及一系列书目的开山之作（more Efective C++, Effective Modern C++)，此书仍然被许多人认为是 CPP programer 进阶的必看书目。此读书笔记仅供我自己查阅，提供简单的总结与感想，以从作者引人入胜但对于已经认真体会的读者而言无益的行文中走出 (TLDR)。并对书中的一些问题尝试使用 C++ 11 后的新特性解决。</p>
<p>我不想成为一个语言学家，阅读之后还需要更多的编程练习来巩固所学习的知识。</p>
<p><span id="more"></span></p>
<h2 id="一些基础的杂项"><a class="anchor" href="#一些基础的杂项">#</a> 一些基础的杂项</h2>
<h3 id="item1-将c视为-federation-of-languages语言联合体"><a class="anchor" href="#item1-将c视为-federation-of-languages语言联合体">#</a> item1 将 C++ 视为 federation of languages (语言联合体)</h3>
<p>将 C++ 从一门编程语言看作四门互相联系但有各自主体思想的子语言的结合体：</p>
<ul>
<li>C: 包括 built-in 数据结构，流程控制语句等，提供语法基础。</li>
<li>Object-Oriented C++：C++ 的面向对象部分，主要设计封装继承多态这三个方面</li>
<li>Template C++：泛型编程部分，对多数程序员少用但及其强大的 C++ 语言部分，提供包括 TMP (模板元编程) 这样的黑魔法。</li>
<li>STL：containers,iterators,algorithms,functions objects... 方便地使用大佬们提供的编程工具，优化编程体验，不用像 C 那样 array simulate everything 了。</li>
</ul>
<p>每一种子语言都有一套自己常用的编程理念，在不同的子语言下编程时，可能会要从不同的规则中进行转换（比如传值的方式）。</p>
<h3 id="item2-用consts-enums和inlines-取代defines"><a class="anchor" href="#item2-用consts-enums和inlines-取代defines">#</a> item2 用 consts, enums, 和 inlines 取代 #defines</h3>
<p><strong>#defines 无法提供包括作用域控制，类型检查等功能，因此能避免就避免。一般只在控制编译逻辑的时候配合 #ifdef/#ifndef 使用，比如根据某些宏修改一些 objects 的定义，而不要用在编程的逻辑中。</strong></p>
<ul>
<li>想使用 #defines 定义常量时 比如 <code>#define PI 3.1415926</code> ，使用 const 替代，以获取更好的编译器报错体验与类型检查</li>
<li>想使用 #defines 定义<strong>类属常量</strong>时，比如<strong>在类中</strong>定义 <code>static const int a = 5;</code>  这里涉及到了类属常量的初始化问题，简要来说，一些编译器禁止 static integral class constants（静态整型族类属常量）的 in-class specification 而不得不在类外使用 <code>const int MyClass::a = 5;</code>  这样的初始化方式。（ps： 都是很老的编译器了，在作者那个年代都算过时的了，gcc4.0.4 都可以在类中定义整型族常量）。对于静态非整型族类属常量，比如 <code>static const string s = &quot;hello&quot;</code> ，或者 <code>static const string s = nullptr</code>  这样的语句是不允许出现在类的定义中的。你必须要在类外初始化。for example:</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> cst <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// allowed</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">const</span> string s<span class="token punctuation">;</span> <span class="token comment">// static const string s = "hello"? not allowed</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token punctuation">;</span> <span class="token comment">// static const int* p = nullter? not allowed</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">const</span> string MyClass<span class="token double-colon punctuation">::</span>s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> MyClass<span class="token double-colon punctuation">::</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>这个过程体现了 C++ 令人难以忍受的缺陷，对于很多东西，它具有很多的特例，并且你很难理解为什么，没有什么规则是通用的</strong>。一个好消息是，C++ 17 后做出了补救 (又有新东西要记了)：</p>
<p>according to <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU2Mzg5Ny9ob3ctY2FuLXlvdS1kZWZpbmUtYS1zdGF0aWMtZGF0YS1tZW1iZXItb2YtdHlwZS1jb25zdC1zdGRzdHJpbmc=">c++ - How can you define a static data member of type const std::string? - Stack Overflow</span></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> cst <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> std<span class="token double-colon punctuation">::</span>string_view STRING <span class="token operator">=</span> <span class="token string">"some useful string constant"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>想使用 #defines 定义函数时，使用 inline 的模版函数替代，以获取函数参数具有的参数类型检查功能，并且拥有不输于 defines 的性能。还有，在使用 defines 定义函数时，你不得不给参数加括号 😃</li>
</ul>
<p>对了 忘了提 enums 了，这里作者使用了一个叫做 the enum hack 的技术，主要来源于一个 enumerated type（枚举类型）的值可以用在一个需要 ints 的地方。for example:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">GamePlayer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> NumTurns <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// "the enum hack" - makes</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                     <span class="token comment">// NumTurns a symbolic name for 5</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> scores<span class="token punctuation">[</span>NumTurns<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// fine</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>使用这项技术，你可以禁止对 NumTurns 的取地址行为，第二个理由是，大量的代码在使用它（作为模版元编程的基本技术之一），所以最好还是认识一下。</p>
<p><strong>by the way, 当你声明一个常量指针的时候，最好别忘了把这个指针也设为 const。</strong></p>
<h3 id="item3-只要可能就用const"><a class="anchor" href="#item3-只要可能就用const">#</a> item3 只要可能就用 const</h3>
<p>use <em>const</em> as long as possible, 经常看到的一句话了，但是看了这节后刷新了我的认知，这节内容主要分为三点：</p>
<ol>
<li>const 关键字提供了语义上的表达，有助于编译器发现错误。const 用途广泛，可用于对象，函数参数，返回类型，成员函数等。（这点为大部分程序员对此节标题的唯一理解）</li>
<li>编译器坚持的是<strong> bitwise constness</strong> (二进制位常量性), 但程序员应当使用<strong> conceptual constness</strong> (概念上的常量性) 来编程。</li>
<li>当 const 和 non-const 成员函数本质上具有相同的实现的时候，使用 non-const 版本调用 const 版本可以避免代码重复。</li>
</ol>
<p>关于第二点的理解：</p>
<p>二进制位常量性是指当你声明一个变量为 const 的时候，编译器只需要检查它在内存中存储的二进制位有没有被更改就行了，因为这样实现十分方便，比如当你声明一个指针为 const 时候，你不能改变指针的值，但是你可以改变指针指向的对象的值。但是当你声明一个类为 const 的时候，只能调用 const 成员函数，并且不能改变其任何成员变量，这实在是太苛刻了。</p>
<p>for example: 一个可以存储文本块长度的类：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  std<span class="token double-colon punctuation">::</span>size_t <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">char</span> <span class="token operator">*</span>pText<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  std<span class="token double-colon punctuation">::</span>size_t textLength<span class="token punctuation">;</span>             <span class="token comment">// last calculated length of textblock</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">bool</span> lengthIsValid<span class="token punctuation">;</span>                 <span class="token comment">// whether length is currently valid</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>std<span class="token double-colon punctuation">::</span>size_t <span class="token class-name">CTextBlock</span><span class="token double-colon punctuation">::</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lengthIsValid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    textLength <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>pText<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error! can't assign to textLength</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    lengthIsValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>             <span class="token comment">// and lengthIsValid in a const</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token punctuation">&#125;</span>                                   <span class="token comment">// member function</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">return</span> textLength<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于 length () 成员函数，由于语义的需要必须定义为 const。但不想每次都调用 strlen 计算文本长度，这会带来许多开销，于是便用上述方法存储字符串长度。但是这违反了二进制常量性，毕竟改变了成员变量。</p>
<p>因此引入了逻辑常量性的概念，这一理念认为，** 一个 const 成员函数可以改变对象中的一些 bits, 但是只能用客户无法察觉的方法。** 这种理念的实现是通过 mutable 关键字实现的，比如将上面的 textLength 和 lengthIsValid 变量用 mutable 修饰即可。</p>
<p>对于第三点的理解：</p>
<p>一般来说，类中重载的 const 成员函数和非 const 成员函数的逻辑都是差不多的，这带来了额外的编译时间，维护成本以及代码膨胀，这对于一些程序员来说是不可忍受的。因此可以使用这样一个 trick: 通过强制转型，让 non-const 成员函数调用 const 版本。for example:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token comment">// same as before</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t position<span class="token punctuation">)</span>         <span class="token comment">// now just calls const op[]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>                         <span class="token comment">// cast away const on</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                                                 <span class="token comment">// op[]'s return type;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> TextBlock<span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span>     <span class="token comment">// add const to *this's type;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>          <span class="token punctuation">[</span>position<span class="token punctuation">]</span>                             <span class="token comment">// call const version of op[]</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样的代码通过不了选美比赛 😄 ，但是它有效。</p>
<p><strong>注意，反过来让 const 版本调用 non-const 版本不可取，因为违反了 const 的语义，你将承受改变成员变量的风险。</strong></p>
<h3 id="item-4-确保对象在使用前被初始化"><a class="anchor" href="#item-4-确保对象在使用前被初始化">#</a> item 4 确保对象在使用前被初始化</h3>
<p>对于 C++ 的对象，当你不初始化它们时，有些时候它们会自动初始化，有时候不会，因此为了避免 ub，再声明的同时最好也初始化它们。</p>
<p>要点：</p>
<ul>
<li>
<p>手动初始化 built-in type 的 objects，因为 C++ 只在某些时候才会自己初始化它们</p>
</li>
<li>
<p>在 constructor 中，用 member initialization list 代替函数体中的 assignment。initialization list 中 data members 的排列顺序要与它们在 class（类）中被声明的顺序相同。因为在构造函数赋值之前，成员变量已经被默认初始化好了，这样做能提升性能。除此之外的是，有些时候，初始化列表式可选项，有时候是必选项，因此为了方便记忆，一律使用初始化列表即可。</p>
</li>
<li>
<p>通过用 local static objects（局部静态对象）代替 non-local static objects（非局部静态对象）来避免跨 translation units（编译单元）的 初始化顺序问题。</p>
</li>
</ul>
<p>即将在全局中定义一个 <code>static FileSystem fs; </code>  替换为提供一个函数，有点像单例模式：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>FileSystem<span class="token operator">&amp;</span> <span class="token function">tfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   <span class="token comment">// this replaces the tfs object; it could be</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>                                   <span class="token comment">// static in the FileSystem class</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">static</span> FileSystem fs<span class="token punctuation">;</span>             <span class="token comment">// define and initialize a local static object</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">return</span> fs<span class="token punctuation">;</span>                        <span class="token comment">// return a reference to it</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="构造-析构与赋值"><a class="anchor" href="#构造-析构与赋值">#</a> 构造、析构与赋值</h2>
<h3 id="item5-了解c为你默认编写并调用了哪些函数"><a class="anchor" href="#item5-了解c为你默认编写并调用了哪些函数">#</a> item5 了解 C++ 为你默认编写并调用了哪些函数</h3>
<ul>
<li>编译器可以隐式生成一个 class（类）的 default constructor（缺省构造函数），copy constructor（拷贝构造函数），copy assignment operator（拷贝赋值运算符）和 destructor（析构函数）。C++11 后还增加了移动构造和移动赋值。</li>
</ul>
<p><strong>对于以下场景：深拷贝，类中有 const 或引用成员变量，以及析构函数有 virtual 需求的时候，默认生成的函数可能不会符合要求</strong>。</p>
<h3 id="item6-若不想使用编译器生成函数就明确拒绝"><a class="anchor" href="#item6-若不想使用编译器生成函数就明确拒绝">#</a> item6 若不想使用编译器生成函数，就明确拒绝</h3>
<p>在 C++ 11 之前，作者是通过将相应的成员函数声明为 private 实现的，或者继承自一个使用这种方法实现的 Uncopyable 的基类。</p>
<p>C++ 11 之后，使用 <code>= delete</code>  即可</p>
<h3 id="item7-为多态基类声明虚析构函数"><a class="anchor" href="#item7-为多态基类声明虚析构函数">#</a> item7 为多态基类声明虚析构函数</h3>
<p>为了防止内存泄露，必须将多态基类的析构函数声明为虚函数</p>
<p>除此之外还要注意两点：</p>
<ul>
<li>普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价</li>
<li>如果一个类型没有被设计成多态基类，又有被误继承的风险，可以使用 C++ 11 中的 <code>final</code>  关键字，这样禁止派生可以防止误继承造成上述问题。</li>
</ul>
<h3 id="item8-防止异常逃离析构函数"><a class="anchor" href="#item8-防止异常逃离析构函数">#</a> item8 防止异常逃离析构函数</h3>
<p>两个要点：</p>
<ul>
<li>destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后<strong>抑制它们或者终止程序</strong>。这里的抑制指的是在 try catch 语句中捕获并处理。</li>
<li>如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。</li>
</ul>
<p>对于第二点，一个常见例子是使用各种 db 的连接池的场景，通常用户需要使用 db.close () 显式释放资源，对于拥有 RAII 机制的 C++ 来说，为什么还需要这样做呢。因为通过 db.close () 这样的普通成员函数，用户可以通过 try catch 语句自行对这个异常做出回应。在析构函数中，同样可以继续使用 RAII 机制，记录用户有无手动释放，没有则自行调用 db.close ()</p>
<h3 id="item9-避免在构造函数或者析构函数中调用虚函数"><a class="anchor" href="#item9-避免在构造函数或者析构函数中调用虚函数">#</a> item9 避免在构造函数或者析构函数中调用虚函数</h3>
<p>简单来说，在构造和析构的时候，对象的类型是不确定的，因此想要调用的虚函数可能不会如你所愿。可以这样理解，再析构和构造函数中虚函数表的构造和析构的时机是不确定的，因此调用虚函数会存在问题。</p>
<p>这点看似简单，却十分容易踩坑，考虑以下场景，为了避免重复代码，我们可能将不同的变量初始化放到一个 init () 函数之中，即使这个函数不是虚函数，但如果其中调用了虚函数，还是违背了这一原则，并且以难以察觉的方式。</p>
<h3 id="item10-在赋值运算符中返回一个reference-to-this"><a class="anchor" href="#item10-在赋值运算符中返回一个reference-to-this">#</a> item10 在赋值运算符中返回一个 reference to *this</h3>
<p>简单来说 这样做是为了支持链式赋值并让自己的接口和内置类型的接口尽可能相似。因此，请将赋值操作符的返回类型设为 ObjectClass&amp; 并返回 * this。</p>
<h3 id="item11-在赋值运算符中处理自赋值"><a class="anchor" href="#item11-在赋值运算符中处理自赋值">#</a> item11 在赋值运算符中处理自赋值</h3>
<p>当给一个对象赋值时，一般来说，这个对象需要释放现有资源，然后通过赋值获取新资源，这个逻辑在处理自我赋值的时候会失效，因为释放的资源可能永远找不到了。</p>
<p>解决这个问题的一个方案是，通过特判处理自赋值情况，很简单也常见的一种思路如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>SomeClass<span class="token operator">&amp;</span> SomeClass<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SomeClass<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>	</pre></td></tr><tr><td data-num="4"></td><td><pre>  ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">DataBlock</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 如果此处抛出异常，ptr 将指向一块已经被删除的内存。</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>首先这种方案的一个问题是：当释放已有资源后，获取新资源的过程可能发生异常，此时指针会指向被释放的资源，导致后续程序出错。</p>
<p>解决的思路也很简单，即先获取新的资源，然后再释放原有的资源：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>SomeClass<span class="token operator">&amp;</span> SomeClass<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SomeClass<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  DataBlock<span class="token operator">*</span> pOrg <span class="token operator">=</span> ptr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">DataBlock</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 如果此处抛出异常，ptr 仍然指向之前的内存。</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">delete</span> pOrg<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>同样，这种方案也不用特判是否是自赋值语句了，还有一点好处是，通过减少 if 语句，可能会对指令流水线的工作有益。</p>
<p>还有一种方案是使用 copy-and-swap 方法，不过本人感觉性能可能会稍低，因此不作讨论。</p>
<h3 id="item12-拷贝一个对象的所有组成成分"><a class="anchor" href="#item12-拷贝一个对象的所有组成成分">#</a> item12 拷贝一个对象的所有组成成分</h3>
<p>即时刻注意以下三点：</p>
<ul>
<li>为类增加成员时，别忘了更改拷贝相关的函数中的逻辑</li>
<li><mark>在继承的场景下，子类需要并且必须通过调用父类的拷贝构造或拷贝赋值来进行父类成员的拷贝。</mark></li>
<li>拷贝构造和拷贝赋值不能互相调用，如果想减少代码重复，就将通用功能放入一个第三方的函数中。</li>
</ul>
<h2 id="资源管理"><a class="anchor" href="#资源管理">#</a> 资源管理</h2>
<h3 id="item13-使用对象管理资源"><a class="anchor" href="#item13-使用对象管理资源">#</a> item13 使用对象管理资源</h3>
<p>经典的 RAII 思想，即利用析构函数退出作用域自动调用的特点处理资源的释放。</p>
<p>C++11 后有了智能指针，因此 RAII 的实践已经很简单了。没想到那时候的智能指针已经存在于 tr1 库里了😄</p>
<h3 id="item14-谨慎考虑资源管理类的拷贝行为"><a class="anchor" href="#item14-谨慎考虑资源管理类的拷贝行为">#</a> item14 谨慎考虑资源管理类的拷贝行为</h3>
<p>即需要考虑在不同情况下是否要禁止或以其他方式控制对资源的拷贝。</p>
<p>C++11 后有了 shared_ptr 和 unique_ptr 后，应该能应付各种场景了。</p>
<h3 id="item15-在资源管理类中准备访问裸资源raw-resources"><a class="anchor" href="#item15-在资源管理类中准备访问裸资源raw-resources">#</a> item15 在资源管理类中准备访问裸资源（raw resources）</h3>
<p>在智能指针中，可以发现，它们提供了 get () 方法获取保管的资源。为什么？</p>
<p>因为很多 API 的参数中，是和资源本身打交道的，因此一个 RAII 资源管理类需要提供访问裸资源的接口。</p>
<p>一个疑问是，这样是否违反了封装性？答案是不会，因为 RAII 只是为了保证资源释放这个行为的发生，封装不是其存在的目的。同时，如果你提供隐式转换，可能会导致一些预期之外的错误，因此资源管理类仅提供显示转换是最合理的。</p>
<h3 id="item16-使用相同形式的new和delete"><a class="anchor" href="#item16-使用相同形式的new和delete">#</a> item16 使用相同形式的 new 和 delete</h3>
<p>即 new 和 delete，new [] 和 delete [] 搭配使用</p>
<h3 id="item17-在一个独立的语句中将new出来的对象存入智能指针"><a class="anchor" href="#item17-在一个独立的语句中将new出来的对象存入智能指针">#</a> item17 在一个独立的语句中将 new 出来的对象存入智能指针</h3>
<p>此条是为了防止非常微妙的内存泄漏，这种 bug 发生概率很小，但一旦出现很难被解决。</p>
<p>对于这样的两个函数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>share_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> sp<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>一个简洁的调用方法是：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">processWidget</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">share_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>但这个语句的一大特点是，可能变为这样的执行顺序：</p>
<ol>
<li>
<p>执行 &quot;new Widget&quot;。</p>
</li>
<li>
<p>调用 priority。</p>
</li>
<li>
<p>调用 shared_ptr 的构造函数。</p>
</li>
</ol>
<p>当在第二点中发生了异常，第一点的 new Widget () 构造的类可能就会发生内存泄漏。</p>
<p>避免类似问题的方法很简单：用一个单独的语句创建 Widget 并将它存入一个智能指针，然后将这个智能指针传递给 processWidget</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// store newed object</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                                      <span class="token comment">// in a smart pointer in a</span></pre></td></tr><tr><td data-num="3"></td><td><pre>									  <span class="token comment">// standalone statement</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">processWidget</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// this call won't leak</span></pre></td></tr></table></figure><p>这样做是因为编译器在不同的语句之间重新安排操作顺序的活动余地比在一个语句之内要小得多</p>
<h2 id="设计与声明"><a class="anchor" href="#设计与声明">#</a> 设计与声明</h2>
<h3 id="item18-让接口容易被正确使用"><a class="anchor" href="#item18-让接口容易被正确使用">#</a> item18 让接口容易被正确使用</h3>
<p>本条款讨论如何<strong>帮助你的客户在使用你的接口时避免他们犯错误</strong>。</p>
<p>在设计接口时，我们常常会错误地假设，接口的调用者<strong>拥有某些必要的知识来规避一些常识性的错误</strong>。但事实上，接口的调用者并不总是像正在设计接口的我们一样 “聪明” 或者知道接口实现的” 内幕信息 “，结果就是，我们错误的假设使接口表现得不稳定。这些不稳定因素可能是由于调用者缺乏某些先验知识，也有可能仅仅是代码上的粗心错误。接口的调用者可能是别人，也可能是未来的你。所以一个合理的接口，应该尽可能的从<strong>语法层面</strong>并在<strong>编译之时运行之前</strong>，帮助接口的调用者规避可能的风险。</p>
<ul>
<li>使用<strong>外覆类型（wrapper）<strong>提醒调用者传参错误检查，将参数的附加条件限制在</strong>类型本身</strong></li>
</ul>
<p>当调用者试图传入数字 “13” 来表达一个 “月份” 的时候，你可以在函数内部做运行期的检查，然后提出报警或一个异常，但这样的做法更像是一种责任转嫁 —— 调用者只有在尝试过后才发现自己手残把 “12” 写成了 “13”。如果在设计参数类型时就把 “月份” 这一类型抽象出来，比如使用 enum class（强枚举类型），就能帮助客户在编译时期就发现问题，把参数的附加条件限制在类型本身，可以让接口更易用。</p>
<ul>
<li>从<strong>语法层面</strong>限制调用者<strong>不能做的事</strong></li>
</ul>
<p>接口的调用者往往无意甚至没有意识到自己犯了个错误，所以接口的设计者必须在语法层面做出限制。一个比较常见的限制是加上 <code>const</code> ，比如在 <code>operate*</code>  的返回类型上加上 <code>const</code>  修饰，可以防止无意错误的赋值 <code>if (a * b = c)</code> 。</p>
<ul>
<li>接口应表现出与内置类型的一致性</li>
</ul>
<p>让自己的类型和内置类型的一致性，比如自定义容器的接口在命名上和 STL 应具备一致性，可以有效防止调用者犯错误。或者你有两个对象相乘的需求，那么你最好重载 <code>operator*</code>  而并非设计名为”multiply” 的成员函数。</p>
<ul>
<li>从语法层面限制调用者<strong>必须做的事</strong></li>
</ul>
<p><strong>别让接口的调用者总是记得做某些事情</strong>，接口的设计者应在假定他们<strong>总是忘记</strong>这些条条框框的前提下设计接口。比如用智能指针代替原生指针就是为调用者着想的好例子。如果一个核心方法需要在使用前后设置和恢复环境（比如获取锁和归还锁），更好的做法是将设置和恢复环境设置成纯虚函数并要求调用者继承该抽象类，强制他们去实现。在核心方法前后对设置和恢复环境的调用，则应由接口设计者操心。</p>
<p><strong>当方法的调用者（我们的客户）责任越少，他们可能犯的错误也就越少。</strong></p>
<h3 id="item19-将class的设计当成设计一个type"><a class="anchor" href="#item19-将class的设计当成设计一个type">#</a> item19 将 class 的设计当成设计一个 type</h3>
<p>本条款提醒我们设计 class 需要考虑的问题：</p>
<ul>
<li>对象该如何创建销毁：包括构造函数、析构函数以及 new 和 delete 操作符的重构需求。</li>
<li>对象的初始化与赋值行为应有何区别。</li>
<li>对象被拷贝时应考虑的行为：拷贝构造函数。</li>
<li>对象的合法值是什么？在成员函数内部对参数做合法性检查。</li>
<li>新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题。</li>
<li>新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非 explicit 函数之间的取舍。</li>
<li>新类型是否需要重载操作符。</li>
<li>什么样的接口应当暴露在外，而什么样的接口应当封装在内（public 和 private）</li>
<li>新类型的效率、资源获取归还、线程安全性和异常安全性如何保证。</li>
<li>这个类是否具备 template 的潜质，如果有的话，就应改为模板类。</li>
</ul>
<h3 id="item20-尽量使用pass-by-reference-to-const替换pass-by-value"><a class="anchor" href="#item20-尽量使用pass-by-reference-to-const替换pass-by-value">#</a> item20 尽量使用 pass-by-reference-to-const 替换 pass-by-value</h3>
<p>值传参的问题有：</p>
<ul>
<li>按值传参涉及大量参数的复制，这些副本大多是没有必要的。</li>
<li>如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。</li>
<li><strong>对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。</strong></li>
<li>小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。</li>
</ul>
<p>尽管如此，面对内置类型和 STL 的迭代器与函数对象，我们通常还是会选择按值传参的方式设计接口。因为，对于内置类型和迭代器，它们往往很小，值传递开销低，有时甚至胜过引用。至于函数对象，值传递主要解决多线程中的同步问题。</p>
<h3 id="item21-必须返回对象时切忌返回reference"><a class="anchor" href="#item21-必须返回对象时切忌返回reference">#</a> item21 必须返回对象时，切忌返回 reference</h3>
<p>主要是一些程序员妄想减少拷贝的开销，而试图将函数的返回值设为引用，而导致对象析构后还试图调用引发错误。</p>
<p>C++ 11 之后，通过 std::move () 和移动构造函数即可解决这个问题。</p>
<h3 id="item22-将成员变量声明为private"><a class="anchor" href="#item22-将成员变量声明为private">#</a> item22 将成员变量声明为 private</h3>
<p>结论：** 请对 class 内所有成员变量声明为 <code>private</code> ， <code>private</code>  意味着对变量的封装。** 作者提供了更有价值的信息在于不同的属性控制 —— <code>public</code> , <code> private</code>  和 <code>protected</code> ——<strong> 代表的设计思想</strong>。</p>
<p>简单的来说，把所有成员变量声明为 private 的好处有两点。首先，所有的变量都是 private 了，那么所有的 public 和 protected 成员都是函数了，用户在使用的时候也就无需区分，这就是<strong>语法一致性</strong>；其次，对变量的封装意味着，<strong>可以尽量减小因类型内部改变造成的类外外代码的必要改动。增加可维护性</strong>。</p>
<p>作者还提出了一个观点，对 <code>private</code>  来说 ** <code>public</code>  和 <code>protected</code>  属性在一定程度上是等价的 **。一个自定义类型被设计出来就是供客户使用的，那么客户的使用方法无非是两种 ——<strong> 用这个类创建对象</strong>或者<strong>继承这个类以设计新的类</strong> —— 以下简称为第一类客户和第二类客户。那么从封装的角度来说，一个 <code>public</code>  的成员说明了<strong>类的作者决定对类的第一种客户不封装此成员</strong>，而一个 <code>protected</code>  的成员说明了<strong>类的作者对类的第二种客户不封装此成员</strong>。也就是说，当我们把类的两种客户一视同仁了以后， <code>public</code> 、 <code>protected</code>  和 <code>private</code>  三者反应的即类设计者对类成员封装特性的不同思路 —— 对成员封装还是不封装，如果不封装是对第一类客户不封装还是对第二类客户不封装。</p>
<p>有意思的是 Java 就删除了 protected 继承，因为这个功能太鸡肋了吧，至少在 C++ 中我还没有见到过使用 protected 的例子。</p>
<h3 id="item23-用非成员非友元函数取代成员函数"><a class="anchor" href="#item23-用非成员非友元函数取代成员函数">#</a> item23 用非成员非友元函数取代成员函数</h3>
<p>用非成员非友元函数取代成员函数，<strong>可以提高封装性与可扩展性</strong></p>
<p>比如对一个浏览器清除 cookie，cache 和 history 的函数，到底是应该选择 choice1:  <code>WebBrowzer.clearEverything()</code>  这样一个接口，还是应该选择 choice2:  <code>clearBrowser(WebBrowser &amp;wb)</code>  呢，注意 WebBrowzer 类已经提供了基本的清除 cookie,cache 和 history 的接口，如下所示：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">clearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">clearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">removeCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>为了方便用户，提供两种清除数据接口的选择如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">&#123;</span>						<span class="token comment">//choice 1: 成员函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">clearEverything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// calls clearCache, clearHistory,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                                        <span class="token comment">// and removeCookies</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">clearBrowser</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span>		<span class="token comment">//choice 2: 非成员非友元函数</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  wb<span class="token punctuation">.</span><span class="token function">clearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  wb<span class="token punctuation">.</span><span class="token function">clearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  wb<span class="token punctuation">.</span><span class="token function">removeCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><ins class="primary">如何提高封装性:</ins></p>
<p>可以使用这样一个标准来衡量类的封装性，即可以<mark>直接访问</mark>类的 private 部分的函数的数量，这个数量越多，类的封装性就越差。从这点来看，应该选择使用 choice2。</p>
<p><ins class="primary">如何提高可扩展性:</ins></p>
<p>个人认为，这一点更具有说服力。假设将类的成员函数分为两类：直接访问 private 部分的成员函数，如 <code>clearCache() clearHistory()</code>  等与间接访问 private 部分的成员函数，如这里的 <code>clearEverything()</code> 。很明显，第二种成员函数的<mark>设计目标是为了方便程序员的操作</mark>，因为即使没有第二种函数，程序员也可以通过调用第一种函数来达到目的。</p>
<p>既然如此，为何不更方便一点呢，要实现这一点，需要配合 C++ 的 namespace 功能来实现。</p>
<p>假设我们采用 choice1, 即使用更多的成员函数，类的定义会变得冗长，并且当我们更改某些 “方便” 成员函数的时候，使用这个类定义的所有编译单元都必须重新编译。解决这个问题的一个例子是 C++ 的 std 命名空间，比如 vector,string 等 std 命名空间提供的功能，分散在不同的源文件和头文件中，当你需要使用 vector 时，你无需 include string 相关的头文件。可以说，string 相关代码对你当前的代码没有影响。</p>
<p>假设 webBrowser 类得到了扩展，需要提供书签，打印，清除数据这三个功能，完全可以使用一个 <code>namespace WebBrowserStuff</code>  并在不同的三个头文件和源文件中分别定义这三个功能相关的 &quot;方便&quot; 函数。假设某个源文件只需要类的打印功能，它不需要 include 其它的头文件，除了打印相关的其它头文件与源文件的更改也不会影响这个源文件的编译。</p>
<p><ins class="dot">简单来说： 我们通过将一个类的相关功能函数拆的四分五裂，达到了更高的灵活性与可扩展性。</ins></p>
<h3 id="item24-当类型转换应该用于所有参数时声明为非成员函数"><a class="anchor" href="#item24-当类型转换应该用于所有参数时声明为非成员函数">#</a> item24 当类型转换应该用于所有参数时，声明为非成员函数</h3>
<p>一个简单的例子即可说明：</p>
<p>考虑一个可以接受单个 int 类型构造的 Rational 类，如果在类中重载 operator* ，可以与另一个 Rational 类使用 * 运算符做乘法。这样的做法允许使用 <code>rational * 2</code>  而不允许使用 <code>2 * rational</code>  这样的语句，这往往不是程序员所期望的。即<mark>如果一个操作符是成员函数，那么它的第一个操作数 (调用对象) 不会发生隐式类型转换。</mark></p>
<p>因此如果想允许像从 2 到 rational 对象这样的隐式类型转换，应该将 operator * 的重载放在类外。</p>
<p>by the way, 如果想要禁止对某些类型的隐式类型转换，可以使用 C++ 11 之后的  <code>explicit</code>  关键字</p>
<h3 id="item25-考虑支持不抛异常的-swap"><a class="anchor" href="#item25-考虑支持不抛异常的-swap">#</a> item25 : 考虑支持不抛异常的 swap</h3>
<p>此节内容非常精彩，深深体现了 C++ 语言的魅力，或者在反 C++ 程序员眼中无法忍受的特点：<strong>为了极致的性能提升而大大增加的程序复杂性与给程序员带来的思想负担，即使这个性能提升有时并不明显</strong>。一个简单的 swap 函数，竟然涉及了这么多的知识：模板类、完全特化与非完全特化、std 命名空间的扩充限制、命名空间与目标函数搜索规则、注重异常安全的编程范式...</p>
<p>swap 是一个重要的函数，在本书中，它就作为异常安全编程 (exception-safe) 的基础 (item 29) 和一种实现自赋值的通用机制 (item 11) 被提及。</p>
<p>作为一切的基础，先看看 std::swap 是如何实现的：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> std <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>          <span class="token comment">// 与常见的实现相同</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>         </pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    T <span class="token function">temp</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    a <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    b <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到一点：只要我们的类型支持拷贝，std::swap 就能完成它的工作。</p>
<p>缺点是：它太慢了，特别是对于成员变量含有指针的函数，它带来了三次拷贝，并且是不必要的。</p>
<p>考虑这样一个类 Widget（体现了 pointer to implemention 设计思想的一组类），即它的主要成员是一个 WidgetImpl, 它长这样：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">WidgetImpl</span> <span class="token punctuation">&#123;</span>                          <span class="token comment">// class for Widget data;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span>                                     <span class="token comment">// details are unimportant</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>                              <span class="token comment">// possibly lots of data —</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> v<span class="token punctuation">;</span>                    <span class="token comment">// expensive to copy!</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                              <span class="token comment">// class using the pimpl idiom</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>  Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>      <span class="token comment">// to copy a Widget, copy its</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token punctuation">&#123;</span>                                         <span class="token comment">// WidgetImpl object. For</span></pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                      <span class="token comment">// details on implementing</span></pre></td></tr><tr><td data-num="18"></td><td><pre>   <span class="token operator">*</span>pImpl <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// operator= in general,</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                      <span class="token comment">// see Items 10, 11, and 12.</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  WidgetImpl <span class="token operator">*</span>pImpl<span class="token punctuation">;</span>                         <span class="token comment">// ptr to object with this</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>考虑使用 std::swap 的开销：<strong>它不仅要拷贝三个 Widgets，而且还有三个 WidgetImpl 对象，而实际上只需要交换它们的指针就可以了</strong></p>
<p>一个自然的想法是，我们提供 std::swap 的一个特化版本，如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> std <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>                            </pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> a<span class="token punctuation">,</span>         <span class="token comment">// 对 std::swap 特化 虽然还不能编译</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                    Widget<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>         </pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>pImpl<span class="token punctuation">,</span> b<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 只用交换指针就行</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span>                                     </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>不能通过编译的原因是，访问了 Widget 类中 private 部分的指针。解决这一问题也很简单：要么声明这个特化为 Widget 类的友元，要么让 Widget 提供一个成员函数 swap 作为接口，并让这个特化去调用它。根据 STL 中容器的选择：这里让 Widget 声明一个名为 swap 的 public 成员函数去做实际的交换，然后特化 std::swap 去调用那个成员函数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                    </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span>                           </pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> other<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>                                    </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>      </pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span>                                </pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">namespace</span> std <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>                       <span class="token comment">// revised specialization of</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> a<span class="token punctuation">,</span>     <span class="token comment">// std::swap</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    Widget<span class="token operator">&amp;</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// to swap Widgets, call their</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token punctuation">&#125;</span>                                <span class="token comment">// swap member function</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>到此问题告一段落，除非我们让问题变得更复杂一些：假设 Widget 和 WidgetImpl 是类模板，而不是类呢，比如说我们参数化存储在 WidgetImpl 中的数据类型：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">WidgetImpl</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以很自然的在刚才的基础上写出这样一段代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> std <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">></span></span></span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span>      <span class="token comment">// error! illegal code!</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                        Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#123;</span> a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但是，它通过不了编译。理由是：这是一个试图对函数进行部分特化 (partial specialization) 的代码，<strong>而与允许对类进行部分特化相反的是，C++ 不允许对函数进行部分特化</strong>。这是由于函数重载完全可以达到函数部分特化的目的，所以 C++ 索性禁止了函数部分特化。正确使用重载来达到目的的代码是：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> std <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>             <span class="token comment">// an overloading of std::swap</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span>          <span class="token comment">// (note the lack of "&lt;...>" after</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span>          <span class="token comment">// "swap"), but see below for</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#123;</span> a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>                   <span class="token comment">// why this isn't valid code</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在通常情况下，上面的代码已经足够达成目的了，但是很遗憾，这又触发了 C++ 的另一条红线，因为我们试图为 C++ 的 std 命名空间添加新成员，而这一做法是 ub 的。<mark>根据<span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2V4dGVuZGluZ19zdGQ="> Extending the namespace std - cppreference.com</span>C++ 禁止对 std 命名空间进行扩充，除非你试图为一个用户定义类型而对 std 空间里的原有成员添加一个完全特化。一个解释是：用户在扩充 std 命名空间后，如果下一个版本的 C++ 添加了一个与用户命名相同的新成员，就会发生命名冲突，从而导致用户之前的代码不再可用。</mark></p>
<p>作者使用的方法是，将上面的代码原封不动地从 std 中挪到 Widget 类所在的命名空间：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> WidgetStuff <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// templatized WidgetImpl, etc.</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                    <span class="token comment">// as before, including the swap</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                   <span class="token comment">// member function</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                    <span class="token comment">// non-member swap function;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span>                 <span class="token comment">// not part of the std namespace</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span>                                         </pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在，从 client 视角来看我们的程序，</p>
<p>假设你写了一个函数模板来交换两个对象的值：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> obj1<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> obj2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">swap</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>哪一个 swap 应该被调用呢？std 中的通用版本，你知道它必定存在；std 中的通用版本的特化，可能存在，也可能不存在；T 专用版本，可能存在，也可能不存在，可能在一个 namespace 中，也可能不在一个 namespace 中（但是肯定不在 std 中）。究竟该调用哪一个呢？如果 T 专用版本存在，你希望调用它，如果它不存在，就回过头来调用 std 中的通用版本。如下这样就可以符合你的希望：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> obj1<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> obj2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>           <span class="token comment">// make std::swap available in this function</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">swap</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// call the best swap for objects of type T</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当编译器看到这个 swap 调用，他会寻找正确的 swap 版本来调用。<mark>C++ 的名字查找规则 (参见<span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2FkbA=="> Argument-dependent lookup - cppreference.com</span>) 确保能找到在全局 namespace 或者与 T 同一个 namespace 中的 T 专用的 swap。（例如，如果 T 是 namespace WidgetStuff 中的 Widget，编译器会利用参数依赖查找（argument-dependent lookup）找到 WidgetStuff 中的 swap。）如果 T 专用 swap 不存在，编译器将使用 std 中的 swap，这归功于此函数中的 using declaration 使 std::swap 在此可见。尽管如此，相对于通用模板，编译器还是更喜欢 T 专用的 std::swap 的特化，所以如果 std::swap 对 T 进行了特化，则特化的版本会被使用。</mark></p>
<p>本节总结：</p>
<ul>
<li>如果 std::swap 对于你的类型来说是低效的，请提供一个 swap 成员函数。并确保你的 swap 不会抛出异常。</li>
<li>如果你提供一个成员 swap，请同时提供一个调用成员 swap 的非成员 swap。对于类（非模板），还要特化 std::swap。</li>
<li>调用 swap 时，请为 std::swap 使用一个 using declaration，然后在调用 swap 时不使用任何 namespace 限定条件。</li>
<li>为用户定义类型完全地特化 std 模板没有什么问题，但是绝不要试图往 std 中加入任何全新的东西。</li>
</ul>
<p>也许还遗留了一个问题，如本节标题所言：绝不要让 swap 的成员版本抛出异常，这是因为 swap 的非常重要的应用之一是为类（以及类模板）提供强大的异常安全（exception-safety）保证 (参见 item 29)。swap 的缺省版本基于拷贝构造和拷贝赋值，如果这两个函数仅涉及内建类型，那么一切 ok，因为可以默认对内建类型的操作绝不会抛出异常。否则的话，可能涉及用户类型的拷贝，而我们为了高效的交换，此时应当提供一个更高效的 swap 版本，使用指针类型的交换来避免缺省拷贝函数的这一缺点，这时又正好解决了可能抛出异常的问题。</p>
<h2 id="编程实践"><a class="anchor" href="#编程实践">#</a> 编程实践</h2>
<h3 id="item26-只要有可能就推迟变量定义"><a class="anchor" href="#item26-只要有可能就推迟变量定义">#</a> item26 只要有可能就推迟变量定义</h3>
<p>优点：</p>
<ul>
<li>增加程序可读性</li>
<li>避免变量的定义和真正使用离得太远，使得中间出现 return 或抛出异常等情况而导致变量白白构造和析构。</li>
</ul>
<h3 id="item27-将强制转型转到最少"><a class="anchor" href="#item27-将强制转型转到最少">#</a> item27 将强制转型转到最少</h3>
<p>如果强制转型使用太多，很可能代码的设计就有问题。</p>
<ul>
<li>避免强制转型的滥用，特别是在性能敏感的代码中应用 dynamic_casts，如果一个设计需要强制转型，设法开发一个没有强制转型的侯选方案。</li>
<li>如果必须要强制转型，设法将它隐藏在一个函数中。客户可以用调用那个函数来代替在他们自己的代码中加入强制转型。</li>
<li>尽量用 C++ 风格的强制转型 (四种 cast) 替换 C 风格的强制转型。它们更容易被注意到，而且他们做的事情也更加明确。</li>
</ul>
<h3 id="item28-避免返回对象内部构件的句柄引用指针或迭代器"><a class="anchor" href="#item28-避免返回对象内部构件的句柄引用指针或迭代器">#</a> item28 避免返回对象内部构件的句柄（引用，指针，或迭代器）</h3>
<p>由于编译器的二进制常量性 (item3)，将成员函数声明为 const 有时仍然会破坏封装性，比如返回内部私有成员的指针或引用等，如果不得不这样做，应该同时将成员函数的返回值设为 const。</p>
<h3 id="item29-争取异常安全exception-safe的代码"><a class="anchor" href="#item29-争取异常安全exception-safe的代码">#</a> item29  争取异常安全（exception-safe）的代码</h3>
<p>根据作者的定义，一个异常安全函数抛出异常时，应当：</p>
<ol>
<li>没有资源泄露</li>
<li>不允许数据结构恶化，即对相关的变量使用不应该发生未定义或错误的行为。</li>
</ol>
<p>for example:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">PrettyMenu</span><span class="token double-colon punctuation">::</span><span class="token function">changeBackground</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream<span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// acquire mutex (as in Item 14)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">delete</span> bgImage<span class="token punctuation">;</span>                    <span class="token comment">// get rid of old background</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span>                    <span class="token comment">// update image change count</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  bgImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token type-opencl-host-cpp keyword">Image</span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// install new background</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// release mutex</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这是一个对一个菜单对象背景图片更换的函数，当 new 操作符抛出异常时，mutex 对象并没有被释放，并且 bgImage 指针指向一个被删除的对象，分别违反了第一条和第二条原则，因此这个函数不是异常安全的。</p>
<p>达到第一条原则有一个十分简单且通用的方法，就是利用 C++ 的 RAII 机制 (item 13)：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">PrettyMenu</span><span class="token double-colon punctuation">::</span><span class="token function">changeBackground</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream<span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  Lock <span class="token function">ml</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                 	<span class="token comment">// 异常抛出时会触发 Lock 类的析构</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">delete</span> bgImage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  bgImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token type-opencl-host-cpp keyword">Image</span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接着处理数据结构恶化问题，作者认为，异常安全对这一问题需要提供以下三种不同级别的保证之一：</p>
<ul>
<li>函数提供基本保证（the basic guarantee），允诺如果一个异常被抛出，程序中剩下的每一件东西都处于合法状态。没有对象或数据结构被破坏，而且所有的对象都处于内部调和状态（所有的类不变量都被满足）。即：<strong>抛出异常后，程序的一部分状态可能被改变，但仍处于合法状态，不至于影响程序继续运行，或者程序员有办法捕捉这些改变并做出应对。</strong></li>
<li>函数提供强力保证（the strong guarantee），即如果一个异常被抛出，程序的状态就像它们从没有被调用过一样。</li>
<li>函数提供不抛出保证（the nothrow guarantee），允诺决不抛出异常，对内建类型的操作一般都是 nothrow 的，这是异常安全代码中必不可少的基础构件。</li>
</ul>
<p>** 对于 programmer 来说，他们提供的函数应当尽量达到最高级别的保证。** 一般来说，程序员提供的函数只要不包含内建类型，基本就只能提供强力保证了。</p>
<p>接下来是一个提供强力保证的通用策略：copy-and-swap，这常常配合 pimpl 原则 (pointer to implementation) 使用，它的步骤一般是这样的：</p>
<ol>
<li>将每一个对象中的全部数据从 “真正的” 对象中放入到一个单独的实现对象中，然后将一个指向实现对象的指针交给真正对象。(pimpl)</li>
<li>做出一个你要改变的对象的拷贝，然后在这个拷贝上做出全部所需的改变。如果改变过程中的某些操作抛出了异常，最初的对象保持不变。在所有的改变完全成功之后，将被改变的对象和最初的对象在一个<strong>不会抛出异常</strong>的操作中进行交换。(copy-and-swap)</li>
</ol>
<p>对于 PrettyMenu 的 changeBackground 函数来说，可以这样写：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">PrettyMenu</span><span class="token double-colon punctuation">::</span><span class="token function">changeBackground</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream<span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>                            <span class="token comment">// see Item 25</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  Lock <span class="token function">ml</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// acquire the mutex</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  std<span class="token double-colon punctuation">::</span>tr1<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>PMImpl<span class="token operator">></span>                <span class="token comment">//copy obj. data，PMImpl 是一个包含所有数据的工具类。</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">pNew</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">PMImpl</span><span class="token punctuation">(</span><span class="token operator">*</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  pNew<span class="token operator">-></span>bgImage<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token type-opencl-host-cpp keyword">Image</span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// modify the copy</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token operator">++</span>pNew<span class="token operator">-></span>imageChanges<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> pNew<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// swap the new</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                                              <span class="token comment">// data into place</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="item30-理解-inline-化的介入和排除"><a class="anchor" href="#item30-理解-inline-化的介入和排除">#</a> item30 理解 inline 化的介入和排除</h3>
<ol>
<li>正确理解 inline： inline 只是对于编译器的请求，最终函数是否 inline 取决于编译器。</li>
<li>正确使用 inline：
<ul>
<li>正确评估 inline 的效果：inline 一般只适用于小的，频繁调用的函数上，这种函数编译后的机器指令最好小于一个函数调用产生的机器指令。一个较大的函数 inline 化会带来代码膨胀，导致附加的分页调度，减少指令缓存命中率，以及随之而来的性能损失。</li>
<li>对于头文件中函数的 inline 慎重，因为 inline 函数展开的特性，与头文件与实现相分离的模式相比，使用 inline 函数的 clients 必须在 inline 函数更改后进行重新编译。</li>
</ul>
</li>
</ol>
<h3 id="item-31-最小化文件之间的编译依赖"><a class="anchor" href="#item-31-最小化文件之间的编译依赖">#</a> item 31 最小化文件之间的编译依赖</h3>
<p>为了尽量减小更改一个实现所引起的链式反应，需要掌握最小化编译依赖的精髓：只要能实现，就让你的头文件独立自主，如果不能，就依赖其它文件中的声明，而不是定义。其它每一件事都从这个简单的设计策略产生。所以：</p>
<ol>
<li>
<p>当对象的引用和指针可以做到时就避免使用对象。仅需一个类型的声明，你就可以定义到这个类型的引用或指针。而定义一个类型的对象必须要存在这个类型的定义。因为指针和引用的大小是固定的，而对象的大小不固定，在编译时需要知道对象具体大小的场景时不适用。</p>
</li>
<li>
<p>用对类声明的依赖替代对类定义的依赖。声明一个使用一个类的函数时绝对不需要有这个类的定义，即使这个函数通过传值方式传递或返回这个类</p>
<p>比如</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>                        <span class="token comment">// class declaration</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>Date <span class="token function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// fine — no definition</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">clearAppointments</span><span class="token punctuation">(</span>Date d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// of Date is needed</span></pre></td></tr></table></figure></li>
<li>
<p>为声明和定义分别提供头文件。为了便于坚持上面的指导方针，头文件需要成对出现：一个用于声明，另一个用于定义。当然，这些文件必须保持一致。如果一个声明在一个地方被改变了，它必须在两处都被改变。得出的结果是：库的客户应该总是 #include 一个声明文件，而不是自己前向声明某些东西，而库的作者应该提供两个头文件。例如，想要声明 today 和 clearAppointments 的 Date 的客户不应该像前面展示的那样手动前向声明 Date。更合适的是，它应该 #include 适当的用于声明的头文件：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"datefwd.h"</span>            <span class="token comment">// header file declaring (but not</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>                               <span class="token comment">// defining) class Date</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Date <span class="token function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// as before</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">clearAppointments</span><span class="token punctuation">(</span>Date d<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li>
</ol>
<p>基于以上想法的两个方法是 Handle 类和 Interface 类，Handle 类和 Interface 类从实现中分离出接口。</p>
<p>Handle 类采用 pimpl 思想，将所有的操作都交给内部指针指向的对象来做，缺点是可能需要提供更多的文件。</p>
<p>Interface 类利用纯虚函数的思想，类似 Java Interface 的使用，需要提供方法来制作具体的实体类。</p>
<h2 id="面向对象设计"><a class="anchor" href="#面向对象设计">#</a> 面向对象设计</h2>
<h3 id="item-32-确保-public-inheritance-模拟-is-a"><a class="anchor" href="#item-32-确保-public-inheritance-模拟-is-a">#</a> item 32 确保 public inheritance 模拟 &quot;is-a&quot;</h3>
<p>不同于 private 继承的一点是，public 继承体系中，子类将拥有父类提供的所有 public 接口。即 public inheritance 意味着 &quot;is-a&quot;。适用于 base classes 的每一件事也适用于 derived classes，因为每一个 derived class object 都是一个 base class object。</p>
<p>其实这是设计模式六大原则中 “里氏替换原则” 的 C++ 实践，里氏替换原则指出：应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换。一个经典的反例是一个 public 继承自长方形类的正方形类，正方形类不能像长方形那样随意地改变长度与宽度，即 setLength () 和 setWidth () 接口在正方形类的使用中会出现麻烦，因此正方形类不应该 public 继承自长方形类。</p>
<h3 id="item33-避免覆盖通过继承得到的名称"><a class="anchor" href="#item33-避免覆盖通过继承得到的名称">#</a> item33  避免覆盖 “通过继承得到的名称”</h3>
<p>在子类中，只要声明了一个与父类同名的函数，比如 <code>foo()</code> ，那么父类中所有的<strong>同名函数</strong>都会变得不可见，不管是 <code>foo()</code>  还是 <code>foo(int)</code>  还是 <code>foo() const</code> ,<strong> 作用域级别的遮盖是和参数类型以及是否虚函数无关的</strong>，这可能有些违反直觉，作者的解释是这是为了防止 programmer 在从某个库或者某个框架中创建一个派生类时，在不知情的情况下从遥远的某个 base classes 中继承了同名的其它函数 (over loads) 的情况。不幸的是，一般情况下 programmer 是需要继承这些 overloads 的。在这种情况下如何绕过 C++ 对 “通过继承得到的名字” 的缺省的覆盖机制呢。</p>
<p>一种方法是使用 using declarations, 这将使父类的所有同名函数可见:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>mf1<span class="token punctuation">;</span>       <span class="token comment">// make all things in Base named mf1 and mf3</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>mf3<span class="token punctuation">;</span>       <span class="token comment">// visible (and public) in Derived's scope</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>还有一种情况是，只想让 base classes 的某个同名函数可见（这是不应该发生在 public 继承中的，否则将违反 item32），这种时候应当使用一个简单的 forwarding function:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   <span class="token comment">// forwarding function; implicitly</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#123;</span> <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>                     <span class="token comment">// inline (see Item 30)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>Derived d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">// fine, calls Derived::mf1</span></pre></td></tr><tr><td data-num="14"></td><td><pre>d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">// error! Base::mf1() is hidden</span></pre></td></tr></table></figure><p>总结：</p>
<ul>
<li>derived classes 中的名字会覆盖 base classes 中的名字，在 public 继承中 中，这不应当发生。</li>
<li>为了使隐藏的 name 重新可见，使用 using declarations 或者 forwarding functions（转调函数）。</li>
</ul>
<h3 id="item-34-区分-inheritance-of-interface接口继承和-inheritance-of-implementation实现继承"><a class="anchor" href="#item-34-区分-inheritance-of-interface接口继承和-inheritance-of-implementation实现继承">#</a> item 34 区分 inheritance of interface（接口继承）和 inheritance of implementation（实现继承）</h3>
<p>继承的情况可以分为三种：</p>
<ol>
<li>继承了一个纯虚函数（Pure virtual functions）</li>
<li>继承了一个简单虚拟函数（Simple virtual functions)</li>
<li>继承了一个非虚拟函数 （Non-virtual functions)</li>
</ol>
<p>什么时候该选哪种方式呢？作者提供了这三种继承方式的语义，以供选择的时候参考</p>
<ol>
<li>纯虚函数指定<strong>仅有接口被继承</strong></li>
<li>简单虚拟函数指定 接口继承加上 <strong>缺省实现继承</strong></li>
<li>非虚拟函数指定接口继承加上<strong>强制实现继承</strong>，参见 item32 对于非虚拟函数一般来说不能重写它。</li>
</ol>
<h3 id="item35-考虑可选的虚函数的替代方法"><a class="anchor" href="#item35-考虑可选的虚函数的替代方法">#</a> item35 考虑可选的虚函数的替代方法</h3>
<p>虚函数简单易懂又功能强大，无脑的使用虚函数可以解决大部分问题，但是在一些特殊场景中，以下几个方法可能会更好。</p>
<ol>
<li>
<p>non-virtual interface (NVI) idiom（非虚拟接口惯用法），这个方法主张将虚函数声明为私有，然后通过非虚拟的 public 接口调用它。这个方法适合继承体系的各个方法包含相同的处理逻辑的时候，将不同的部分放在虚函数中，让虚函数专注于实现各个类不同的部分，然后在调用它的 public 接口中做一些通用的控制工作，for example：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>               <span class="token comment">// derived classes do not redefine</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#123;</span>                                     <span class="token comment">// this - see Item 36</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// do "before" stuff - see below</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// do the real work</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// do "after" stuff - see below</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> retVal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token comment">// derived classes may redefine this</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// default algorithm for calculating</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token punctuation">&#125;</span>                                     <span class="token comment">// character's health</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在调用虚拟的 doHeadthValue 方法之前和之后可以做一些处理。</p>
</li>
<li>
<p>使用作为成员变量的函数指针，一个策略模式的简单实现。</p>
</li>
<li>
<p>使用 std::function 对象，这样做的优点是 function 对象可以被多个不同类调用，更方便。</p>
</li>
</ol>
<h3 id="item36-绝不要重定义一个-inherited-non-virtual-function通过继承得到的非虚拟函数"><a class="anchor" href="#item36-绝不要重定义一个-inherited-non-virtual-function通过继承得到的非虚拟函数">#</a> item36 绝不要重定义一个 inherited non-virtual function（通过继承得到的非虚拟函数）</h3>
<p>可以参照 item32 与里式替换法则，在能使用父类的地方一定能够使用子类，而不会破坏程序的行为。同时，如果你的函数有多态调用的需求，一定记得把它设为虚函数，否则基类指针指向子类对象的时候是不会调用到子类重载过的函数的，很可能会出错。</p>
<h3 id="item37-绝不要重定义一个函数的-inherited-default-parameter-value通过继承得到的缺省参数值"><a class="anchor" href="#item37-绝不要重定义一个函数的-inherited-default-parameter-value通过继承得到的缺省参数值">#</a> item37 绝不要重定义一个函数的 inherited default parameter value（通过继承得到的缺省参数值）</h3>
<p>原因是缺省参数是静态绑定的，但是对于虚函数是动态绑定的，因此通过父类指针调用子类的虚函数的时候，会发生实现按照子类，但缺省参数按照父类的情况。同时同 item36，除了虚函数外，也希望子类的表现与父类相同。</p>
<h3 id="item38-通过-composition模拟-has-a或-is-implemented-in-terms-of是根据实现的"><a class="anchor" href="#item38-通过-composition模拟-has-a或-is-implemented-in-terms-of是根据实现的">#</a> item38 通过 composition 模拟 &quot;has-a&quot; 或 &quot;is-implemented-in-terms-of&quot;（是根据…… 实现的）</h3>
<p>使用复合代替继承是一个经典的设计思想，能提高程序运行的性能。假设 A 类拥有一个 B 类的成员变量，语义是 A 类是根据 B 类实现的，这很容易理解。</p>
<h3 id="item39-谨慎使用-private-inheritance私有继承"><a class="anchor" href="#item39-谨慎使用-private-inheritance私有继承">#</a> item39 谨慎使用 private inheritance（私有继承）</h3>
<p>我们知道，public 继承代表着 &quot;is a&quot; 关系，private 继承代表着 has a 或者说 &quot;是根据... 实现的&quot; 关系。因为 private 继承不会拥有与父类相同的接口，但是可以复用父类的所有接口与成员变量来对外提供新功能。</p>
<p>但是根据 item38，复合也拥有与私有继承同样的语义，那么如何在这两者中进行选择呢？结论是这样的：== 只要你能就用 composition（复合），只有在绝对必要的时候才用 private inheritance（私有继承）。== 这里绝对必要的情况主要是当 protected members 和虚函数参与进来的时候。比如说，当你要处理的两个 classes（类）不具有 is-a（是一个）的关系，而且其中的一个还需要访问另一个的 protected members（保护成员）或需要重定义一个或更多个它的 虚函数。甚至在这种情况下，我们也看到 public inheritance 和 containment 的混合使用通常也能产生你想要的行为，虽然有更大的设计复杂度。</p>
<p>两个原因：</p>
<ol>
<li>private 继承的子类如果还可能被新的类继承的时候，可能需要禁止当前类的虚函数被重载，作者使用了复杂的方法，但 C++ 11 后使用 final 关键字便可解决此问题，故此原因可忽略</li>
<li>item31 提到的最小化编译依赖的问题，复合可以只需要对象的声明，而继承必须看到对象的定义。</li>
</ol>
<h3 id="item40-谨慎使用多继承"><a class="anchor" href="#item40-谨慎使用多继承">#</a> item40 谨慎使用多继承</h3>
<p>能避免使用多继承就避免使用多继承，目前还没有看到过必须使用多继承的例子，java 删除了多继承貌似也没什么问题。</p>
<p>总结：</p>
<ul>
<li>多继承比 single inheritance 单继承更复杂。它能导致新的歧义问题（父类中拥有同名 members) 和对 virtual inheritance（虚继承）的需要。</li>
<li>virtual inheritance（虚继承）增加了 size 和 speed 成本，以及 initialization（初始化）和 assignment（赋值）的复杂度。当 virtual base classes（虚拟基类）没有数据时它是最适用的。</li>
<li>多继承有合理的用途。比如一种方案涉及组合从一个 Interface class（接口类）的公有继承和从一个有助于实现的 类的 私有继承。</li>
</ul>
<h2 id="模板"><a class="anchor" href="#模板">#</a> 模板</h2>
<p>这一章的内容值得反复阅读，行文环环相扣，实在是难以再浓缩了。</p>
<h3 id="item41-理解-implicit-interfaces隐式接口和-compile-time-polymorphism编译期多态"><a class="anchor" href="#item41-理解-implicit-interfaces隐式接口和-compile-time-polymorphism编译期多态">#</a> item41 理解 implicit interfaces（隐式接口）和 compile-time polymorphism（编译期多态）</h3>
<p>类和模版的一个共同特点是它们都支持接口和多态，区别是类支持显式接口和运行时多态（通过虚函数实现），而模版支持隐式接口和编译期多态。</p>
<p>运行时多态与编译器多态很好理解。显式接口的意思是，一个类提供了哪些接口，在它的类定义之中就能全部找到，所以是显式的。而对于模板来说，参数化的类需要提供的接口是基于合法表达式的，比如一个表达式 <code>if (templateClass.size() &gt; 10)</code> , 我们可以<strong>推测</strong>出这个参数化的类必须提供 templateClass 接口，所以说是隐式的。</p>
<h3 id="item42-理解-typename-的两个含义"><a class="anchor" href="#item42-理解-typename-的两个含义">#</a> item42 理解 typename 的两个含义</h3>
<p>第一个含义，用于模版声明中：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>                 <span class="token comment">// uses "class"</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>              <span class="token comment">// uses "typename"</span></pre></td></tr></table></figure><p>这里的 <code>typename</code>  和 <code>class</code>  在语法层面上没有什么不同，都用在声明一个模板类型参数的时候。但是，在惯例上，一般会使用 <code>typename</code> ，表示类型 T 不仅可以是一个类类型，也可以是其它类型，仅当模板类型参数仅接受用户定义类型的时候使用 class。</p>
<p>第二个含义，用 <code>typename</code>  去标识 nested dependent type names（嵌套依赖类型名）</p>
<p>这里设计两个概念：<strong>嵌套</strong>和<strong>依赖</strong>，for example，这个代码还不能通过编译，只是举例：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">C</span><span class="token operator">></span>                            <span class="token comment">// print 2nd element in</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span>               <span class="token comment">// container;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span>                                               <span class="token comment">// this is not valid C++!</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     C<span class="token double-colon punctuation">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get iterator to 1st element</span></pre></td></tr><tr><td data-num="6"></td><td><pre>     <span class="token operator">++</span>iter<span class="token punctuation">;</span>                                    <span class="token comment">// move iter to 2nd element</span></pre></td></tr><tr><td data-num="7"></td><td><pre>     <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>                         <span class="token comment">// copy that element to an int</span></pre></td></tr><tr><td data-num="8"></td><td><pre>     std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> value<span class="token punctuation">;</span>                        <span class="token comment">// print the int</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个函数中有两个局部变量， <code>iter</code>  和  <code>value</code> 。 <code>iter </code> 的类型是  <code>C::const_iterator</code> ，一个依赖于模板参数 C 的类型。一个 模板中的依赖于一个 模板参数的名字被称为 dependent names（依赖名字）。当一个 dependent names（依赖名字）嵌套在一个类的内部时，我称它为 nested dependent name（嵌套依赖名字）。C::const_iterator 是一个 nested dependent name（嵌套依赖名字）。实际上，它是一个 nested dependent type name（嵌套依赖类型名），也就是说，<strong>一个涉及到一个 type（类型）的 nested dependent name（嵌套依赖名字）</strong>。</p>
<p>print2nd 中的另一个 局部变量 <code>value</code>  具有 int 类型。int 是一个不依赖于任何模板参数的名字。这样的名字被称为 non-dependent names（非依赖名字）。</p>
<p>上面的这个代码错在 <code>C::const_iterator iter(container.begin());</code>  这一行，在这里，我们之所以觉得能够声明 <code>iter</code>  这个变量，是因为我们默认 C::const_iterator 是一个类型，也就是说 <code>iter</code>  的声明仅在 <code>C::const_iterator</code>  是一个类型时才有意义，但是在编译器看来这是不对的，编译器会认为 C::const_iterator 可能是 C 中的一个静态数据成员，因为编译器会考虑所有可能的输入，** 因此在 C 还不是已知的时候，它会假定嵌套依赖名字不是一个 type (类型)。** 因此为了声明 <code>iter</code>  变量，我们必须告诉编译器 <code> C::const_iterator</code>  是一个类型，我们将 <code>typename</code>  放在这个声明的前面来做到这一点。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">C</span><span class="token operator">></span>                           <span class="token comment">// this is valid C++</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">typename</span> <span class="token class-name">C</span><span class="token double-colon punctuation">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这就是 <code>typename</code>  的第二个含义， <code>typename </code> 前置于嵌套依赖类型名。但这一规则也有两个例外：</p>
<p><code>typename </code> 不必前置于在一个 list of base classes（基类列表）中的或者在一个 member initialization list（成员初始化列表）中作为一个 base classes identifier（基类标识符）的 nested dependent type name（嵌套依赖类型名）。很拗口，但例子很简单：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token class-name">Nested</span></span> <span class="token punctuation">&#123;</span> <span class="token comment">// 基类列表中 typename not</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span>                                 <span class="token comment">// allowed</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">explicit</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token operator">:</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">Nested</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>                  <span class="token comment">// 初始化列表中的基类标识符</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#123;</span>                                     <span class="token comment">// : typename not allowed</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">typename</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>Nested temp<span class="token punctuation">;</span>      <span class="token comment">// use of nested dependent type</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// name not in a base class list or</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span>                                     <span class="token comment">// as a base class identifier in a</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                   <span class="token comment">// mem. init. list: typename required</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里还有一个知识点，涉及 <code>typedef</code>  与 <code>typename</code> ，同时还需要一点点模板元编程的知识。</p>
<p>假设我们在写一个取得一个 iterator 的 函数模板，而且我们要做一个 iterator 指向的对象的局部拷贝 temp，我们可以这样做：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">workWithIterator</span><span class="token punctuation">(</span>IterT iter<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token double-colon punctuation">::</span>value_type <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里 <code>typename std::iterator_traits&lt;IterT&gt;::value_type</code>  实在太长了，因此可以使用这种语法简化它：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">workWithIterator</span><span class="token punctuation">(</span>IterT iter<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token double-colon punctuation">::</span>value_type value_type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  value_type <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>有点怪，但是这是合理的，可以很快的习惯这种语法，因为输一长串 typename + 类型太麻烦了</p>
<h3 id="item-43了解如何访问-templatized-base-classes模板化基类中的名字"><a class="anchor" href="#item-43了解如何访问-templatized-base-classes模板化基类中的名字">#</a> item 43 了解如何访问 templatized base classes（模板化基类）中的名字</h3>
<p>在模板类的继承体系中，子类不能像 Object-oriented C++ 那样直接使用父类的方法，这是模板具有特化的特性引起的问题，即<strong>针对某个类型进行的特化，这个特化后的类与其他通过相同模板的类可能拥有不同的方法</strong>，因此 C++ 拒绝模版派生类对模版基类方法的直接使用，因此，程序员需要向编译器保证任何后继的 base class template（基类模板）的 specializations（特化）都将支持 general template（通用模板）提供的 interface（接口），如果保证被证实不成立，真相将在后继的编译过程中暴露，编译器会报错。</p>
<p>保证的方法有：</p>
<ul>
<li>经由 &quot;this-&gt;&quot; 前缀</li>
<li>经由 using declarations</li>
<li>经由一个 explicit base class qualification（显式基类限定）引用 base class templates（基类模板）中的名字。</li>
</ul>
<p>比如想要使用基类模板的 <code>sendClear(...)</code>  函数，直接使用 <code>sendClear()</code>  不行，而下面这些语法才是正确的：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Company</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">LoggingMsgSender</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MsgSender</span><span class="token operator">&lt;</span><span class="token class-name">Company</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">sendClearMsg</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    write <span class="token string">"before sending"</span> info to the log<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">sendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// okay, assumes that</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                                          <span class="token comment">// sendClear will be inherited</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    write <span class="token string">"after sending"</span> info to the log<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Company</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">LoggingMsgSender</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MsgSender</span><span class="token operator">&lt;</span><span class="token class-name">Company</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">using</span> MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token double-colon punctuation">::</span>sendClear<span class="token punctuation">;</span>   <span class="token comment">// tell compilers to assume</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                    <span class="token comment">// that sendClear is in the</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                         <span class="token comment">// base class</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">sendClearMsg</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">sendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// okay, assumes that</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                  <span class="token comment">// sendClear will be inherited</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Company</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">LoggingMsgSender</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MsgSender</span><span class="token operator">&lt;</span><span class="token class-name">Company</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">sendClearMsg</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token class-name">MsgSender</span><span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">sendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// okay, assumes that</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                       <span class="token comment">// sendClear will be</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span>                                           <span class="token comment">// inherited</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="item44-从模板中分离出参数无关的代码"><a class="anchor" href="#item44-从模板中分离出参数无关的代码">#</a> item44 从模板中分离出参数无关的代码</h3>
<p>考虑以下求矩阵得 invert 的代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>           <span class="token comment">// template for n x n matrices of</span></pre></td></tr><tr><td data-num="2"></td><td><pre>         std<span class="token double-colon punctuation">::</span>size_t n<span class="token operator">></span>        <span class="token comment">// objects of type T; see below for info</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token punctuation">&#123;</span>           <span class="token comment">// on the size_t parameter</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// invert the matrix in place</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>SquareMatrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">></span> sm1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre>sm1<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// call SquareMatrix&lt;double, 5>::invert</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>SquareMatrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">></span> sm2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="15"></td><td><pre>sm2<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// call SquareMatrix&lt;double, 10>::invert</span></pre></td></tr></table></figure><p>这里将有两个 invert 函数被实例化。这两个函数不是相同的，因为一个作用于 5 x 5 矩阵，而另一个作用于 10 x 10 矩阵，但是除了常数 5 和 10 以外，这两个函数是相同的。很明显，这里发生了代码膨胀。</p>
<p>因此正确的做法是提供一个模板父类，派生自这个父类的所有具有相同 T 类型的 SquareMatrix 子类都共享同一个 invert 函数。</p>
<h3 id="item45-用成员函数模板接受所有兼容类型"><a class="anchor" href="#item45-用成员函数模板接受所有兼容类型">#</a> item45 用成员函数模板接受所有兼容类型</h3>
<p>本原则的场景是：考虑一个 A 类型与 B 类型，其中 B 类型是 A 类型的派生类，那么一个 B 类型的对象或指针可以隐式的转换为 A 类型的指针或对象。但是，对于智能指针或类似功能的其他类，一个 share_ptr&lt;B&gt; 类型对象却无法隐式转换为 share_ptr&lt;A &gt; 类型，<strong>因为同一个模板的不同实例化之间没有继承关系</strong>，虽然这样的转换符合直觉并且大多数情况下很有用。因此在用户定义类型中模仿这样的转换是有意义的，并且需要一些技巧。</p>
<p>正确的做法是使用一个模板构造函数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>         <span class="token comment">// initialize this held ptr</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>             <span class="token comment">// with other's held ptr</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> heldPtr<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span>                                     <span class="token comment">// built-in pointer held</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  T <span class="token operator">*</span>heldPtr<span class="token punctuation">;</span>                                <span class="token comment">// by the SmartPtr</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>他接受任意类型的其他智能指针，并且仅当 U 类型能隐式转换为 T 类型的时候，代码能通过编译，这正是我们想要的。除此之外，赋值操作也应该达到这个效果，因此我们可以写出下面的代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span>                                     <span class="token comment">// construct from</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">explicit</span> <span class="token function">shared_ptr</span><span class="token punctuation">(</span>Y <span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// any compatible</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span>                                     <span class="token comment">// built-in pointer,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// shared_ptr,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span>                                     <span class="token comment">// weak_ptr, or</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">explicit</span> <span class="token function">shared_ptr</span><span class="token punctuation">(</span>weak_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// auto_ptr</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">explicit</span> <span class="token function">shared_ptr</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span>                                     <span class="token comment">// assign from</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// any compatible</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span>                                     <span class="token comment">// shared_ptr or</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// auto_ptr</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>需要注意的是，成员模板并不改变语言规则，而且规则规定一个拷贝构造函数时必需的而我们没有提供，编译器会自动生成一个，所以<strong>一个模板构造函数不会阻止编译器生成非模板的构造函数</strong>。因此为了全面支配拷贝构造，我们必须既声明一个模板拷贝构造函数，又声明一个常规的，非模板的拷贝构造函数，这同样适用于赋值，正确的实践应当像这样：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// copy constructor</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span>                                <span class="token comment">// generalized</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// copy constructor</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// copy assignment</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">></span>                                <span class="token comment">// generalized</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// copy assignment</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="item46-需要类型转换时在模板内定义非成员函数"><a class="anchor" href="#item46-需要类型转换时在模板内定义非成员函数">#</a> item46 需要类型转换时在模板内定义非成员函数</h3>
<p>此节针对 item24 中的示例增加了扩展讨论 (模板化 Rational 和 operator*)。item 24 的结论告诉我们，非成员函数适合应用到所有参数都需要进行隐式类型转换的场景之中。因此在模板中也使用相同的方法是很自然的:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>     <span class="token comment">// see Item 20 for why params</span></pre></td></tr><tr><td data-num="5"></td><td><pre>           <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// are now passed by reference</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">const</span> T <span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>           <span class="token comment">// see Item 28 for why return</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">const</span> T <span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>         <span class="token comment">// values are still passed by value,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                  <span class="token comment">// Item 3 for why they're const</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                            <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>正如 item24 中提到的，我们想要支持 mixed-mode arithmetic（混合模式运算），所以我们要让下面这些代码能够编译：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// this example is from Item 24,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                                      <span class="token comment">// except Rational is now a template</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// error! won't compile</span></pre></td></tr></table></figure><p>编译失败的原因是：<mark>模板实参推导的过程中，从不考虑隐式类型转换</mark>因此面对一个 Rational&lt;int&gt; 类型的参数 <code>oneHalf</code>  和 int 类型的参数 <code>2</code> , 编译器不会将 <code>2</code>  隐式转换为 Rational&lt;int&gt; 类型，也就导致了 operator * 模板推导失败，编译器找不到能用的实现。</p>
<p>也就是说，如果我们有了一个实例化的函数，对它的调用过程中参数可以发生隐式类型转换，但既然模板推导过程失败了，我们也就没有了实例化的函数，这就是编译失败的原因。</p>
<p>这里用到的解决方案是让 class Rational&lt;T&gt; 为 Rational&lt;T&gt; 声明作为一个友元函数的 operator*。<strong>class 类模板不依靠 模板实参推演（这个过程仅适用于 function templates（函数模板）），所以 T 在 class Rational&lt;T&gt; 被实例化时总是已知的：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">friend</span>                                              <span class="token comment">// declare operator*</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>     <span class="token comment">// function (see</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                           <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// below for details)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                                <span class="token comment">// define operator*</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token comment">// functions</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                            <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在对 operator * 的混合模式调用可以编译了，因为当 object oneHalf 被声明为 Rational&lt;int&gt; 类型时，class Rational&lt;int&gt; 被实例化，而作为这一过程的一部分，取得 Rational&lt;int &gt; 参数的友元函数 operator* 被自动声明。作为已声明 函数（并非一个 函数模板），在调用它的时候编译器可以使用隐式转换函（譬如 Rational 的非显式构造函数），而这就是它们如何使得混合模式调用成功的。</p>
<p>by the way，有一个小知识点是：在一个 类模板内部，模板的名字可以被用做 模板和它的参数的缩写，所以，在 Rational&lt;T&gt; 内部，我们可以只写 Rational 代替 Rational&lt;T&gt;。</p>
<p>但是，上面的代码虽然能够编译，但是还不能链接，因为 operator* 还没有提供实现。我们打算让 class 之外的 operator* 模板提供这个定义，但是这种方法不能工作 (why)。让它能工作的最简单的方法或许就是将 operator* 的本体合并到它的 定义中：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment">// same impl</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                  lhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// as in</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span>                                                          <span class="token comment">// Item 24</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="item47-为类型信息使用-traits-classes特征类"><a class="anchor" href="#item47-为类型信息使用-traits-classes特征类">#</a> item47 为类型信息使用 traits classes（特征类）</h3>
<p>当我们的函数想为某些特定类型提供更高效的实现，并且不想在运行期花费额外开销进行类型判断的时候，本节的技巧十分有用。本节的一些做法在 C++ 11 后有了更简洁的做法，不过了解一下还是很有必要的，替代方法在节末也有涉及。</p>
<p>以 STL 提供的 advance 函数为例，advance 将一个指定的 iterator 移动一个指定的距离：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span>       <span class="token comment">// move iter d units</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// forward; if d &lt; 0,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                                               <span class="token comment">// move iter backward</span></pre></td></tr></table></figure><p>在概念上，advance 仅仅是在做 <code>iter += d</code> , 但是这样实现是错误的，因为只有随机访问迭代器支持 <code>+=</code>  操作。其它迭代器不得不反复利用 <code>++</code>  或 <code>--</code>  d 次来实现 advance。</p>
<p>STL 的 iterator 不同种类的简单回顾：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>特点</th>
<th>代表</th>
</tr>
</thead>
<tbody>
<tr>
<td>input iterators (输入迭代器)</td>
<td>只能向前移动，每次移动一步，只读</td>
<td>输入文件的读指针</td>
</tr>
<tr>
<td>output iterators (输出迭代器)</td>
<td>只能向前移动，每次移动一步，只写</td>
<td>输出文件的写指针</td>
</tr>
<tr>
<td>forward iterators (前向迭代器)</td>
<td>只能向前移动，每次移动一步</td>
<td>单向链表容器的迭代器</td>
</tr>
<tr>
<td>bidirectional iterators (双向迭代器)</td>
<td>加上了和前向迭代器一样的向后移动能力</td>
<td>set,map 的迭代器</td>
</tr>
<tr>
<td>random access iterators (随机访问迭代器)</td>
<td>可以在常量时间里向前或向后跳转任意距离</td>
<td>vector,string 的迭代器</td>
</tr>
</tbody>
</table>
<p>对于五种迭代器种类，C++ 都有一个用于识别它的 &quot;tag struct&quot; 结构体在标准库中：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">input_iterator_tag</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">output_iterator_tag</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">forward_iterator_tag</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">input_iterator_tag</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">bidirectional_iterator_tag</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">forward_iterator_tag</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">random_access_iterator_tag</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">bidirectional_iterator_tag</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这些结构体之间的继承关系体现了 &quot;is a&quot; 关系</p>
<p>返回到 advance，对于不同的 iterator, 实现 advance 的一个方法是使用反复增加或减少 iterator 的循环，这个方法时间复杂度是 O (n)，但是随机访问迭代器支持常量时间的移动，所以当它出现的时候我们最好能利用这种能力。我们真正想做的大致可以这样描述：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>iter is a random access iterator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     iter <span class="token operator">+=</span> d<span class="token punctuation">;</span>                                      <span class="token comment">// use iterator arithmetic</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span>                                                  <span class="token comment">// for random access iters</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>d<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">++</span>iter<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>              <span class="token comment">// use iterative calls to</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>d<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">--</span>iter<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>                     <span class="token comment">// ++ or -- for other</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span>                                                  <span class="token comment">// iterator categories</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>** 现在的关键是，我们如何得到关于一个类型的某些信息。这就是 traits 能做到的：它们允许你在编译过程中得到过于一个类型的信息。**traits 不是 C++ 中的一个关键字或预定义结构；它们是一项技术和 C++ 程序员遵守的惯例。建立这项技术的要求之一是它在 内建类型上必须和在 user-defined types（用户定义类型）上一样有效，因此将信息嵌入到类型内部是不可以的，因为无法将信息嵌入一个指针内部。那么，一个类型的 traits 信息，必须在类型外部。标准的方法是将它放到 模以及这个模板的一个或更多的特化中。对于 iterators，标准库中模板被称为 iterator_traits：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token operator">></span>          <span class="token comment">// template for information about</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token punctuation">;</span>           <span class="token comment">// iterator types</span></pre></td></tr></table></figure><p>iterator_traits 的工作方法是对于每一个 IterT 类型，在 结构体 iterator_traits&lt;IterT&gt; 中声明一个名为 iterator_category 的 typedef。这个 typedef 被看成是 IterT 的 iterator category（迭代器种类）。</p>
<p>iterator_traits 通过两部分实现这一点。首先，它强制要求任何 user-defined iterator（用户定义迭代器）类型必须包含一个名为 iterator_category 的嵌套 typedef 用以识别适合的 tag struct（标签结构体）。例如，deque 的 iterators（迭代器）是随机访问的，所以一个 deque iterators 的 class 看起来就像这样：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span>                    <span class="token comment">// template params elided</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">deque</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>对于一个 list (双向链表)，则是这样：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">typedef</span> bidirectional_iterator_tag iterator_category<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>而 iterator_traits 仅仅是简单地模仿了 iterator class 的嵌套 typedef：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// the iterator_category for type IterT is whatever IterT says it is;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// see Item 42 for info on the use of "typedef typename"</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token double-colon punctuation">::</span>iterator_category iterator_category<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>同时为了支持指针这样无法带有嵌套 typedef 的东西，iterator_traites 为其提供了一个部分模板特化：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token operator">></span>               <span class="token comment">// partial template specialization</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>IterT<span class="token operator">*</span><span class="token operator">></span>         <span class="token comment">// for built-in pointer types</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>到此为止，可以总结出如何设计和实现一个 traits class：</p>
<ul>
<li>识别你想让它可用的关于类型的一些信息（例如，对于 iterators（迭代器）来说，就是它们的 iterator category（迭代器种类））。</li>
<li>选择一个名字标识这个信息（例如，iterator_category）。</li>
<li>提供一个模板和一系列特化（例如，iterator_traits），它们包含你要支持的类型的信息。</li>
</ul>
<p>有了 iterator_traits，就可以改善 advance 的伪代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator_category<span class="token punctuation">)</span> <span class="token operator">==</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     <span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>random_access_iterator_tag<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// 这个代码可能涉及编译问题 见原书 item48</span></pre></td></tr></table></figure><p>现在的问题是：IterT 的类型在编译期间是已知的，所以 iterator_traits&lt;IterT&gt;::iterator_category 可以在编译期间被确定。但是 if 语句还是要到运行时才能被求值。为什么要到运行时才做我们在编译期间就能做的事情呢？它浪费了时间。</p>
<p>解决方法是，重载，重载的最佳匹配是编译期间完成的，这个行为也有点像 if 语句选择分支的过程。为了让 advance 拥有我们想要的行为方式，我们必须要做的全部就是创建一个包含 advance 的 “内容” 的重载函数的多个版本：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span>              <span class="token comment">// use this impl for</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">,</span>                  <span class="token comment">// random access</span></pre></td></tr><tr><td data-num="3"></td><td><pre>               std<span class="token double-colon punctuation">::</span>random_access_iterator_tag<span class="token punctuation">)</span>       <span class="token comment">// iterators</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  iter <span class="token operator">+=</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span>              <span class="token comment">// use this impl for</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">,</span>                  <span class="token comment">// bidirectional</span></pre></td></tr><tr><td data-num="11"></td><td><pre>               std<span class="token double-colon punctuation">::</span>bidirectional_iterator_tag<span class="token punctuation">)</span>       <span class="token comment">// iterators</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>d<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">++</span>iter<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>d<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">--</span>iter<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span>              <span class="token comment">// use this impl for</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">,</span>                  <span class="token comment">// input iterators</span></pre></td></tr><tr><td data-num="19"></td><td><pre>               std<span class="token double-colon punctuation">::</span>input_iterator_tag<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>     <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">"Negative distance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// see below</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span>d<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">++</span>iter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>给出针对 doAdvance 的各种重载，advance 需要做的全部就是调用它们，传递一个适当的 iterator category 类型的额外 object 以便编译器利用重载匹配正确的实现：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">doAdvance</span><span class="token punctuation">(</span>                                              <span class="token comment">// call the version</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    iter<span class="token punctuation">,</span> d<span class="token punctuation">,</span>                                              <span class="token comment">// of doAdvance</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">typename</span>                                              <span class="token comment">// that is</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      std<span class="token double-colon punctuation">::</span><span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// appropriate for</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                      <span class="token comment">// iter's iterator</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ps: C++17 后提供的 constexpr if 和 &lt;type_traits&gt; 库是重载的一个替代方法，可以使上述代码更简单易读：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">DistT</span><span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DistT d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same_v<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator_category<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>random_access_iterator_tag<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">doAdvance</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> d<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>random_access_iterator_tag<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">constexpr</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same_v<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator_category<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>bidirectional_iterator_tag<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">doAdvance</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> d<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>bidirectional_iterator_tag<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">doAdvance</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> d<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>input_iterator_tag<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="item48-感受模板元编程tmp"><a class="anchor" href="#item48-感受模板元编程tmp">#</a> item48 感受模板元编程 (TMP)</h3>
<p>本节提供的例子是 TMP 界的 &quot;hello world&quot; 程序：用模板元编程计算阶乘：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> n<span class="token operator">></span>                 <span class="token comment">// general case: the value of</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Factorial</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// Factorial&lt;n> is n times the value</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                                     <span class="token comment">// of Factorial&lt;n-1></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> value <span class="token operator">=</span> n <span class="token operator">*</span> Factorial<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>                           <span class="token comment">// special case: the value of</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Factorial</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Factorial&lt;0> is 1</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> value <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后可以这样使用：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> Factorial<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>            <span class="token comment">// prints 120</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> Factorial<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>           <span class="token comment">// prints 3628800</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>很基础，但是能体现 TMP 的最大优势：将运行期的计算放到编译器计算，但是可能还不足够显示模板元编程的巨大威力。模板元编程是一门图灵完备的语言，它能做到很多事，它带来的效率提升令人惊叹...</p>
<p>C++11 后，模板元编程正式获得了标准库支持，遗憾的是本书完成之前还没有引入，模板元编程现在有了许多通用的范式和惯例，当需要的时候，可以深入去了解它们。</p>
<p>C++11 的 &lt;type_traits&gt; 库提供了一些非常有用的模板元编程支持，包括 (gpt 生成）：</p>
<ol>
<li><strong>型别特征 (Type Traits)</strong>:
<ul>
<li><code>std::is_same&lt;T, U&gt;</code> : 检查两个类型是否相同。</li>
<li><code>std::is_integral&lt;T&gt;</code> : 检查类型是否为整型。</li>
<li><code>std::is_floating_point&lt;T&gt;</code> : 检查类型是否为浮点型。</li>
<li><code>std::is_pointer&lt;T&gt;</code> : 检查类型是否为指针。</li>
<li>还有很多其他有用的型别特征，如  <code>is_array</code> 、 <code>is_class</code> 、 <code>is_enum</code>  等。</li>
</ul>
</li>
<li><strong>类型转换</strong>:
<ul>
<li><code>std::conditional&lt;B, T, F&gt;</code> : 根据布尔值  <code>B</code>  选择类型  <code>T</code>  或  <code>F</code> 。</li>
<li><code>std::enable_if&lt;B, T&gt;</code> : 根据布尔值  <code>B</code>  启用或禁用类型  <code>T</code> 。</li>
<li><code>std::decay&lt;T&gt;</code> : 获取类型  <code>T</code>  的 &quot;衰减&quot;(decay) 形式。</li>
</ul>
</li>
<li><strong>数值计算</strong>:
<ul>
<li><code>std::integral_constant&lt;T, v&gt;</code> : 表示一个编译时常量值。</li>
<li><code>std::tuple&lt;Types...&gt;</code> : 异构容器，可用于编译时计算。</li>
<li><code>std::pair&lt;T, U&gt;</code> : 二元组，可用于编译时计算。</li>
</ul>
</li>
<li><strong>函数操作</strong>:
<ul>
<li><code>std::invoke&lt;F, Args...&gt;</code> : 调用可调用对象  <code>F</code>  并传递参数  <code>Args</code> 。</li>
<li><code>std::result_of&lt;F(Args...)&gt;</code> : 获取调用  <code>F(Args...)</code>  的结果类型。</li>
</ul>
</li>
<li><strong>算法</strong>:
<ul>
<li><code>std::make_index_sequence&lt;N&gt;</code> : 生成一个包含  <code>0</code>  到  <code>N-1</code>  的整数序列。</li>
<li><code>std::index_sequence_for&lt;T1, T2, ..., TN&gt;</code> : 根据给定类型生成整数序列。</li>
</ul>
</li>
</ol>
<p>从这些函数的作用可见 TMP 的强大效用，足以在需要的时候担当重任。</p>
<h2 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h2>
<h3 id="item49-了解-new-handler的行为"><a class="anchor" href="#item49-了解-new-handler的行为">#</a> item49 了解 new-handler 的行为</h3>
<p>对是否处理内存分配失败这件事有争议，一种说法是直接让程序 crash 即可，毕竟内存不足已经是十分严重的系统问题，并且对于内存分配失败程序员大多数时候总是无能为力。但是，任何技术都有适合的场景，并且本节涉及的一些技巧还是十分精妙，有助于学习。</p>
<p>这一节主要介绍了对 new 行为分配内存失败的一种处理方案：new-handler，程序员可以使用 &lt;new&gt; 标准库中的 set_new_handler 函数设置一个 new-handler，在内存分配失败时会调用设置的 new-handler，具体来说它们的声明是这样的：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> std <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>new_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//new_handler 是一个函数指针类型</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置 global new_handler 为 p，并返回旧的 new_handler</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>一个使用的例子是:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">outOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span><span class="token string">"Unable to satisfy request for memory\n"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	std<span class="token double-colon punctuation">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>outOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span> pBigDataArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1000000000L</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当 operator new 无法满足内存申请时，它会不断调用 new-handler，直到找到足够内存 (见 item 51)，从这个描述可以总结出<strong>一个好的 new-handler 必须做以下事情之一</strong>：</p>
<ul>
<li>让更多内存被使用</li>
<li>安装另一个 new-handler（让有能力的人来)</li>
<li>卸载 new-handler（将 new-handler 设置为 null，没有安装任何 new-handler 时，operator new 会在内存分配失败时抛出异常</li>
<li>抛出 bad_alloc 异常</li>
<li>不返回，调用 abort 或 exit</li>
</ul>
<p>很多时候我们希望以不同的方式处理内存分配失败情况，特别是希望视分配物属于哪个 class 而定，我们想要达到这样的效果：</p>
<pre><code class="language-c++">class X &#123;
public:
	static void outOfMemory();
	...
&#125;
class Y &#123;
public:
	static void outOfMemory();
&#125;
X *p1 = new X; //失败时调用X::outOfMemory
Y *p2 = new Y; //失败时调用Y::outOfMemory
</code></pre>
<p>遗憾的是 C++ 不支持为类提供专属的 new-handlers, 我们不得不自己实现这种行为。只需每个 class 提供自己的 set_new_handler 和 operator new 即可，<strong>其中 set_new_handler 使客户得以指定 class 专属的 new-handler, 而 operator new 则确保在分配 class  对象内存的过程中用类专属的 new-handler 替换 global new-handler。</strong></p>
<p>假设我们现在想为 Widget 类提供一个专属 new-handler</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler set_new<span class="token operator">-</span><span class="token function">handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler currentHandler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>std<span class="token double-colon punctuation">::</span>new_handler Widget<span class="token double-colon punctuation">::</span>currentHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>std<span class="token double-colon punctuation">::</span>new_handler <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 和标准版没什么区别</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    std<span class="token double-colon punctuation">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最重要的是 Widget 重载的 opertor new, 它需要做到以下事情:</p>
<ol>
<li>调用标准 set_new_handler, 将 Widget 的 new-handler 安装为 global new-handler</li>
<li>调用 global operator new 执行实际的内存分配，如果分配失败，会调用 widget 的 new-handler，如果最终仍无法分配，会抛出 bad_alloc 异常，并且必须恢复原本的 global new-handler。为了确保原来的 new-handler 总是能够被重新安装回去，将用到 RAII 机制</li>
<li>如果 global operator new 成功分配，Widget 的 operator new 会返回一个指向分配的内存的指针，并且要自动恢复调用前的 global new-handler。</li>
</ol>
<p>代码，运用到了 RAII 机制：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">NewHandlerHolder</span> <span class="token punctuation">&#123;</span>	<span class="token comment">//	资源管理类</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">explicit</span> <span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler nh<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">handler</span><span class="token punctuation">(</span>nh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">~</span><span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>	<span class="token comment">// 析构时恢复 global new_handler</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewHandlerHolder <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>	<span class="token comment">// 禁止拷贝和赋值</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    NewHandlerHolder<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewHandlerHolder <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	std<span class="token double-colon punctuation">::</span>new_handler handler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// Widget 的 operator new 也很简单</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    NewHandlerHolder <span class="token function">h</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回或抛出异常时会自动恢复之前的 new-handler</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在 Widget 的客户可以这样方便地为其指定 new-handler:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">outOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>outOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Widget<span class="token operator">*</span> pw1 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span> <span class="token comment">// 失败是调用 outOfMem</span></pre></td></tr><tr><td data-num="4"></td><td><pre>std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> ps <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span> <span class="token comment">// 失败时调用 global new-handler</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>Widget<span class="token operator">*</span> pw2 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>	<span class="token comment">// 失败时抛出异常</span></pre></td></tr></table></figure><p>实现这一方案的代码并不因 class 的不同而不同，因此考虑如何加上复用是一个自然的想法，一个简单的做法是提供一个 base class 来允许派生类继承这一能力。由于每个类都需要获得一个不同的静态 currentHandler 对象，需要用到模板。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">NewHandlerSupport</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler set_new<span class="token operator">-</span><span class="token function">handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token punctuation">;</span><span class="token operator">:</span>size_t size<span class="token punctuation">)</span><span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler currentHandler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="12"></td><td><pre>std<span class="token double-colon punctuation">::</span>new_handler</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name">NewHandlerSupport</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	std<span class="token double-colon punctuation">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>templace<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	NewHandlerHolder <span class="token function">h</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="25"></td><td><pre>std<span class="token double-colon punctuation">::</span>new_handler NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>currentHandler <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">// 现在 widget 类只需要</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">NewHandlerSupport</span><span class="token operator">&lt;</span><span class="token class-name">Widget</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="item50-领会何时替换new和delete才有意义"><a class="anchor" href="#item50-领会何时替换new和delete才有意义">#</a> item50 领会何时替换 new 和 delete 才有意义</h3>
<p>在以下情况可以替换缺省的 new 和 delete：</p>
<ul>
<li>为了检测运用错误</li>
<li>为了收集动态分配内存的使用统计信息</li>
<li>为了增加分配和归还的速度</li>
<li>为了降低缺省内存管理器带来的额外空间开销</li>
<li>为了弥补缺省分配器中的非最佳齐位 (比如 x86 架构对 8 byte 齐位的 double 类型最快，所以重载 opertor new 让分配地址都是 8 byte 齐位)</li>
<li>为了将相关对象集中</li>
<li>为了获得非传统的行为</li>
</ul>
<p><strong>内存分配很困难，坑也很多，如需要重写最好还是引入或者参考开源库。</strong></p>
<h3 id="item51-编写-new-和-delete-时要遵守惯例"><a class="anchor" href="#item51-编写-new-和-delete-时要遵守惯例">#</a> item51 编写 new 和 delete 时要遵守惯例</h3>
<p>首先看看 operator new 大概做了什么：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>                                      <span class="token comment">// your operator new might</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>                 <span class="token comment">// take additional params</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// handle 0-byte requests</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">// by treating them as</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span>                                    <span class="token comment">// 1-byte requests</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   _attempt to allocate size bytes<span class="token punctuation">;</span>_</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_the allocation was successful_<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>       <span class="token keyword">return</span> <span class="token punctuation">(</span>_a pointer to the memory_<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// allocation was unsuccessful; find out what the</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// current new-handling function is (see below)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    new_handler globalHandler <span class="token operator">=</span> <span class="token function">set_new_handler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>它处理了零字节（C++ 要求即使请求零字节，operator new 也要返回一个合理的指针），也包含了一个无限循环，跳出循环的唯一出路是内存被成功分配或 new-handling function 做了 item49 中描述的事情之一：使得更多的内存可用，安装一个不同的 new-handler，卸载 new-handler，抛出一个 bad_alloc，或不再返回。我们自己重写的 operator new 也需要遵循这些规则。</p>
<p>有一个容易被忽略的点是 operator new 成员函数会被派生类继承，对于 Class X 来说 它的 operator new 成员函数的 size 一般是与 sizeof (X) 适配的，绝不会更大或者更小。然而，由于继承，就有可能一个基类中的 operator new 被调用来为一个派生类分配内存。如果基类 的 operator new 不是被设计成应付这种情况的（很有可能是基类专属的操作）。它处理这种局面的最佳方法就是把这个请求调用甩给 standard operator new:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span> Base<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token comment">// if size is "wrong,"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// have standard operator</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                                          <span class="token comment">// new handle the request</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// otherwise handle</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                                          <span class="token comment">// the request here</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于 operator delete，事情就更简单了，唯一需要注意的就是 C++ 保证删除空指针总是安全的，所以你需要遵循这个保证。下面是一个 standard operator delete 的伪代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>rawMemory<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token comment">// do nothing if the null</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                                         <span class="token comment">// pointer is being deleted</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  _deallocate the memory pointed to by rawMemory<span class="token punctuation">;</span>_</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>类似地，对于错误大小的 delete 请求，也可以委托给 stardard operator delete 来做。</p>
<h3 id="item52-如果编写了-placement-new就要编写-placement-delete"><a class="anchor" href="#item52-如果编写了-placement-new就要编写-placement-delete">#</a> item52 如果编写了 placement new，就要编写 placement delete</h3>
<p>两个要点：</p>
<ul>
<li>
<p><strong>在编写一个 operator new 的 placement 版本时，确保同时编写 operator delete 的相应的 placement 版本。否则，你的程序可能会发生微妙的，断续的 memory leaks 内存泄漏。</strong></p>
<p>原因是，考虑下面这种代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Widget <span class="token operator">*</span>pw <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这行代码会发生两件事，一是调用 operator new 为 Widget 分配内存，然后调用 Widget 的默认构造函数，假设第二步调用抛出了一个异常，第一步的内存分配必须被撤销，否则就是一个内存泄漏。由于 clients 无法获取第一步分配的地址，因此撤销操作必须由 C++ runtime system 来完成。</p>
<p>那么 C++ 会调用哪个 delete 函数来撤销呢，它会调用与这个 new 操作参数一致的 operator delete 来撤销，如果没有提供，它什么也不会做，那么就将发生内存泄漏。</p>
<p>比如说：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里提供了一个 placement new </span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pMemory<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pMemory<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 必须提供一个与 placement new 对应的 delete 函数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>当你声明 new 和 delete 的 placement 版本时，确保不会无意中覆盖这些函数的常规版本。</strong></p>
<p>item 33 讨论了继承体系中 name 被覆盖的场景和需要考虑的细节，new 和 delete 的编写也不例外。</p>
<p>C++ 在全局提供如下形式的 operator new:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// normal new</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// placement new</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span>                             <span class="token comment">// nothrow new —</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                   <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// see [Item 49]</span></pre></td></tr></table></figure><p>因此如果你在一个 class 中声明了任何 operator news，都将覆盖所有这些标准形式。<strong>除非你有意防止 class 的客户使用这些形式，否则，除了你创建的任何自定义 new 形式以外，还要确保它们都可以使用。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ 读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux—01-Linux安装常识</title>
    <url>/2022/09/30/Linux%E2%80%9401-Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h1 id="linux系统的安装"><a class="anchor" href="#linux系统的安装">#</a> Linux 系统的安装</h1>
<p><span id="more"></span></p>
<p><img data-src="preview.jpg" alt="芝士辉夜"></p>
<h2 id="交换分区"><a class="anchor" href="#交换分区">#</a> 交换分区</h2>
<p>直接从物理内存读写数据比从硬盘读写快的多，然而物理硬盘是有限的，这样就使用到了虚拟内存。虚拟内存是为了满足物理内存的不足而提出的一种策略，他是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为<strong>交换分区（swap 分区）</strong>。</p>
<p>内核会将暂时不用的内存信息写到交换分区，使物理内存得到释放并用于其它用途，当需要原始内容时，这些信息会被重新从交换分区读入物理内存。</p>
<p>Linux 的内存管理采用分页存取机制，为了保证物理内存能得到充分利用，内核会在适当时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p>
<h2 id="分区命名"><a class="anchor" href="#分区命名">#</a> 分区命名</h2>
<p>Linux 系统使用字母和数字的组合来指代硬盘分区，该命名方案是基于文件的，文件名的格式为 */dev/xxyN* (比如 /dev/sda1 分区)</p>
<p>/dev: 这是 Linux 系统中所有设备文件所在的目录名。因为分区位于硬盘上，而硬盘是设备，所以这些文件代表了在 /dev 上所有可能的分区</p>
<p>xx：分区名的前两个字母表示分区所在设备的类型，通常是 hd（IDE）硬盘或 sd（SCSI 硬盘）</p>
<p>y: 这个字母表示分区所在的设备。例如，/dev/hda（第一个 IDE 硬盘）或 /dev/sdb (第二个 SCSI 硬盘)</p>
<p>N：最后的数字 N 代表硬盘上的第几个分区。</p>
<h2 id="挂载目录"><a class="anchor" href="#挂载目录">#</a> 挂载目录</h2>
<p>Linux 系统中的每一个分区都是构成支持一组文件和目录 所必需的存储区的一部分。它是通过挂载来实现的，挂载 是将分区关联到某一目录的过程，挂载分区使起始于这个 指定目录（称为挂载目录）的存储区能够被使用。</p>
<p>例如，如果分区 /dev/sda5 被挂载在目录 /usr 上，这意味着 所有在 /usr 下的文件和目录在物理上位于 /dev/sda5。因此 文件 /usr/bin/cal 被保存在分区 /dev/sda5 上，而文件 /etc/passwd 却不是。</p>
<p>/usr 目录下的目录还有可能是其它分区的挂载目录。例如， 某个分区（如 /dev/sda7）可以被挂载到 /usr/local 目录下， 这意味着文件 /usr/local/man/whatis 将位于分区 /dev/sda7 上，而不是分区 /dev/sda5 上。</p>
<h2 id="分区规划"><a class="anchor" href="#分区规划">#</a> 分区规划</h2>
<p>合理的分区规划 ：</p>
<p>・swap 分区：实现虚拟内存，建议大小是物理内存 的 1～2 倍；</p>
<p>・/boot 分区：建议大小最少为 200MB；・/usr 分区：用来存放 Linux 系统中的应用程序， 其相关数据较多，建议大小最少为 8GB；</p>
<p>・/var 分区：用来存放 Linux 系统中经常变化的数 据以及日志文件，建议大小最少为 1GB；</p>
<p>・/ 分区：Linux 系统的根目录，所有的目录都挂在 这个目录下面，建议大小最少为 1GB；</p>
<p>・/home 分区：存放普通用户的数据，是普通用户 的宿主目录，建议大小为剩下的空间。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>STL学习-01-智能指针与vector</title>
    <url>/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/</url>
    <content><![CDATA[<h1 id="c-的标准模板库"><a class="anchor" href="#c-的标准模板库">#</a> c++ 的标准模板库</h1>
<p><span id="more"></span></p>
<p><img data-src="%E9%9B%A8%E5%A4%A9-%E5%A5%B3%E5%AD%A9-%E5%95%86%E5%BA%97.jpg" alt="雨天 女孩 商店"></p>
<h2 id="智能指针模板类"><a class="anchor" href="#智能指针模板类">#</a> 智能指针模板类</h2>
<p>智能指针是类似于指针的类对象，比较方便内存管理。传统的指针必须时时刻刻记得 new 与 delete 的配套使用，很容易造成内存泄漏。而智能指针实际上类似于一个类，有自己的析构函数，所以编译器再不需要智能指针时便可以自动调用其析构函数释放内存，也就是可以略去 delete 操作。</p>
<h3 id="使用智能指针"><a class="anchor" href="#使用智能指针">#</a> 使用智能指针</h3>
<p>要创建智能指针对象，必须包含头文件 memory 然后使用通常的模板语法来实例化所需类型的指针。</p>
<p>声明：  <code> template &lt;class X&gt; class auto_ptr</code></p>
<p>使用 eg：  <code> auto_ptr&lt;double&gt; pd(new double);</code></p>
<p>​					  <code>auto_ptr&lt;string&gt; ps(new string);</code></p>
<p>注意： 智能指针模板位于名称空间 std 中。</p>
<h3 id="有关智能指针的注意事项"><a class="anchor" href="#有关智能指针的注意事项">#</a> 有关智能指针的注意事项</h3>
<p>c++ 目前有三种常见智能指针：auto_ptr, unique_ptr,shared_ptr</p>
<p>在使用智能指针时，可能会遇到问题，比如如果两个智能指针指向同一块内存区域，则程序会删除同一个对象两次，这是会造成极大错误的。为避免这种问题，方法有多种。</p>
<ul>
<li>建立所有权概念，对于特定对象，只有一个智能指针可以拥有他。 这是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 更严格</li>
<li>创建智能更高的指针，跟踪引用特定对象的智能指针数，这称为引用计数。当最后一个指针过期时，才调用 delete。这是 shared_ptr 的策略</li>
<li>执行深拷贝</li>
</ul>
<p>auto_ptr 和 unique_ptr 的区别：</p>
<p>​		两个 auto_ptr 指向同一块内存区域时，可以通过编译，但可能在运行时报错。两个 unique_ptr 指向同一块内存区域时，会在编译阶段就报错（除非赋值给其中一个 unique_ptr 的另一个 unique_ptr 是一个用完即毁的智能指针，如某一函数中 new 出来的 unique_ptr 的返回）。</p>
<h2 id="模板类vector"><a class="anchor" href="#模板类vector">#</a> 模板类 vector</h2>
<h3 id="创建vector"><a class="anchor" href="#创建vector">#</a> 创建 vector</h3>
<p>要创建 vector 模板对象， 可使用通常的 &lt;type&gt; 表示法来指出要使用的类型。另外，vector 模板使用动态内存分配，因此可以用初始化参数指出需要多少元素。</p>
<p><code> vector&lt;int&gt; ratings(5);  // a vector of 5 ints</code></p>
<h3 id="可对vector执行的操作"><a class="anchor" href="#可对vector执行的操作">#</a> 可对 vector 执行的操作</h3>
<p>size ()—— 返回容器中元素数目        swap ()—— 交换两个容器的内容             begin ()—— 返回一个指向容器中第一个元素的 <em><strong>迭代器</strong></em>      end () 返回一个表示超过容器尾的<em><strong>迭代器</strong></em></p>
<p>什么是迭代器？ 它是一个广义的指针，可以对其执行类似指针的操作，如解除引用 *、递增 ++</p>
<p>STL 的每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，作用域为整个类。如要为 vector 的 double 类型规范声明一个迭代器，可以这样做：</p>
<p>​	 <code>vector&lt;double&gt;::iterator pd;//  pd an iterator</code></p>
<p>假设 scores 是一个 vector&lt;double&gt; 对象，可以利用好 auto 关键字简化书写：</p>
<p><code>auto pd = scores.begin()</code></p>
<p>vector 还支持 push_back () (内存不够会自动扩充容器), erase () insert () 等方法</p>
<h3 id="其它操作"><a class="anchor" href="#其它操作">#</a> 其它操作</h3>
<p>有两个具有代表性的 STL 函数：for_each () 和 sort () 。</p>
<p>for_each () 函数可用于很多容器类，它接受 3 个参数。前两个是定义容器中的迭代器，最后一个是一个函数指针。for_each () 函数将被指向的函数应用于容器区间中的各个元素，可以用 for_each () 函数来代替 for 循环。</p>
<p>eg:  <code>for_each(books.begin(), books.end(), ShowReview);</code></p>
<p>sort () 函数也要求函数支持随机访问。该函数接收两个定义区间的迭代器参数。如果容器中的元素有内置的 &lt; 运算符进行值比较，可以直接使用。如果容器中的元素是用户定义的类对象，则用户需要利用重载定义 &lt; 运算符。</p>
<p>还有第二个版本的 sort () 函数，它接收第三个参数，该参数是一个函数指针，不一定是用于比较的 operator&lt;()，而是一个返回值可转换为 bool 类型的函数，它接收两个容器中的元素，返回为 false 表示两个参数的顺序不正确。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL C++</tag>
      </tags>
  </entry>
  <entry>
    <title>golang-命令行词典</title>
    <url>/2023/07/21/golang-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%8D%E5%85%B8/</url>
    <content><![CDATA[<h1 id="golang-入门-命令行词典"><a class="anchor" href="#golang-入门-命令行词典">#</a> golang - 入门 命令行词典</h1>
<h2 id="golang相关知识点"><a class="anchor" href="#golang相关知识点">#</a> golang 相关知识点</h2>
<p>尝试了 goland 的基础语法，结构体使用，错误处理，基本的输入输出，命令行参数等。</p>
<p>体验了 go 自带的间结强大的 net 库，http 库等，可以非常轻松的进行 go 语言 struct 与 json 格式的序列化和反序列化。</p>
<h2 id="效果"><a class="anchor" href="#效果">#</a> 效果</h2>
<p><img data-src="image-20230721114017207.png" alt="image-20230721114017207"></p>
<h2 id="过程"><a class="anchor" href="#过程">#</a> 过程</h2>
<p>首先对某翻译网站翻译的请求进行抓包，得到请求发出时的请求头。然后可以使用检查工具中的 copy as cURL 复制为 curl 命令</p>
<p><img data-src="image-20230721114338333.png" alt="image-20230721114338333"></p>
<p>​	然后可搜索在线工具比如 curlconverter 将 curl 命令转化为 go 语言中发送 http 请求的代码。</p>
<p>​	还需要使用一个 go 语言自带的结构体保存返回的信息，由于返回的 json 字段很多，并且有嵌套，所以也可使用在线的 json 转 go 结构体工具。</p>
<p><img data-src="image-20230721115238319.png" alt="image-20230721115238319"></p>
<p>然后主体部分就完成了，将其封装为 query 函数，接受一个需要查询的字符串 word，在 main 函数中调用。</p>
<p>然后使用 go build 直接编译成可执行文件，将其路径放入环境变量即可。</p>
<h2 id="可改进之处"><a class="anchor" href="#可改进之处">#</a> 可改进之处</h2>
<p>请求头里的 cookie 和其余信息都是硬编码的，但是翻译网站的反爬和鉴权措施一般不会很严格，但仍有可能需要定时修改代码。</p>
<h2 id="代码"><a class="anchor" href="#代码">#</a> 代码</h2>
<figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token string">"bytes"</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token string">"encoding/json"</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token string">"io"</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token string">"log"</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token string">"net/http"</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token string">"os"</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">type</span> DictRequest <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	TransType <span class="token builtin">string</span> <span class="token string">`json:"trans_type"`</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	Source    <span class="token builtin">string</span> <span class="token string">`json:"source"`</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	UserID    <span class="token builtin">string</span> <span class="token string">`json:"user_id"`</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">type</span> DictResponse <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	Rc   <span class="token builtin">int</span> <span class="token string">`json:"rc"`</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	Wiki <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	<span class="token punctuation">&#125;</span> <span class="token string">`json:"wiki"`</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	Dictionary <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>		Prons <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>			EnUs <span class="token builtin">string</span> <span class="token string">`json:"en-us"`</span></pre></td></tr><tr><td data-num="26"></td><td><pre>			En   <span class="token builtin">string</span> <span class="token string">`json:"en"`</span></pre></td></tr><tr><td data-num="27"></td><td><pre>		<span class="token punctuation">&#125;</span> <span class="token string">`json:"prons"`</span></pre></td></tr><tr><td data-num="28"></td><td><pre>		Explanations <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>      <span class="token string">`json:"explanations"`</span></pre></td></tr><tr><td data-num="29"></td><td><pre>		Synonym      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>      <span class="token string">`json:"synonym"`</span></pre></td></tr><tr><td data-num="30"></td><td><pre>		Antonym      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>      <span class="token string">`json:"antonym"`</span></pre></td></tr><tr><td data-num="31"></td><td><pre>		WqxExample   <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    <span class="token string">`json:"wqx_example"`</span></pre></td></tr><tr><td data-num="32"></td><td><pre>		Entry        <span class="token builtin">string</span>        <span class="token string">`json:"entry"`</span></pre></td></tr><tr><td data-num="33"></td><td><pre>		Type         <span class="token builtin">string</span>        <span class="token string">`json:"type"`</span></pre></td></tr><tr><td data-num="34"></td><td><pre>		Related      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token string">`json:"related"`</span></pre></td></tr><tr><td data-num="35"></td><td><pre>		Source       <span class="token builtin">string</span>        <span class="token string">`json:"source"`</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token punctuation">&#125;</span> <span class="token string">`json:"dictionary"`</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>		fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">`usage: onlineDict WORD</span></pre></td></tr><tr><td data-num="42"></td><td><pre>eaxmple: onlineDict hello</pre></td></tr><tr><td data-num="43"></td><td><pre>`<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>		os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>	word <span class="token operator">:=</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="47"></td><td><pre>	<span class="token function">query</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token keyword">func</span> <span class="token function">query</span><span class="token punctuation">(</span>word <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>	client <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Client<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>	<span class="token comment">//var data = strings.NewReader(`&#123;"trans_type":"en2zh","source":"good"&#125;`)</span></pre></td></tr><tr><td data-num="53"></td><td><pre>	request <span class="token operator">:=</span> DictRequest<span class="token punctuation">&#123;</span>TransType<span class="token punctuation">:</span> <span class="token string">"en2zh"</span><span class="token punctuation">,</span> Source<span class="token punctuation">:</span> word<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>	buf<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="55"></td><td><pre>	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="57"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>	<span class="token keyword">var</span> data <span class="token operator">=</span> bytes<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="59"></td><td><pre>	req<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewRequest</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"xxxx"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="60"></td><td><pre>	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="62"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"authority"</span><span class="token punctuation">,</span> <span class="token string">"xxxx"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"accept"</span><span class="token punctuation">,</span> <span class="token string">"application/json, text/plain, */*"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="65"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"accept-language"</span><span class="token punctuation">,</span> <span class="token string">"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="66"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"app-name"</span><span class="token punctuation">,</span> <span class="token string">"xy"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="67"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"content-type"</span><span class="token punctuation">,</span> <span class="token string">"application/json;charset=UTF-8"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="68"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"device-id"</span><span class="token punctuation">,</span> <span class="token string">"89b4990d1ee4c5a8e30571cb7ac33c49"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="69"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"origin"</span><span class="token punctuation">,</span> <span class="token string">"xxxx"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="70"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"os-type"</span><span class="token punctuation">,</span> <span class="token string">"web"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="71"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"os-version"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="72"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"referer"</span><span class="token punctuation">,</span> <span class="token string">"https://fanyi.caiyunapp.com/"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="73"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"sec-ch-ua"</span><span class="token punctuation">,</span> `<span class="token string">"Not.A/Brand"</span><span class="token punctuation">;</span>v<span class="token operator">=</span><span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token string">"Chromium"</span><span class="token punctuation">;</span>v<span class="token operator">=</span><span class="token string">"114"</span><span class="token punctuation">,</span> <span class="token string">"Microsoft Edge"</span><span class="token punctuation">;</span>v<span class="token operator">=</span><span class="token string">"114"</span><span class="token string">`)</span></pre></td></tr><tr><td data-num="74"></td><td><pre>	req.Header.Set("sec-ch-ua-mobile", "?0")</pre></td></tr><tr><td data-num="75"></td><td><pre>	req.Header.Set("sec-ch-ua-platform", `"Windows"`<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="76"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"sec-fetch-dest"</span><span class="token punctuation">,</span> <span class="token string">"empty"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="77"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"sec-fetch-mode"</span><span class="token punctuation">,</span> <span class="token string">"cors"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="78"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"sec-fetch-site"</span><span class="token punctuation">,</span> <span class="token string">"cross-site"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="79"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"user-agent"</span><span class="token punctuation">,</span> <span class="token string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.82"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="80"></td><td><pre>	req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"x-authorization"</span><span class="token punctuation">,</span> <span class="token string">"token:xxxx"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="81"></td><td><pre>	resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="82"></td><td><pre>	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="84"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="85"></td><td><pre>	<span class="token keyword">defer</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="86"></td><td><pre>	bodyText<span class="token punctuation">,</span> err <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="87"></td><td><pre>	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="88"></td><td><pre>		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="89"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="90"></td><td><pre>	<span class="token keyword">if</span> resp<span class="token punctuation">.</span>StatusCode <span class="token operator">!=</span> <span class="token number">200</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="91"></td><td><pre>		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"bad StatusCode"</span><span class="token punctuation">,</span> resp<span class="token punctuation">.</span>StatusCode<span class="token punctuation">,</span> <span class="token string">"body"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>bodyText<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="92"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>	<span class="token keyword">var</span> dictResponse DictResponse</pre></td></tr><tr><td data-num="94"></td><td><pre>	err <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>bodyText<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dictResponse<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="95"></td><td><pre>	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="96"></td><td><pre>		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="97"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="98"></td><td><pre>	<span class="token comment">//fmt.Printf("%+v\n", dictResponse)</span></pre></td></tr><tr><td data-num="99"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token string">"UK:"</span><span class="token punctuation">,</span> dictResponse<span class="token punctuation">.</span>Dictionary<span class="token punctuation">.</span>Prons<span class="token punctuation">.</span>En<span class="token punctuation">,</span> <span class="token string">"US:"</span><span class="token punctuation">,</span> dictResponse<span class="token punctuation">.</span>Dictionary<span class="token punctuation">.</span>Prons<span class="token punctuation">.</span>EnUs<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="100"></td><td><pre>	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> item <span class="token operator">:=</span> <span class="token keyword">range</span> dictResponse<span class="token punctuation">.</span>Dictionary<span class="token punctuation">.</span>Explanations <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="101"></td><td><pre>		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="102"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="103"></td><td><pre>	<span class="token comment">//fmt.Printf("%s\n", bodyText)</span></pre></td></tr><tr><td data-num="104"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现自动选课</title>
    <url>/2023/02/15/python%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%80%89%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="python实现自动选课"><a class="anchor" href="#python实现自动选课">#</a> python 实现自动选课</h1>
<p>主要利用 selenium 与 ddddocr 库实现了对南大选课系统已收藏课程的自动化选择， 频率约为每两秒一次。实际测试中在一天时间内抢到了三门通识与两次近代史。</p>
<p><span id="more"></span></p>
<p>驱动这个项目动力来自于南大选课系统的落后。在开放选课的前一分钟 mikeMao 点击了一下刷新按钮，然后当 mikeMao 看到选课界面时已经是十分钟以后了。他没有任何体育课，也没有抢到近代史（因为他上学期为了逃离黑榜退掉了近代史），并且只中了一门必中的通识课！如果只靠蹲，mikeMao 这学期的课表可能会爆炸，于是 mikeMao 吐槽能否开发一个自动选课脚本，他的室友 stonerXiao 花了两小时写了一个可以使用的抢课脚本，mikeMao 获得了源码。但是他觉得一些地方写的不是很好，于是第二天上课（两点的课，两点零一群里通知老师有事不来了），他就动手改了一遍，借鉴了 stonerXiao 的刷新思路，mikeMao 几乎重写了一份代码。并在接下来的一天内塞满了课表。</p>
<p>源码</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> By</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ui <span class="token keyword">import</span> WebDriverWait</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>edge<span class="token punctuation">.</span>options <span class="token keyword">import</span> Options</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">import</span> time</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">import</span> ddddocr</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">import</span> traceback</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment"># 使用须知 需要安装：selenium 与 ddddorc 库 edge 浏览器及对应版本的驱动程序 并且参照注释对下面源码进行改动 将想选的课收藏</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># 可能不明原因退出或报错 可能是收藏被吞了（重新收藏一下） 或者网络波动（重启程序即可）</span></pre></td></tr><tr><td data-num="11"></td><td><pre>username <span class="token operator">=</span> <span class="token string">""</span>  <span class="token comment"># 添加用户名</span></pre></td></tr><tr><td data-num="12"></td><td><pre>password <span class="token operator">=</span> <span class="token string">""</span>  <span class="token comment"># 添加密码</span></pre></td></tr><tr><td data-num="13"></td><td><pre>url <span class="token operator">=</span> <span class="token string">"https://xk.nju.edu.cn/xsxkapp/sys/xsxkapp/*default/index.do"</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>login_button <span class="token operator">=</span> <span class="token string">"/html/body/div[1]/article/section/div[4]/div[1]/button"</span></pre></td></tr><tr><td data-num="16"></td><td><pre>start <span class="token operator">=</span> <span class="token string">"/html/body/div[1]/article/section/div[4]/div[2]/button"</span></pre></td></tr><tr><td data-num="17"></td><td><pre>favorite <span class="token operator">=</span> <span class="token string">"/html/body/div[1]/header/div[2]/ul/li[8]/a"</span></pre></td></tr><tr><td data-num="18"></td><td><pre>special <span class="token operator">=</span> <span class="token string">"/html/body/div[1]/header/div[2]/ul/li[1]/a"</span>  <span class="token comment"># for refresh</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>select <span class="token operator">=</span> <span class="token string">"/html/body/div[1]/article/div[2]/div[2]/table/tbody/tr[&#123;&#125;]/td[8]/a[2]"</span></pre></td></tr><tr><td data-num="21"></td><td><pre>confirm <span class="token operator">=</span> <span class="token string">"/html/body/div[3]/div[2]/div[2]/div[1]"</span></pre></td></tr><tr><td data-num="22"></td><td><pre>confirm_ <span class="token operator">=</span> <span class="token string">"/html/body/div[3]/div[2]/div[2]/div"</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>course_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment"># 识别验证码</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">def</span> <span class="token function">Identify_verifi_code</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    img <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> <span class="token string">'//*[@id="vcodeImg"]'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    img<span class="token punctuation">.</span>screenshot<span class="token punctuation">(</span><span class="token string">'vcode.png'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    ocr <span class="token operator">=</span> ddddocr<span class="token punctuation">.</span>DdddOcr<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'vcode.png'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        img_bytes <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    res <span class="token operator">=</span> ocr<span class="token punctuation">.</span>classification<span class="token punctuation">(</span>img_bytes<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">return</span> res</pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token keyword">def</span> <span class="token function">login</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token comment"># driver.maximize_window ()  # 将窗口最大化</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    verifi_code <span class="token operator">=</span> Identify_verifi_code<span class="token punctuation">(</span>driver<span class="token punctuation">)</span>  <span class="token comment"># 识别验证码</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token comment"># 找到登录框 输入账号密码</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">'loginName'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>username<span class="token punctuation">)</span>  <span class="token comment"># 输入用户名</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">'loginPwd'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>password<span class="token punctuation">)</span>  <span class="token comment"># 输入密码</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">'verifyCode'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>verifi_code<span class="token punctuation">)</span>  <span class="token comment"># 输入验证码</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre>    wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 10 秒内每隔 500 毫秒扫描 1 次页面变化，当出现指定的元素后结束。</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> driver<span class="token punctuation">:</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> login_button<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> login_button<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 点击登录</span></pre></td></tr><tr><td data-num="49"></td><td><pre></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="52"></td><td><pre>            verifi_code <span class="token operator">=</span> Identify_verifi_code<span class="token punctuation">(</span>driver<span class="token punctuation">)</span>  <span class="token comment"># 识别验证码</span></pre></td></tr><tr><td data-num="53"></td><td><pre>            driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">'verifyCode'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="54"></td><td><pre>            driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">'verifyCode'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>verifi_code<span class="token punctuation">)</span>  <span class="token comment"># 输入验证码</span></pre></td></tr><tr><td data-num="55"></td><td><pre>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="56"></td><td><pre>            wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 10 秒内每隔 500 毫秒扫描 1 次页面变化，当出现指定的元素后结束。</span></pre></td></tr><tr><td data-num="57"></td><td><pre>            wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> driver<span class="token punctuation">:</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> login_button<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre>            driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> login_button<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 点击登录</span></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token keyword">except</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="60"></td><td><pre>        <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre></pre></td></tr><tr><td data-num="62"></td><td><pre>    wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment"># 20 秒内每隔 500 毫秒扫描 1 次页面变化，当出现指定的元素后结束。</span></pre></td></tr><tr><td data-num="63"></td><td><pre>    wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> driver<span class="token punctuation">:</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre>    driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="65"></td><td><pre></pre></td></tr><tr><td data-num="66"></td><td><pre></pre></td></tr><tr><td data-num="67"></td><td><pre><span class="token keyword">def</span> <span class="token function">is_Login</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="68"></td><td><pre>    <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="69"></td><td><pre>        driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">'loginName'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="70"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">False</span></pre></td></tr><tr><td data-num="71"></td><td><pre>    <span class="token keyword">except</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="72"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">True</span></pre></td></tr><tr><td data-num="73"></td><td><pre></pre></td></tr><tr><td data-num="74"></td><td><pre></pre></td></tr><tr><td data-num="75"></td><td><pre><span class="token keyword">def</span> <span class="token function">start_select</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="76"></td><td><pre>    <span class="token keyword">if</span> is_Login<span class="token punctuation">(</span>driver<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="77"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">False</span></pre></td></tr><tr><td data-num="78"></td><td><pre>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment"># 20 秒内每隔 500 毫秒扫描 1 次页面变化，当出现指定的元素后结束。</span></pre></td></tr><tr><td data-num="80"></td><td><pre>    wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> driver<span class="token punctuation">:</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> favorite<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="81"></td><td><pre>    driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> favorite<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="82"></td><td><pre></pre></td></tr><tr><td data-num="83"></td><td><pre>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="84"></td><td><pre>    course_board <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>CLASS_NAME<span class="token punctuation">,</span> <span class="token string">'course-body'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="85"></td><td><pre>    tr_list <span class="token operator">=</span> course_board<span class="token punctuation">.</span>find_elements<span class="token punctuation">(</span>By<span class="token punctuation">.</span>CLASS_NAME<span class="token punctuation">,</span> <span class="token string">'course-tr '</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="86"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'已收藏课程：'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="87"></td><td><pre>    <span class="token keyword">for</span> tr <span class="token keyword">in</span> tr_list<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="88"></td><td><pre>        wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>tr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="89"></td><td><pre>        wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> tr<span class="token punctuation">:</span> tr<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> <span class="token string">'./td[2]'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="90"></td><td><pre>        course_name <span class="token operator">=</span> tr<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> <span class="token string">'./td[2]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text</pre></td></tr><tr><td data-num="91"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span>course_name<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"\n"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="92"></td><td><pre>    count <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="93"></td><td><pre>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="94"></td><td><pre>        count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="95"></td><td><pre>        <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="96"></td><td><pre>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'已尝试次数：'</span> <span class="token operator">+</span> count<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="97"></td><td><pre>            <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%Y-%m-%d %H:%M:%S'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="98"></td><td><pre></pre></td></tr><tr><td data-num="99"></td><td><pre>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="100"></td><td><pre>        course_board <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>CLASS_NAME<span class="token punctuation">,</span> <span class="token string">'course-body'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="101"></td><td><pre>        tr_list <span class="token operator">=</span> course_board<span class="token punctuation">.</span>find_elements<span class="token punctuation">(</span>By<span class="token punctuation">.</span>CLASS_NAME<span class="token punctuation">,</span> <span class="token string">'course-tr '</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="102"></td><td><pre>        <span class="token keyword">for</span> tr <span class="token keyword">in</span> tr_list<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="103"></td><td><pre>            wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>tr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="104"></td><td><pre>            wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> tr<span class="token punctuation">:</span> tr<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> <span class="token string">'./td[8]/a[2]'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="105"></td><td><pre></pre></td></tr><tr><td data-num="106"></td><td><pre>            course_name <span class="token operator">=</span> tr<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> <span class="token string">'./td[2]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text</pre></td></tr><tr><td data-num="107"></td><td><pre>            select_button <span class="token operator">=</span> tr<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> <span class="token string">'./td[8]/a[2]'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="108"></td><td><pre>            select_button<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="109"></td><td><pre>            <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="110"></td><td><pre>                driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> confirm<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="111"></td><td><pre>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"选课成功！"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="112"></td><td><pre>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已成功选中&#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>course_name<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="113"></td><td><pre>                course_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>course_name<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="114"></td><td><pre>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"确认中"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="115"></td><td><pre>                wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 20 秒内每隔 500 毫秒扫描 1 次页面变化，当出现指定的元素后结束。</span></pre></td></tr><tr><td data-num="116"></td><td><pre>                wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> driver<span class="token punctuation">:</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> confirm_<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="117"></td><td><pre>                driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> confirm_<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="118"></td><td><pre>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"确认成功!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="119"></td><td><pre>            <span class="token keyword">except</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="120"></td><td><pre>                <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="121"></td><td><pre></pre></td></tr><tr><td data-num="122"></td><td><pre>        wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 10 秒内每隔 500 毫秒扫描 1 次页面变化，当出现指定的元素后结束。</span></pre></td></tr><tr><td data-num="123"></td><td><pre>        wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> driver<span class="token punctuation">:</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> special<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="124"></td><td><pre>        driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> special<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="125"></td><td><pre></pre></td></tr><tr><td data-num="126"></td><td><pre>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="127"></td><td><pre>        wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 10 秒内每隔 500 毫秒扫描 1 次页面变化，当出现指定的元素后结束。</span></pre></td></tr><tr><td data-num="128"></td><td><pre>        wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span><span class="token keyword">lambda</span> driver<span class="token punctuation">:</span> driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> favorite<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="129"></td><td><pre>        driver<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> favorite<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="130"></td><td><pre></pre></td></tr><tr><td data-num="131"></td><td><pre></pre></td></tr><tr><td data-num="132"></td><td><pre><span class="token keyword">def</span> <span class="token function">working</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="133"></td><td><pre>    options <span class="token operator">=</span> Options<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="134"></td><td><pre>    <span class="token comment"># 关闭沙盒启动 把下面两行注释掉 会出现浏览器界面 建议注释掉看看能不能运行 可以再取消注释</span></pre></td></tr><tr><td data-num="135"></td><td><pre>    <span class="token comment">#options.add_argument('--no-sandbox')</span></pre></td></tr><tr><td data-num="136"></td><td><pre>    <span class="token comment">#options.add_argument("--headless")</span></pre></td></tr><tr><td data-num="137"></td><td><pre></pre></td></tr><tr><td data-num="138"></td><td><pre>    driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Edge<span class="token punctuation">(</span>executable_path<span class="token operator">=</span><span class="token string">"msedgedriver.exe"</span><span class="token punctuation">,</span> options<span class="token operator">=</span>options<span class="token punctuation">)</span>  <span class="token comment"># executable_path 改成下载的 edge 驱动程序路径</span></pre></td></tr><tr><td data-num="139"></td><td><pre>    driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="140"></td><td><pre></pre></td></tr><tr><td data-num="141"></td><td><pre>    <span class="token comment"># 登录并查询</span></pre></td></tr><tr><td data-num="142"></td><td><pre>    <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="143"></td><td><pre>        login<span class="token punctuation">(</span>driver<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="144"></td><td><pre>        start_select<span class="token punctuation">(</span>driver<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="145"></td><td><pre>    <span class="token keyword">except</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="146"></td><td><pre>        traceback<span class="token punctuation">.</span>print_exc<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="147"></td><td><pre>    <span class="token keyword">finally</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="148"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已选到如下课程:"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="149"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span>course_list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="150"></td><td><pre>        driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="151"></td><td><pre></pre></td></tr><tr><td data-num="152"></td><td><pre></pre></td></tr><tr><td data-num="153"></td><td><pre><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="154"></td><td><pre>    working<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python 爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>nova——高考网站学校名称爬取</title>
    <url>/2023/03/16/nova%E2%80%94%E2%80%94%E9%AB%98%E8%80%83%E7%BD%91%E7%AB%99%E5%AD%A6%E6%A0%A1%E5%90%8D%E7%A7%B0%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<h1 id="nova项目-高考网站学校名称爬取"><a class="anchor" href="#nova项目-高考网站学校名称爬取">#</a> nova 项目 - 高考网站学校名称爬取</h1>
<p>任务：在高考特殊类型招生报名网站中爬取全中国的中学名称</p>
<p>但是遭遇了强大的反爬措施 遂把失败经历记录如下</p>
<p><span id="more"></span></p>
<p>首先使用 selenium 不加任何反爬措施登录网站试试：</p>
<p>发现第一关就过不了</p>
<p><img data-src="image-20230318120750666.png" alt="image-20230318120750666"></p>
<p>请求显示 400 bad request 表明我们的请求被识别为非法的请求</p>
<p>在控制台输入  <code>window.navigator.webdriver</code></p>
<p>显示结果：</p>
<p><img data-src="image-20230318120845415.png" alt="image-20230318120845415"></p>
<p>间接地表示了你使用了 selenium 等自动化工具</p>
<h2 id="尝试方案一加入配置"><a class="anchor" href="#尝试方案一加入配置">#</a> 尝试方案一 (加入配置)：</h2>
<p>在 stackoverflow 搜索 selenium 400 bad request</p>
<p>有人提供了解决方案 :<img data-src="image-20230318122455280.png" alt="image-20230318122455280"></p>
<p>在代码中加入：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>edge_options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--disable-blink-features=AutomationControlled"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>这个配置可以去除 webdriver 的一些特征 但是在这个网站中还是失败</p>
<p>在控制台输入  <code>window.navigator.webdriver</code>   仍然显示 true，说明特征没隐藏完</p>
<h2 id="尝试方案二注入js代码"><a class="anchor" href="#尝试方案二注入js代码">#</a> 尝试方案二 (注入 JS 代码)：</h2>
<p>加入代码如下：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>driver<span class="token punctuation">.</span>execute_cdp_cmd<span class="token punctuation">(</span><span class="token string">"Page.addScriptToEvaluateOnNewDocument"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token string">"source"</span><span class="token punctuation">:</span> <span class="token triple-quoted-string string">"""</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Object.defineProperty(navigator, 'webdriver', &#123;</pre></td></tr><tr><td data-num="4"></td><td><pre>      get: () => false</pre></td></tr><tr><td data-num="5"></td><td><pre>    &#125;)</pre></td></tr><tr><td data-num="6"></td><td><pre>  """</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul>
<li>
<p>cdp (Chrome Devtools Protocol) 命令 通过 CDP, 可以检查 / 调试 / 监听网络流量，</p>
</li>
<li>
<p>Page.addScriptToEvaluateOnNewDocument：在浏览器启动之前执行给定的 JS 脚本</p>
</li>
<li>
<p>Object.defineProperty：JS 语法，直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象（代码中是将  <code>navigator.webdriver</code>  设置为  <code>false</code> ）</p>
</li>
</ul>
<p>结果如下： 可以看到 webdriver 的一些特征确实被隐藏了</p>
<p><img data-src="image-20230318124126335.png" alt="image-20230318124126335"></p>
<p>但是页面仍然一片空白 请求包仍然是 400 bad request</p>
<h2 id="思考一"><a class="anchor" href="#思考一">#</a> 思考一：</h2>
<p>上面的方法都在尝试隐藏某些你在使用爬虫的痕迹 部分网站检测不会那么深 但是使用爬虫总会留下痕迹</p>
<p>selenium 启动的浏览器 ，有几十个特征可以被检测到</p>
<p>有一个网站：<span class="exturl" data-url="aHR0cHM6Ly9ib3Quc2Fubnlzb2Z0LmNvbS8=">https://bot.sannysoft.com/</span> 可以检测你的浏览指纹</p>
<p>使用无头浏览器直接打开这个网站并截图：</p>
<p><img data-src="image-20230318130242034.png" alt="image-20230318130242034"></p>
<p>标红的都是未通过的测试</p>
<p>用刚刚尝试的方法 get 这个网站 好了很多 但仍显示未通过爬虫检测</p>
<p><img data-src="image-20230318130449697.png" alt></p>
<p>正常浏览器打开：</p>
<p><img data-src="image-20230318125152944.png" alt></p>
<h2 id="尝试方案三更强大的js注入"><a class="anchor" href="#尝试方案三更强大的js注入">#</a> 尝试方案三 (更强大的 JS 注入):</h2>
<p>方案二的 js 代码还是太简单了，只能隐藏一个特定的特征（虽然这个特征比较常用）</p>
<p>在网上看看有没有更专业的开发者开发出来的更强大的 js 代码：</p>
<p>找到了一份  <strong>stealth.min.js</strong></p>
<p>那么，这个 <code>stealth.min.js</code>  文件是怎么来的呢？这就要说到 <code>pyppeteer</code>  (一个与 selenium 同类的爬虫库) 了。，Python 版本的 <code>pyppeteer</code>  已经很久没有人维护了，但是 Node.js 版本的  <code>puppeteer</code>  持续有人维护，并且在持续更新，生态也越来越好。</p>
<p>有开发者给 puppeteer 写了一套插件，叫做 <code>puppeteer-extra</code> 。其中，就有一个插件叫做<strong> puppeteer-extra-plugin-stealth</strong>。这个东西，就来专门用来让 puppeteer 隐藏模拟浏览器的指纹特征。</p>
<p>那么，我们用 Python  selenium 的人怎么办呢？实际上也有办法。就是把其中的隐藏特征的脚本提取出来，做成一个单独的 js 文件。然后让 Selenium 在打开任意网页之前，先运行一下这个 js 文件里面的内容。</p>
<p>puppeteer-extra-plugin-stealth 的作者还写了另外一个工具，叫做<strong> extract-stealth-evasions</strong>。这个东西就是用来生成 <code>stealth.min.js</code>  文件的。</p>
<p>首先安装 Node.js，然后安装 Npm，接着运行如下命令：</p>
<p><code>npx extract-stealth-evasions </code></p>
<p>就能在文件夹下生成一个 stealth.min.js 文件了</p>
<p>使用 stealth.min.js 如下：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'stealth.min.js'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    js <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>driver<span class="token punctuation">.</span>execute_cdp_cmd<span class="token punctuation">(</span><span class="token string">"Page.addScriptToEvaluateOnNewDocument"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"source"</span><span class="token punctuation">:</span> js</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>再登录刚才的网站：</p>
<p><img data-src="image-20230318132200964.png" alt></p>
<p>通过此网站的测试</p>
<p>再尝试我们要爬取的网站 请求包仍然是 400 bad request</p>
<p>猜测失败原因是反爬措施太强大了 不管怎么做都会留下使用爬虫的痕迹</p>
<h2 id="尝试方案四连接手动打开的浏览器"><a class="anchor" href="#尝试方案四连接手动打开的浏览器">#</a> 尝试方案四（连接手动打开的浏览器）：</h2>
<p>既然使用驱动程序的 selenium 总会留下特征，手动打开的浏览器不会被检测到，那我能不能从源头解决问题，先手动打开一个浏览器，然后尝试用 selenium 接管它呢。</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>cmd1 <span class="token operator">=</span> <span class="token string">'cd "C:\Program Files (x86)\Microsoft\Edge\Application" &amp;&amp; start .\msedge.exe --remote-debugging-port=9225 '</span> \</pre></td></tr><tr><td data-num="2"></td><td><pre>           <span class="token string">'--user-data-dir="C:\selenium\EdgeProfile" '</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>cmd1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    edge_options <span class="token operator">=</span> Options<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    edge_options<span class="token punctuation">.</span>add_experimental_option<span class="token punctuation">(</span><span class="token string">"debuggerAddress"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:9225"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>上面代码在命令行中用调试模式打开了 Edge 浏览器，并且开放了一个远程调试端口，我们再使用 selenium 连接上这个端口，取得控制权。</p>
<p>在 get 一下目标网址，并登录：</p>
<p><img data-src="image-20230318134112693.png" alt></p>
<p>终于能进来了。</p>
<p>要爬取的中学名称信息分为四个下拉列表：</p>
<p><img data-src="image-20230318134447273.png" alt="image-20230318134447273"></p>
<p>当选中了上一级下拉列表的某个选项后，服务端会返回一个 ajax 包，并更新下一级下拉列表里的内容，在这里仍然遇到问题。</p>
<p>如果用 selenium 选择了某一个选项，发现后面的下拉列表并没有更新。</p>
<p>演示一下。</p>
<p>通过检查工具抓包，发现还是 400 bad request，猜测爬虫还是被检测出来了。</p>
<h2 id="尝试方案五模拟真实环境"><a class="anchor" href="#尝试方案五模拟真实环境">#</a> 尝试方案五 (模拟真实环境)</h2>
<p>猜测：爬虫遍历列表选项并点击的频率太快了，被识别出来非人工操作</p>
<p>在每次点击选项后都加上 time.sleep (1) 休眠一秒钟，仍然失败</p>
<h2 id="尝试方案六直接对ajax包的url发请求"><a class="anchor" href="#尝试方案六直接对ajax包的url发请求">#</a> 尝试方案六 (直接对 ajax 包的 url 发请求)</h2>
<p>一个 url 示例：</p>
<p><strong><span class="exturl" data-url="aHR0cHM6Ly9nYW9rYW8uY2hzaS5jb20uY24venpibS9xdWVyeVhqcy5hY3Rpb24/TFVWVndzODA9NUgyX1l0S2NmN0FCQXZhV00xVThCWjJJNFFWWHUuWlhuQ0RITUVsR0JKY0Vma3dxY0dWNDlIUzQ2d2FTOWQ5ZXk3eUlTZG5BOG95WUh6MkxTVkdJYnVHVEpRVXpBWjNaRUt0d3pKZ0NtSm5oMDNjNlhteVA2ZnVwdXVTUTN6elVOdlFUUndTX1cxeTZtY055TEhDdl82czhIX1IzY2xRYUk3czN4OG5yNFg3NVdDUUFCbFRTWURTMnhtU3p6MnczQ21fMDh6bDJ3Ymd1aTR2NjVCb2laMkw2c0hEYWdSWl95d3ZtTmpfLlg1SDlhbTYwYlpNMGpZaEtwQ19Fck9RcUxfdjhWRmgyN0plQ1g5YldSNW9JTTlRSjEyNldqTUdmM1NldzJTNjhzeFhUVHdmWG9NcTVULjE3WXdrbjRwZGlralZsUWhDc25jbGV4Z3cwaW94dVVjMTMwVEhVdFVQaEQudGx0M2pKYnp5WnpfU1pJLlhyTVJuU3ZWamdpcHBvWg==">https://gaokao.chsi.com.cn/zzbm/queryXjs.action?LUVVws80=5H2_YtKcf7ABAvaWM1U8BZ2I4QVXu.ZXnCDHMElGBJcEfkwqcGV49HS46waS9d9ey7yISdnA8oyYHz2LSVGIbuGTJQUzAZ3ZEKtwzJgCmJnh03c6XmyP6fupuuSQ3zzUNvQTRwS_W1y6mcNyLHCv_6s8H_R3clQaI7s3x8nr4X75WCQABlTSYDS2xmSzz2w3Cm_08zl2wbgui4v65BoiZ2L6sHDagRZ_ywvmNj_.X5H9am60bZM0jYhKpC_ErOQqL_v8VFh27JeCX9bWR5oIM9QJ126WjMGf3Sew2S68sxXTTwfXoMq5T.17Ywkn4pdikjVlQhCsnclexgw0ioxuUc130THUtUPhD.tlt3jJbzyZz_SZI.XrMRnSvVjgippoZ</span></strong></p>
<p>对要携带的参数的 key 值和 value 进行了加密 找不到规律 也失败</p>
<h2 id="尝试方案七undetected_driver"><a class="anchor" href="#尝试方案七undetected_driver">#</a> 尝试方案七 (undetected_driver)</h2>
<p>向老师求助后得到的方案</p>
<p>undetected_driver 也是 selenium 提供的一个模块 可以防止浏览器特征被识别，并且可以根据浏览器版本自动下载驱动。</p>
<p>可以过登录 但是发来的 ajax 请求包还是 400 bad request</p>
<h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2>
<p>猜测失败原因：还是有没有隐藏好的特征被反爬措施检查到了。</p>
<p>查找替代方案：在搜索引擎搜索全国中学名称，有结果，但是数据比较老，而且权威性无法保证。在中国教育部官网搜索没有结果。可能需要在同类的政府网站填写个人信息的时候可以找到。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python 爬虫 计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生-docker入门</title>
    <url>/2023/06/27/%E4%BA%91%E5%8E%9F%E7%94%9F-docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="云原生-docker-k8s-springboot"><a class="anchor" href="#云原生-docker-k8s-springboot">#</a> 云原生 docker + k8s + springboot</h1>
<h2 id="云原生的本质"><a class="anchor" href="#云原生的本质">#</a> 云原生的本质</h2>
<p>根据微服务将应用进行细分，将每一部分打包放入对应的容器，动态统筹管理容器，实现资源利用最大化。</p>
<h2 id="什么是docker"><a class="anchor" href="#什么是docker">#</a> 什么是 Docker</h2>
<p>Docker 是 Docker 公司开源的一种最流行的容器实现方案，极大方便了应用服务部署。</p>
<p>Docker 可以将应用、配置、和环境打包，形成了一个独立的类似于 iOS APP 形式的 <strong>应用</strong>，此应用可以直接分发到任意一个支持 Docker 的环境中，通过简单的命令即可运行。</p>
<p>Docker 使得容器化技术使用非常方便，极大地推进了容器行业的发展与容器技术标准化。</p>
<blockquote>
<p>docker 口号： build once, run anywhere</p>
</blockquote>
<h2 id="docker的优势"><a class="anchor" href="#docker的优势">#</a> Docker 的优势</h2>
<ul>
<li>环境一致性</li>
<li>资源独立与隔离</li>
<li>轻量化</li>
</ul>
<h2 id="通过docker容器配置nginx静态网页"><a class="anchor" href="#通过docker容器配置nginx静态网页">#</a> 通过 docker 容器配置 Nginx 静态网页</h2>
<p>从 docker 仓库下载具有默认 Nginx 配置的容器：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> pull nginx</pre></td></tr></table></figure><p>现在有了镜像，但是镜像和容器的关系就像类和实例，要真正运行还要创建一个容器：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">--name</span> docker-nginx <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 nginx</pre></td></tr></table></figure><p>参数说明：</p>
<ul>
<li>run 是创建新容器的命令</li>
<li>--name 标志是指定容器名称的方式。如果为空，将分配一个生成的名称。</li>
<li>-p 以 - p local-machine-port:internal-container-port 的格式指定公开的端口，比如这里将容器中的端口：80 映射到宿主机的端口：80</li>
<li>nginx 是镜像名称，也就是刚刚 pull 下来的镜像，没有 tag 表示用最新 (latest)</li>
</ul>
<p>此时在浏览器输入本地 ip 可看到 nginx 默认登录界面：</p>
<p><img data-src="image-20230627181050252.png" alt="image-20230627181050252"></p>
<p>此时必须用 CTRL+c 在命令行中停止容器运行。可以使用 docker ps -a 查看此时的容器状态。</p>
<p><img data-src="image-20230627181625674.png" alt="image-20230627181625674"></p>
<p>可以使用</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-vf</span> docker-nginx</pre></td></tr></table></figure><p>删除现有的 dorker-nginx 容器。</p>
<h2 id="daemon模式下运行"><a class="anchor" href="#daemon模式下运行">#</a> Daemon 模式下运行</h2>
<p>上面启动的容器还未与 terminal 分离，必须手动 CTRL+c 停止运行 才能输入后续指令，而在 daemon 模式下我们可以将容器交给 Daemon 进程，即一个守护进程托管，让其在后台运行。</p>
<p>创建一个保存网页内容的文件夹：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/docker-nginx/html</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token builtin class-name">cd</span> ~/docker-nginx/html</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">vim</span> index.html</pre></td></tr></table></figure><p>编写网页内容：</p>
<figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Docker nginx Tutorial<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>this page is provided by nginx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>然后使用命令：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">--name</span> docker-nginx <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> ~/docker-nginx/html:/usr/share/nginx/html nginx</pre></td></tr></table></figure><p>参数说明：</p>
<ul>
<li>-v 标志开启挂载功能，: 的左侧是服务器（宿主机）上的位置：右侧是链接到的容器内的位置</li>
<li>-d 采用 daemon 模式</li>
<li><code>/usr/share/nginx/html</code>  是 nginx 服务器默认用于存储静态 HTML 网页和其他资源的位置，通常情况下会在这个目录中存放可由 Web 浏览器访问的 HTML 文件、CSS 文件、JavaScript 文件和图像文件等。</li>
</ul>
<p>结果：</p>
<p><img data-src="image-20230627183153353.png" alt="image-20230627183153353"></p>
<h2 id="使用dockerfile创建本地镜像"><a class="anchor" href="#使用dockerfile创建本地镜像">#</a> 使用 Dockerfile 创建本地镜像</h2>
<h3 id="什么是dockerfile"><a class="anchor" href="#什么是dockerfile">#</a> 什么是 Dockerfile</h3>
<p><img data-src="image-20230627190343246.png" alt="image-20230627190343246"></p>
<h3 id="使用dockerfile创建2048镜像并运行"><a class="anchor" href="#使用dockerfile创建2048镜像并运行">#</a> 使用 Dockerfile 创建 2048 镜像并运行</h3>
<p>Dockerfile 的内容如下：</p>
<figure class="highlight dockerfile"><figcaption data-lang="Docker"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Pull base image.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token instruction"><span class="token keyword">FROM</span> nginx:latest</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token instruction"><span class="token keyword">COPY</span> 2048-master /usr/share/nginx/html</span></pre></td></tr></table></figure><p>在 Dockerfile 的同级目录下存放了 2048-master 文件夹，其中包含了 2048 网页版的资源</p>
<p>使用命令</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> build <span class="token parameter variable">-t</span> my-2048 <span class="token builtin class-name">.</span></pre></td></tr></table></figure><p>创建一个名为 my-2048 的镜像 最后的。表示 Dockerfile 在当前目录下。</p>
<p>-t 指定镜像的名字</p>
<p>然后使用</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">--name</span> <span class="token number">2048</span> <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 my-2048</pre></td></tr></table></figure><p>创建并启动一个容器</p>
<p>此时打开 localhost：</p>
<p><img data-src="image-20230627191156151.png" alt="image-20230627191156151"></p>
<h2 id="docker镜像管理"><a class="anchor" href="#docker镜像管理">#</a> Docker 镜像管理</h2>
<p><img data-src="image-20230627192134665.png" alt="image-20230627192134665"></p>
<h2 id="docker容器管理"><a class="anchor" href="#docker容器管理">#</a> Docker 容器管理</h2>
<p><img data-src="image-20230627192437509.png" alt="image-20230627192437509"></p>
<h2 id="docker原理"><a class="anchor" href="#docker原理">#</a> Docker 原理</h2>
<h3 id="docker组成架构"><a class="anchor" href="#docker组成架构">#</a> Docker 组成架构</h3>
<p>Docker 采用 C/S 架构，client 通过接口与 Server 进程通信实现容器的构建，运行和发布。</p>
<p>Docker 由五个部分组成</p>
<p>－<strong>Docker Client</strong> <strong>客户端</strong>，负责向服务端（Docker Daemon 守护进程）发起请求</p>
<p>－<strong>Docker Daemon</strong> <strong>守护进程</strong>，负责 从 Docker Registry 下载 Docker 镜像和通过 Docker 镜像 启动 Docker 容器</p>
<p>－<strong>Docker Registry</strong> <strong>仓库</strong>，负责存储 Docker 镜像</p>
<p>－<strong>Docker Container</strong> <strong>容器</strong></p>
<p>－<strong>Docker Image</strong> <strong>镜像</strong></p>
<p><img data-src="image-20230628141358473.png" alt="image-20230628141358473"></p>
<h2 id="docker运行容器流程"><a class="anchor" href="#docker运行容器流程">#</a> Docker 运行容器流程</h2>
<ol>
<li>
<p>Docker Client 执行 docker run，Docker Daemon 收到来自 client 的请求；</p>
</li>
<li>
<p>Docker Daemon 优先查找本地镜像，如果本地没有，Docker daemon 会从远端镜像仓库拉取所需镜像；</p>
</li>
<li>
<p>启动 Linux Namespace 配置，设置指定的 Cgroups 参数，挂载 rootfs（容器镜像），切换进程的根目录；</p>
</li>
<li>
<p>容器运行。</p>
</li>
</ol>
<p><img data-src="image-20230628141534884.png" alt="image-20230628141534884"></p>
<h2 id="docker容器文件系统"><a class="anchor" href="#docker容器文件系统">#</a> Docker 容器文件系统</h2>
<p>Docker 容器的 rootfs 使用的是 UnionFS（联合文件系统）。</p>
<p>UnionFS 是通过联合挂载多个文件目录得到的一个完整的文件系统。容器 rootfs 看起来是一个可读、可写的具备完整功能的独立文件系统，但实际上由多层只读层和一个专属于该容器的读写层联合挂载而成。</p>
<p>Linux 中支持的 UnionFS 实现有 overlay2、aufs、btrfs，其中最常用的就是 overlay2。</p>
<p><img data-src="image-20230628145756899.png" alt="image-20230628145756899"></p>
<p>在准备容器 rootfs 时联合挂载用到的多层目录是哪来的呢？</p>
<p>－<strong>读写层</strong>，每个容器都有自己专属的读写层，该层由 docker 在创建此容器时创建的。</p>
<p>－<strong>只读层</strong>，每个容器的 rootfs 都会包含好几层只读层，该层由 docker 在拉取镜像时将镜像中的各层解压到 docker 的数据目录得到的。</p>
<p>总结</p>
<p>－容器镜像与容器 rootfs 的关联</p>
<p>Docker 拉取镜像解压到 docker 数据目录后得到只读层；</p>
<p>Docker 创建容器时使用数据目录中的读写层联合挂载得到容器 rootfs</p>
<p><img data-src="image-20230628145830246.png" alt="image-20230628145830246"></p>
<h1 id="kubernetes"><a class="anchor" href="#kubernetes">#</a> kubernetes</h1>
<h2 id="什么是kubernetes"><a class="anchor" href="#什么是kubernetes">#</a> 什么是 kubernetes</h2>
<p>kubernetes 是开源的容器集群管理项目，诞生于 2014 年，有 Google 公司发起，试图为基于容器的应用部署和管理打造一个强大引擎。使用 go 语言构造。</p>
<ul>
<li>一个基于容器技术的分布式架构领先方案</li>
<li>一个生产级容器编排工具</li>
<li>一个完备的分布式学习通支撑平台</li>
</ul>
<p>竞品： Mesos， Docker Swarm</p>
<p>我们在应用容器化的过程中会涉及到封装、调度单容器，也会涉及到解决各个容器间的类型关系，比如 web 容器会涉及到与 DB 容器的交互，可以通过建立 “link” 来将 DB 容器中的信息注入到 web 容器中。但这样做的缺陷在于缺少普适性，随着系统的扩大，容器间的 “link” 会越来越复杂。</p>
<p>Kubernetes 的优势就在于：从设计之初就<strong>以统一的方式定义任务之间的各种关系</strong>， 并且为将来支持更多种类的关系留有余地，能够按照用户的意愿和整个系统的规则，完全自动化地处理好容器之间的各种关系，这个过程也就是<strong>编排</strong>。而其他很多集群管理项目（比如 Yarn、Mesos，以及 Swarm）擅长的，把一个容器按规则，放置在某个最佳节点上运行的功能则称为<strong>调度</strong>。</p>
<p>容器本质是进程，那 Kubernetes 作为具有普遍意义的容器编排工具，就是云操作系统。</p>
<p>理解 Kubernetes 设计理念是学习 Kubernetes 的前提。我们需要聚焦在两个问题：</p>
<p>l <strong>如何处理应用与应用之间的关系？</strong></p>
<p>l <strong>如何恰当的容器化一个应用？</strong></p>
<p>第一个问题，应用与应用之间的关系可以细化为容器间的关系，具体来说是两类：一类关系是 “紧密交互” 的，即：这些应用之间需要频繁交互、访问，或者会直接通过本地文件进行信息交换。Kubernetes 把这类关系涉及到的一组容器划分为一个 <strong>“ Pod ”</strong>（ Kuberntes 最小调度单位），在这里面可以进行高效信息交换。</p>
<p>另一类关系则是常见的应用间的普通访问，Kuberntes 通过定义 “<strong>服务对象</strong>” 来描述。比如 web 应用和数据库应用的交互，涉及到固定 IP 地址和端口以负载均衡的方式访问，就产生了 Service 对象来处理；加密授权的关系需求，则可由 Secret 对象解决等等。</p>
<p>第二个问题，以 Pod 为基础为解决不同的场景需求衍生出了不同的解决方案，也就是<strong>基于 Pod 改进后的对象资源，称为 “编排对象”</strong>。比如被称为 DaemonSet 的对象资源，它可以像守护进程一样在每个宿主机上有且只能有一个 pod 副本；再比如 CronJob ，它专门用来描述定时任务等等。</p>
<p>如下图所示，由 “Pod” 产生各类 “<strong>编排对象</strong>”，再为解决各种关系问题产生了类似 Service、Ingress 等 “<strong>服务对象</strong> ”。</p>
<p><img data-src="/image-20230629231456801.png" alt="image-20230629231456801"></p>
<h2 id="架构"><a class="anchor" href="#架构">#</a> 架构</h2>
<p><img data-src="image-20230723114238163.png" alt="image-20230723114238163"></p>
<p>k8s 有一个 Master 节点负责与用户的通信和管理工作节点等工作，而每一个工作节点 (Node 节点) 对应一个真实的物理机或虚拟机，承担工作负载，Node 负责监控并汇报容器的状态，同时根据 Master 的要求管理容器生命周期。</p>
<blockquote>
<p>master 节点组件</p>
<ul>
<li><strong>API Server</strong>。<strong>K8S 的请求入口服务</strong>。API Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活。</li>
<li><strong>Scheduler</strong>。<strong>K8S 所有 Worker Node 的调度器</strong>。当用户要部署服务时，Scheduler 会选择最合适的 Worker Node（服务器）来部署。</li>
<li><strong>Controller Manager</strong>。<strong>K8S 所有 Worker Node 的监控器</strong>。Controller Manager 有很多具体的 Controller，在文章 **<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9tZWRpdW0uY29tLyU0MGt1bWFyZ2F1cmF2MTI0Ny9jb21wb25lbnRzLW9mLWt1YmVybmV0ZXMtYXJjaGl0ZWN0dXJlLTZmZWVhNGQ1YzcxMg==">Components of Kubernetes Architecture</span>** 中提到的有 Node Controller、Service Controller、Volume Controller 等。Controller 负责监控和调整在 Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务。</li>
<li><strong>etcd</strong>。<strong>K8S 的存储服务</strong>。etcd 存储了 K8S 的关键配置和用户配置，K8S 中仅 API Server 才具备读写权限，其他组件必须通过 API Server 的接口才能读写数据（见 **<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy90aGVuZXdzdGFjay5pby9ob3ctZG9lcy1rdWJlcm5ldGVzLXdvcmsv">Kubernetes Works Like an Operating System</span>**）。				--zhihu</li>
</ul>
</blockquote>
<blockquote>
<p>node 节点组件</p>
<ul>
<li><strong>Kubelet</strong>。<strong>Worker Node 的监视器，以及与 Master Node 的通讯器</strong>。Kubelet 是 Master Node 安插在 Worker Node 上的 “眼线”，它会定期向 Worker Node 汇报自己 Node 上运行的服务的状态，并接受来自 Master Node 的指示采取调整措施。</li>
<li><strong>Kube-Proxy</strong>。<strong>K8S 的网络代理</strong>。私以为称呼为 Network-Proxy 可能更适合？Kube-Proxy 负责 Node 在 K8S 的网络通讯、以及对外部网络流量的负载均衡。</li>
<li><strong>Container Runtime</strong>。<strong>Worker Node 的运行环境</strong>。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine。大白话就是帮忙装好了 Docker 运行环境。</li>
<li><strong>Logging Layer</strong>。<strong>K8S 的监控状态收集器</strong>。私以为称呼为 Monitor 可能更合适？Logging Layer 负责采集 Node 上所有服务的 CPU、内存、磁盘、网络等监控项信息。</li>
<li><strong>Add-Ons</strong>。<strong>K8S 管理运维 Worker Node 的插件组件</strong>。有些文章认为 Worker Node 只有三大组件，不包含 Add-On，但笔者认为 K8S 系统提供了 Add-On 机制，让用户可以扩展更多定制化功能，是很不错的亮点。</li>
</ul>
</blockquote>
<h2 id="k8s优势"><a class="anchor" href="#k8s优势">#</a> k8s 优势</h2>
<ul>
<li>强大的容器编排能力</li>
<li>轻量级</li>
<li>开放开源</li>
<li>优秀的 API 设计</li>
<li>基于微服务模式的多层资源抽象模型</li>
<li>可扩展性好</li>
<li>自动化程度高</li>
<li>部署支持多种环境</li>
</ul>
<h2 id="k8s常用命令"><a class="anchor" href="#k8s常用命令">#</a> k8s 常用命令</h2>
<h3 id="createapply"><a class="anchor" href="#createapply">#</a> create/apply</h3>
<p><code>kubectl apply/create -f [FILE NAME]</code></p>
<p>kubectl create 属于</p>
<h3 id="get"><a class="anchor" href="#get">#</a> get</h3>
<p><code>kubectl get pods|replicationcontrollers|services|namespaces|nodes|...|events [options]</code></p>
<h3 id="describe"><a class="anchor" href="#describe">#</a> describe</h3>
<p>查看资源详细信息</p>
<h3 id="logs"><a class="anchor" href="#logs">#</a> logs</h3>
<p>查看 pod 内容器日志</p>
<h3 id="exec"><a class="anchor" href="#exec">#</a> exec</h3>
<p>在 pod 容器中执行命令</p>
<h3 id="edit"><a class="anchor" href="#edit">#</a> edit</h3>
<p>编辑资源</p>
<h3 id="delete"><a class="anchor" href="#delete">#</a> delete</h3>
<p>删除资源</p>
<h3 id="故障检测"><a class="anchor" href="#故障检测">#</a> 故障检测</h3>
<p>放张图备用</p>
<p><img data-src="v2-9437b19801b2a08dea506005a4dd2eb2_1440w.webp" alt="img"></p>
<h1 id="springboot-入门"><a class="anchor" href="#springboot-入门">#</a> Springboot 入门</h1>
<h2 id="特点"><a class="anchor" href="#特点">#</a> 特点</h2>
<ul>
<li>独立运行的 spring 项目     spring boot 可以以 jar 包的形式独立运行</li>
<li>内嵌 servlet 容器，应用无需打成 WAR 包。</li>
<li>提供 starter 简化 Maven 配置</li>
<li>提供了大量的自动配置</li>
<li>自带应用监控</li>
<li>无代码生成和 XML 配置</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>从数理逻辑本身到哥德尔不完备定理的一种证明方法</title>
    <url>/2023/11/17/%E4%BB%8E%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%9C%AC%E8%BA%AB%E5%88%B0%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>音乐能激发或抚慰情怀，绘画使人赏心悦目，诗歌能动人心弦，哲学使人获得智慧，科学可以改善物质生活，但数学能给予以上的一切。</p>
<p>​																																				-- 克莱因</p>
</blockquote>
<p><span id="more"></span></p>
<h2 id="对于数学和数理逻辑的思考"><a class="anchor" href="#对于数学和数理逻辑的思考">#</a> 对于数学和数理逻辑的思考</h2>
<p>谈到数学，我不禁想到一个经典的问题：数学是被人发现的，还是被人发明的？这好像已经迈入了哲学的范畴， 我有一个苹果，然后再有了一个苹果，于是共有 1+1=2 个苹果，这好像是想当然的，因为像苹果这类区限分明的自然事物是可以数的，人们发现自然物可以被计数，于是就有了数学中的加法。人们定义了 1 和 2，同时定义了加法的规则，于是有了 1+1=2，这样做是合理的，符合人类直觉的，并且与许多人们公认的规则结合在在一起建立了数学大厦，并且在几千年的人类文明进化史中没有出什么差错。我们今天坐在高楼大厦里，用着精密的手机，电脑，坐着高铁，飞机穿梭于世界各地。我们靠它们生存，但是我们如何保证高楼不会坍塌，坐的飞机不会坠落呢，因为我们有强大的 “武器” 依靠，即数学的证明。这些东西无一不是在图纸上被确定性的定义了材料和尺寸等规则，并经过了数学的验证，设计师拍着胸脯保证，在数学上已经验证过了，才最终被制造出来。高效运转的人类社会离不开数学，而数学大厦又建造在这些所谓的 “公理” 之上，而这些公理的正确性，如果靠的仅仅是我们人类的直觉，这不免让我有些发怵。** 直觉是靠的住的吗？** 在几何上，两个点可以唯一确定一条直线，二维平面内的两条直线不是平行就必定相交，所有的直角都相等。。。 这些都是不证自明的定理，很少有人会怀疑。但是我们知道，有些时候直觉是靠不住的，比如哥伦布环绕了地球一圈并返回到了起点，我们就理所应当的认为地球是圆的，因为排除了地球边缘是深不见底的深渊或者天圆地方等盛行的理论，但是我们很少想过，地球会不会是一个甜甜圈，会不会是一个莫比乌斯环？</p>
<p>但对于这些貌似是不证自明的定理，如果他们是不对的，那人类社会不可能高度发达，所以我倾向于认为数学是被人发现的，但我们常用的自然数，符号等属于我们发明的 “符号体系”，这些符号体系体现了自然界中某些本质，某些永远正确，客观存在的东西，这些东西就是数学。 有一点我们必须确定，不能对每一个数学结论都凭借直觉来确认，我们可以根据直觉判断自行车的轮子应当是圆的，但对于更复杂的东西好像就不行了，否则很可能会踩雷，导致某天某样东西突然崩塌，造成不可预计的后果，我们需要一些从正确的结论推导出新结论的东西，并且保证这个 “过程” 和这个 “过程” 的出发点是正确的，我觉得这就是数理逻辑研究的领域，数理逻辑研究的是数学本身，即 “数学的数学”。当然数理逻辑也有出发点，一些不需要证明就能被认为正确的东西，否则就会出现 “数学的数学的数学”，无限递归下去，这是很可笑的，但我们需要保障这些出发点尽可能少（减少出错的机会），并且不容置疑的正确。</p>
<h2 id="哥德尔不完备定理的出现"><a class="anchor" href="#哥德尔不完备定理的出现">#</a> 哥德尔不完备定理的出现</h2>
<p>在数理逻辑这个领域发展之初，数学家们为数学寻求坚实的基础：一系列基本的数学事实，或者说公理。它们既是一致的，即不会导致矛盾，同时也是完备的，以作为所有数学真理的基础。但是哥德尔发表的不完备定理彻底粉碎了这一梦想，这一定理简短又振聋发聩，大概意思是</p>
<p>——<strong> 每个无矛盾的数学系统都存在一些语句无法被证明（不完备的）。</strong></p>
<p>这意味着不存在一个对万事万物皆适用的数学理论，可证明性和正确性也无法统一。数学家可以证明的内容取决于他们的初始假设，而非所有结论所依据的基本事实（这个自然界本身）。这个定理引起了轩然大波，也产生了许多有趣的问题，对于这些问题的讨论，许多又进入到了哲学的领域，比如<strong>不完备定理依赖算术又说算术是不完备的，这不是循环论证吗？物理学需要数学，哥德尔不完备定理是不是意味着我们永远无法理解宇宙等</strong>。</p>
<h2 id="一个有趣的证明"><a class="anchor" href="#一个有趣的证明">#</a> 一个有趣的证明</h2>
<p>这个证明是在<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI3NTI4Nzk2"> (如何简单清晰地解释哥德尔不完备定理？ - 知乎 (zhihu.com)</span> 看到的</p>
<p>哥德尔的主要策略是把<strong>关于</strong>某个公理系统的语句映射到一个特定的系统<strong>内</strong>的语句，即映射到一个关于数字的语句。这个映射使公理系统能够有效地谈论自身。</p>
<p>这个过程的第一步是将任何可能的数学语句或一系列语句映射到一个被称为哥德尔数的唯一数字。</p>
<p>这个对哥德尔的方案略微修改后的版本是由欧内斯特・内格尔（Ernest Nagel）和詹姆士・纽曼（James Newman）在他们 1958 年出版的《<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFNSU5MyVBNSVFNSVCRSVCNyVFNSVCMCU5NCVFNyU5QSU4NCVFOCVBRiU4MSVFNiU5OCU4RSZhbXA7c2VhcmNoX3NvdXJjZT1FbnRpdHkmYW1wO2h5YnJpZF9zZWFyY2hfc291cmNlPUVudGl0eSZhbXA7aHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyJTNBJTIyYW5zd2VyJTIyJTJDJTIyc291cmNlSWQlMjIlM0ExMzQ2MDk3MjQ5JTdE">哥德尔的证明</span>》（《Gödel's Proof》）的书中提出的，始于用 12 个基本符号作为词汇来表达一系列基本公理。例如，用符号 ∃表示存在，用符号 + 表示加法。重要的是，符号 s 表示 “后继”，给出了表示特定数字的方法。例如， ss0 指的是 2 。</p>
<p>这 12 个符号被分配到了从 1 至 12 的哥德尔数。</p>
<p><img data-src="picture1.png" alt></p>
<p>下一步，用字母表示变量，从 xyz 开始，映射到大于 12 的素数（即 13,17,19 ）。</p>
<p>接下来，这些符号和变量的任意组合，即任何可以被构造的算术公式或公式序列，都将有自己的哥德尔数。</p>
<p>比如，考虑 0=0 。这个公式的三个符号对应的哥德尔数是 6,5,6 。哥德尔需要将这三个数字的序列改为一个唯一的数字，也就是其他符号序列不会生成的数字。 为此，他采用前三个质数（2,3,5 ），将每个符号的哥德尔数作为这个序列相同位置的指数，并将它们相乘。因此 0=0 变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup><mo>×</mo><msup><mn>3</mn><mn>5</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2^{6} \times 3^{5} \times 5^{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，即 243000000 。</p>
<p>该映射之所以有效，是因为没有两个公式会有相同的哥德尔数。 哥德尔数是整数，而整数仅以一种方式分解为质数。因此，243000000 的唯一质数分解是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup><mo>×</mo><msup><mn>3</mn><mn>5</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2^{6} \times 3^{5} \times 5^{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> ，这意味着只有一种可能的方法可以解码这个哥德尔数：公式 0=0。</p>
<p>哥德尔之后更进一步。数学证明是由一系列的公式组成的。因此，哥德尔也为每个公式序列赋予了唯一的哥德尔编号。在这种情况下，正如前面一样，他从质数列表开始，即 2,3,5 依此类推。 然后，他将公式的哥德尔数作为对应位置素数序列的指数（例如，若先出现 0=0 ，则为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>243000000</mn></msup><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">2^{243000000} \times ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span><span class="mord mtight">3</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>），然后将所有数相乘。</p>
<p><strong>算数元数学</strong></p>
<p>这么做真正的好处是，即使是<strong>关于</strong>算术公式的语句，也被称为元数学语句，也可以转换为以它们自身的哥德尔数所产生的公式。</p>
<p>首先考虑公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo><mo stretchy="false">(</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sim (0=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，意思是 “零不等于零”。这个公式显然的错误的。不过它依然有哥德尔数：2 的 1 次幂（符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> 的哥德尔数是 1），乘以 3 的 8 次幂（“左括号” 的哥德尔数是 8），依次类推，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mo>×</mo><msup><mn>3</mn><mn>8</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup><mo>×</mo><msup><mn>7</mn><mn>5</mn></msup><mo>×</mo><mn>1</mn><msup><mn>1</mn><mn>6</mn></msup><mo>×</mo><mn>1</mn><msup><mn>3</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2^1\times 3^8\times5^6\times7^5\times11^6\times 13^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 。</p>
<p>因为我们可以为所有公式甚至错误的公式生成哥德尔数，所以我们可以通过谈论它们的哥德尔数来明智地谈论这些公式。</p>
<p>考虑以下语句：“公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo><mo stretchy="false">(</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sim(0=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 的第一个符号是波浪号”。这个关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo><mo stretchy="false">(</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sim(0=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>) 的正确的元数学语句转化为关于公式的哥德尔数的语句，即其第一个指数为 1，即波浪号的哥德尔数。 换句话说，我们的语句为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mo>×</mo><msup><mn>3</mn><mn>8</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup><mo>×</mo><msup><mn>7</mn><mn>5</mn></msup><mo>×</mo><mn>1</mn><msup><mn>1</mn><mn>6</mn></msup><mo>×</mo><mn>1</mn><msup><mn>3</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2^1\times 3^8\times5^6\times7^5\times11^6\times 13^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 只有一个 2 因子。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo><mo stretchy="false">(</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sim(0=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 以除波浪号以外的任何符号开头，那么其哥德尔数至少应该有两个 2 因子。因此，更准确地说， 2 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mo>×</mo><msup><mn>3</mn><mn>8</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup><mo>×</mo><msup><mn>7</mn><mn>5</mn></msup><mo>×</mo><mn>1</mn><msup><mn>1</mn><mn>6</mn></msup><mo>×</mo><mn>1</mn><msup><mn>3</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2^1\times 3^8\times5^6\times7^5\times11^6\times 13^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 的因子，但 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 不是因子。</p>
<p>我们可以将最后一个语句转换为精确的算术公式，即我们可以使用基本符号写下。这个公式当然有一个哥德尔数，我们可以通过将其符号映射到素数的幂上来进行计算。</p>
<blockquote>
<p>对于好奇的读者，这个语句可以读作 “存在一个整数 x 使得 x 乘以 2 等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mo>×</mo><msup><mn>3</mn><mn>8</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup><mo>×</mo><msup><mn>7</mn><mn>5</mn></msup><mo>×</mo><mn>1</mn><msup><mn>1</mn><mn>6</mn></msup><mo>×</mo><mn>1</mn><msup><mn>3</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2^1\times 3^8\times5^6\times7^5\times11^6\times 13^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，且不存在一个整数 x 使得 xx 乘以 4 等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mo>×</mo><msup><mn>3</mn><mn>8</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup><mo>×</mo><msup><mn>7</mn><mn>5</mn></msup><mo>×</mo><mn>1</mn><msup><mn>1</mn><mn>6</mn></msup><mo>×</mo><mn>1</mn><msup><mn>3</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2^1\times 3^8\times5^6\times7^5\times11^6\times 13^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。对应的公式为</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>×</mo><mi>s</mi><mi>s</mi><mn>0</mn><mo>=</mo><mi>s</mi><mi>s</mi><mi>s</mi><mo>…</mo><mi>s</mi><mi>s</mi><mi>s</mi><mn>0</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo>∼</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>×</mo><mi>s</mi><mi>s</mi><mi>s</mi><mi>s</mi><mn>0</mn><mo>=</mo><mi>s</mi><mi>s</mi><mi>s</mi><mo>…</mo><mi>s</mi><mi>s</mi><mi>s</mi><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\exists x)(x \times s s 0=s s s \ldots s s s 0) \cdot \sim(\exists x)(x \times s s s s 0=s s s \ldots s s s 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∃</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord">0</span><span class="mclose">)</span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∃</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>s</mi><mi>s</mi><mo>…</mo><mi>s</mi><mi>s</mi><mi>s</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">s s s \ldots s s s 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord">0</span></span></span></span> 表示有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mo>×</mo><msup><mn>3</mn><mn>8</mn></msup><mo>×</mo><msup><mn>5</mn><mn>6</mn></msup><mo>×</mo><msup><mn>7</mn><mn>5</mn></msup><mo>×</mo><mn>1</mn><msup><mn>1</mn><mn>6</mn></msup><mo>×</mo><mn>1</mn><msup><mn>3</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2^1\times 3^8\times5^6\times7^5\times11^6\times 13^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 个后继符号 s 。符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span></span></span></span> 意思是 “且”，是基本词汇中较长表达的简写： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⋅</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\cdot q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 可以用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo><mo stretchy="false">(</mo><mo>∼</mo><mi>p</mi><mo>∨</mo><mo>∼</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sim(\sim p\vee \sim q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord">∨</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span> 代替。</p>
</blockquote>
<p>对于这个例子，内格尔和纽曼写道 “这说明了一个非常普遍且深刻的见解，它位于哥德尔发现的核心：长链符号的印刷性质可以间接但完全准确地 被对大整数因式分解性质的讨论替代。</p>
<p>对于元数学语句，转换为符号依然是可能的：“存在某个哥德尔数为 x 的公式序列，可以证明哥德尔数为 k 的公式”，或者简言之，“哥德尔数为 k 的公式可以被证明”。将此类语句 “算术化” 的能力为解决这个难题奠定了基础。</p>
<p><strong>G 自身</strong></p>
<p>哥德尔的独到见解是，他可以用公式本身的哥德尔数代入到公式中，从而导致无穷无尽的麻烦。</p>
<p>为了看出这个代入是如何起效的，考虑公式 (∃x)(x=sy) （它读作 “存在一个变量 x 使得它是 y 的后继”，或者简言之，“ y 有一个后继”）。像所有公式一样，它有哥德尔数，即某个大整数，我们就叫它 m 。</p>
<p>现在让我们在公式中用 m 代替符号 y 。 这形成一个新公式 (∃x)(x=sm) ，表示 “ m 有一个后继”。 我们怎么记这个公式的哥德尔数呢？我们需要传达三点信息：我们从哥德尔数为 m 的公式开始。 在其中，我们用 m 代替了符号 y 。根据前面介绍的映射方案，符号 y 的哥德尔数为 17。因此，让我们指定新公式的哥德尔数为 sub (m,m,17) 。</p>
<blockquote>
<p>译者注：这段是理解的难点，我们更仔细的再叙述一遍。在这段中，我们定义了一个函数 sub ，这个函数一共有 3 个输入，他们都是正整数，我们记为 sub (a,b,c)) 。其中，第一个参数 a 是一个公式的哥德尔数，我们接收到 a 之后要把它解码成此哥德尔数所对应的公式。最后一个参数 c 指的是一个符号的哥德尔数，我们要找到 a 对应公式的所有哥德尔数为 c 的符号所对应的位置。最后，我们把刚才找到的位置全部替换成数字 b 。现在，我们计算这个修改后的公式的哥德尔数，这个数字就是 sub (a,b,c)。</p>
</blockquote>
<p>替换构成了哥德尔证明的关键。</p>
<p>他考虑下面一个元数学语句 “无法证明哥德尔数为 sub (y,y,17) 的公式”。回想一下我们刚刚学到的符号，哥德尔数为 sub (y,y,17) 的公式是通过取哥德尔数为 y （某个未知量）的公式并将该变量 y 替换掉哥德尔数为 17 的符号（也是任何一个 y 的位置）。</p>
<p>事情变得令人迷惑，但是不管怎么说，我们的元数学语句 “无法证明哥德尔数为 sub (y,y,17) 的公式” 肯定能转化为某个特定哥德尔数所对应的公式。 我们把这个数称为 n 。</p>
<p>现在进行最后一轮替换：哥德尔通过将数字 n 替换先前公式中 y 的位置来创建一个新公式。他的新公式声称：“无法证明哥德尔数为 sub (n,n,17) 的公式”。我们将此新公式称为 G 。</p>
<p>自然， G 也有一个哥德尔数。那么它的值是什么呢？哇哦，它肯定是 sub (n,n,17) ！根据定义， sub (n,n,17) 是下面公式的哥德尔数，它是通过将哥德尔数为 n 的公式中对应哥德尔数为 17 的符号用 n 替代所得到的。而 G 正是这个公式！ 由于素数分解的唯一性，我们现在看到 G 所讨论的公式就是 G 本身。</p>
<blockquote>
<p>译者注：这又是一个难点。我们更仔细的叙述如何计算 sub (n,n,17)。回忆我们前面的注，我们的第一步就是要解码 n 所对应的公式。根据前文，我们知道这对应了语句 “无法证明哥德尔数为 sub (y,y,17) 的公式”。第二步，我们要找到 17 所对应的符号，也就是 y 的所有位置，我们将找到的位置加个框：“无法证明哥德尔数为 \mathrm{sub}(\bbox[#EEF, 5px, border: 2px solid red]{y},\bbox[#EEF, 5px, border: 2px solid red]{y},17) 的公式 “。第三步，我们要把框的位置替换成 n ，也就是 “无法证明哥德尔数为 sub (n,n,17) 的公式 “，而这正是公式 G 。</p>
</blockquote>
<p>G 断言自己无法被证明。</p>
<p>但是 G 能被证明吗？如果是的话，则意味着存在某个公式序列，可以证明哥德尔数为 sub (n,n,17) 的公式。但这恰好与 G 相反，即 G 断言不存在这样的证明。相反的语句 G 和 ∼G 在一致的公理体系中不可能同时为真。因此， G 的正确与否必然无法被判定。</p>
<p>然而，尽管 G 是无法被判定，它显然是对的。 G 意思是 “无法证明哥德尔数为 sub (n,n,17) 的公式”，而这正是我们所发现的事实。既然 G 是正确的，还是在此公理体系内构造的一个无法被判定的语句，说明了这个系统是不完备的。</p>
<p>你可能认为你可以提出一些额外的公理，使用它们证明 G 并解决悖论。但是你不能。哥德尔说明了对于增强的公理系统将允许构建新的正确的公式 G （根据与之前的方法类似），而该公式无法在新的增强系统中得到证明。在努力建立完备的数学系统时，你永远无法摆脱困境。</p>
<p><strong>没有一致性的证明</strong></p>
<p>我们学到了如果公理集是一致的，则它是不完备的。这是哥德尔第一不完备定理。第二定理，即没有一套公理可以证明其自身的一致性，由此易得。</p>
<p>如果公理集可以证明它永远不会产生矛盾，那意味着什么？这意味着存在根据这些公理构建的一系列公式，证明了这个含义为 “这组公理是一致的” 的元数学公式。由第一定理，这个公理集必然是不完备的。</p>
<p>但是，“公理集是不完备的” 与 “有一个无法被证明的正确的公式” 含义相同。这个语句等价于我们的公式 G 。我们知道公理不能证明 G 。</p>
<p>因此，哥德尔创造了一个矛盾的证明：如果公理集可以证明其自身的一致性，那么我们将能够证明 G 。但是我们不能。因此，没有一组公理可以证明其自身的一致性。</p>
<p>哥德尔的证明扼杀了对一个一致和完备的数学系统的追求。内格尔和纽曼在 1958 年写道，不完备性的含义 “还没有被完全理解”。直到今天仍然如此。</p>
]]></content>
      <categories>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>数理逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫学习</title>
    <url>/2023/01/25/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="python爬虫学习总结"><a class="anchor" href="#python爬虫学习总结">#</a> python 爬虫学习总结</h1>
<p>学习 python 爬虫的一些笔记</p>
<p><span id="more"></span></p>
<h2 id="requests模块"><a class="anchor" href="#requests模块">#</a> requests 模块</h2>
<p>requests 模块流程：</p>
<pre><code>1. 指定url
2. 发起请求 response = requests.get(url)
3. 获取数据 page_source = response.text()
4. 存储数据 文件操作/数据库操作
</code></pre>
<p>参数 tips：params 是用来发送查询字符串，而 data 是用来发送正文的。post 与 get 方法的特性是：这两种参数 post（）方法都可以用，get 方法只能发查询字符串，不能发送正文</p>
<p>text 返回字符串 content 返回二进制（爬取图片可用）  json 返回对象</p>
<p>分页爬取：</p>
<p>​	如果是 ajax，在检查、网络、xhr 中查看</p>
<p>​	如果是新链接，可以使用正则表达式匹配 url</p>
<p>如果是用 ajax 的包：要注意的：</p>
<ul>
<li>看请求方法 是 GET 还是 POST。。。</li>
<li>看响应头的 content-type 选择 reponse.text () 或 reponse.json ()</li>
<li>看负载中带的参数</li>
</ul>
<p>中文乱码问题（文件编码格式为 utf8 json.dump 时 ensure acill 选项关闭）</p>
<p>什么是 ajax? （根据用户行为重新渲染界面。 不修改 url 在检查 - 网络 - XHR 中查看具体信息）</p>
<h2 id="bs4-数据解析"><a class="anchor" href="#bs4-数据解析">#</a> bs4 数据解析</h2>
<p>bs4 数据解析的原理：</p>
<p>1. 实例化一个 BeautifulSoup 对象 并且将页面原码数据加载到该对象中</p>
<p>2. 通过调用 bs 对象中相关的属性或方法进行标签定位和数据提取</p>
<p>如何实例化 beautifulsoup 对象：</p>
<ol>
<li>
<p>将本地的 html 文档中的数据加载到该对象中</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>fp <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token string">'lxml'</span><span class="token punctuation">)</span></pre></td></tr></table></figure></li>
<li>
<p>将互联网上获取的页面源码加载到该对象中</p>
<pre><code>page_text = response.text
soup = BeautifulSoup(page_text,'lxml')
</code></pre>
</li>
</ol>
<p>提供的用于数据解析的方法和属性：</p>
<p>soup.tagname 返回 html 中第一次出现的 tagname 标签</p>
<p>soup.find ('tagname') 等同于 soup.tagname</p>
<p>soup.find ('tagname', class = 'classname') 定义属性位置， class 可以替换为 id attr</p>
<p>soup.find_all ('tagname') 找到符合要求所有标签 返回列表</p>
<p>soup.select ('.tang')  参数为某种选择器（id class 标签），返回一个列表</p>
<p>soup.select ('.tang&gt; ul &gt; li &gt; a') 层级选择器，返回一个列表</p>
<p>soup.selest ('.tang&gt; ul a') &gt; 号表示一个层级，空格表示多个层级</p>
<p>怎么获取标签之间的文本数据：</p>
<p>使用	soup.a.text/string/get_text () 方法</p>
<pre><code>-   text/get_text(): 可以获取某一个标签中所有的文本内容（多套几层也能得到）
-   string：获取标签下直系的文本内容
</code></pre>
<p>怎么获取标签的属性值：</p>
<p><code>soup.select('tang &gt; ul &gt; li &gt; a')[0]['href']</code>  直接获得 a 标签中的 herf 属性值</p>
<h2 id="xpath解析"><a class="anchor" href="#xpath解析">#</a> xpath 解析</h2>
<p>xpath 解析： 最常用且最便捷高效的一种解析方式。</p>
<p>xpath 解析原理：</p>
<pre><code>1. 实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。
2. 调用etree对象中的xpath方法结合xpath表达式实现标签的定位和内容的捕获。
</code></pre>
<p>环境安装：</p>
<pre><code>- pip install lxml
</code></pre>
<p>如何实例化 etree 对象</p>
<p>​	from lxml import etree</p>
<ol>
<li>
<p>将本地的 html 文档中的源码数据加载到 etree 对象中：</p>
<p><code> etree.parse(filePath)</code></p>
</li>
<li>
<p>可以将从互联网上获取的源码数据加载到该对象中</p>
<p><code>etree.HTML('page_text')        -xpath('xpath表达式')</code></p>
</li>
</ol>
<p>/ 表示一个层级  // 表示多个层级</p>
<p>路径后加 [@ 属性名] 精确定位 如 <code>xx_list = tree.xpath('//div[@class='song']')</code></p>
<p>中括号内加数字代表取第几个（索引下标从 1 开始） <code>xx_list[0]</code></p>
<p>获取文本：定位后加 /text ()</p>
<h2 id="中文出现乱码常见的处理方法"><a class="anchor" href="#中文出现乱码常见的处理方法">#</a> 中文出现乱码常见的处理方法</h2>
<p>两种常见方法，一般能解决所有中文乱码问题</p>
<ol>
<li>
<p>对爬下来的整个数据改变编码：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>response<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span></pre></td></tr></table></figure></li>
<li>
<p>对出现问题的对象单独进行编码与解码</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>img_name <span class="token operator">=</span> img_name<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'iso-8859-1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'gbk'</span><span class="token punctuation">)</span></pre></td></tr></table></figure></li>
</ol>
<h2 id="selenium模块"><a class="anchor" href="#selenium模块">#</a> selenium 模块</h2>
<h3 id="selenium模块与爬虫之间具有怎样的关联"><a class="anchor" href="#selenium模块与爬虫之间具有怎样的关联">#</a> selenium 模块与爬虫之间具有怎样的关联？</h3>
<ul>
<li>便捷的获取网站中动态加载的数据</li>
<li>便捷实现模拟登录</li>
</ul>
<h3 id="什么是selenium模块"><a class="anchor" href="#什么是selenium模块">#</a> 什么是 selenium 模块</h3>
<p>基于浏览器自动化的一个模块。 （编写代码让浏览器完成自动化操作）</p>
<h3 id="selenium使用流程"><a class="anchor" href="#selenium使用流程">#</a> selenium 使用流程：</h3>
<ul>
<li>环境安装：pip install selenium</li>
<li>下载一个浏览器的驱动程序</li>
<li>实例化一个浏览器对象</li>
</ul>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>edge<span class="token punctuation">.</span>service <span class="token keyword">import</span> Service</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 实例化一个浏览器对象 参数中的路径为浏览器驱动程序的路径（建议与程序在同一路径下）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>service <span class="token operator">=</span> Service<span class="token punctuation">(</span>executable_path <span class="token operator">=</span> <span class="token string">'./edgedriver.exe'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>bro <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Edge<span class="token punctuation">(</span>service <span class="token operator">=</span> service<span class="token punctuation">)</span></pre></td></tr></table></figure><ul>
<li>编写基于浏览器的代码</li>
</ul>
<h3 id="selenium常用函数"><a class="anchor" href="#selenium常用函数">#</a> selenium 常用函数</h3>
<ul>
<li>
<p>bro.get (url)  											让浏览器发起一个指定 url 对应请求</p>
</li>
<li>
<p>page_text = bro.page_source		  获取浏览器当前页面的页面源码数据</p>
</li>
<li>
<p>标签定位：使用 find_element 方法</p>
</li>
</ul>
<p>​	search_input = bro.find_element(By.[attrname], &quot;[attr]'s value&quot;)</p>
<ul>
<li>
<p>标签交互：</p>
<p>​	search_input.send_keys('xxx')</p>
</li>
<li>
<p>执行一组 js 代码</p>
<p>​	bro.execute_script('code...')</p>
</li>
<li>
<p>点击按钮：</p>
<p>​	btn.click()</p>
</li>
<li>
<p>后退 / 前进</p>
<p>​	bro.back()/forward()</p>
</li>
</ul>
<h3 id="selenium处理iframe"><a class="anchor" href="#selenium处理iframe">#</a> selenium 处理 iframe</h3>
<p>bro.switch_to.frame('frame_name')</p>
<h3 id="动作链项目暂时用不到"><a class="anchor" href="#动作链项目暂时用不到">#</a> 动作链 (项目暂时用不到)</h3>
<p>南大相关网站的登录还不需要滑块验证</p>
<p>碰到滑块验证的时候可能就需要用到了</p>
<h3 id="selenium实现模拟登录"><a class="anchor" href="#selenium实现模拟登录">#</a> selenium 实现模拟登录</h3>
<p>结合前面的基础知识 先点击账号密码登录按钮，找到账号输入框与密码输入框，</p>
<p>输入账号密码，点击登录按钮</p>
<h2 id="模拟登陆cookie操作"><a class="anchor" href="#模拟登陆cookie操作">#</a> 模拟登陆 cookie 操作</h2>
<h3 id="cookie有什么作用"><a class="anchor" href="#cookie有什么作用">#</a> cookie 有什么作用</h3>
<p>TCP/IP 协议是无状态的，因此通常的 get 请求 服务器端不知道你有没有处于登录状态</p>
<p>携带 cookie 值的 get 请求 能使服务器端知道你已经处于登录状态</p>
<h3 id="手动cookie不推荐"><a class="anchor" href="#手动cookie不推荐">#</a> 手动 cookie（不推荐）</h3>
<p>登录网站后通过抓包工具手动复制 cookie 值 将 cookie 值封装到 headers 中，写死在程序里</p>
<p>缺点：cookie 值一段时间后会过期</p>
<h3 id="自动处理"><a class="anchor" href="#自动处理">#</a> 自动处理</h3>
<p>cookie 值是如何产生的？既然 cookie 值能让服务器知道你已经处于登录状态，那么理所当然 cookie 值是登录时发送 post 请求后服务器端生成后发送给客户端的</p>
<p>session 会话对象：</p>
<p>作用：</p>
<ol>
<li>可以进行请求的发送</li>
<li>如果请求过程中产生了 cookie，则该 cookie 会被自动存储 / 携带在该 session 对象中</li>
</ol>
<p>使用：</p>
<ol>
<li>
<p>创建一个 session 对象 ：  <code>session = requests.Session()</code></p>
</li>
<li>
<p>使用 session 对象进行模拟登录 post 请求的发送 (cookie 就会被存储在 session 中)</p>
</li>
<li>
<p>session 对象对个人主页对应的 get 请求进行发送（携带了 cookie）</p>
</li>
</ol>
<p>如果登录找不到 post 请求或遇到问题导致获得不到 cookie：</p>
<p>​	适用 selenium 登录后 用下列方法直接取得 cookie:</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>c <span class="token operator">=</span> bro<span class="token punctuation">.</span>get_cookies<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>bro<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cookies <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 获取 cookie 中的 name 和 value, 转化成 requests 可以使⽤的形式</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> cookie <span class="token keyword">in</span> c<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    cookies<span class="token punctuation">[</span>cookie<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> cookie<span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p>然后就能用 cookies 了：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token operator">=</span>detail_url<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> cookies<span class="token operator">=</span>cookies<span class="token punctuation">)</span></pre></td></tr></table></figure><h2 id="并行爬取异步爬虫"><a class="anchor" href="#并行爬取异步爬虫">#</a> 并行爬取（异步爬虫）</h2>
<p>原理：利用进程池实现并行爬取</p>
<p>使用方法：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 创建进程池</span></pre></td></tr><tr><td data-num="3"></td><td><pre>pool <span class="token operator">=</span> Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>pool<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>function_name<span class="token punctuation">,</span> iterable<span class="token punctuation">[</span><span class="token punctuation">,</span>chunksize<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p><strong>processes 参数设置注意</strong>：当进程数量大于 CPU 的内核数量时，等待运行的进程会等到其他进程运行完毕让出内核为止。因此，如果 CPU 是单核，就无法进行多进程并行。在使用多进程爬虫之前，我们需要先了解计算机 CPU 的核心数量。这里用到了 multiprocessing:</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> cpu_count</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>运行结果为 16。</p>
<p>使用 eg：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'https://xjh.haitou.cc/xa/after/page-&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>pool <span class="token operator">=</span> Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#get_xuanjing 为参数是一个 url 的爬虫函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>pool<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>get_xuanjiang<span class="token punctuation">,</span>urls<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭进程池，不再接受新的进程</span></pre></td></tr><tr><td data-num="6"></td><td><pre>pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 主进程阻塞等待子进程的退出</span></pre></td></tr></table></figure><h2 id="有关爬虫的一些问题"><a class="anchor" href="#有关爬虫的一些问题">#</a> 有关爬虫的一些问题：</h2>
<ul>
<li>
<p>爬下来的文本中带有 &amp; nbsp 在 html 中表示 no breaking space（不自动换行的空格）</p>
<p>此时可以采用 str.replace (u'\xa0', '') 来解决 str 为待处理字符串</p>
</li>
<li>
<p>requests 里.text 与 .content 方法的区别：</p>
<p>两者区别在于，content 中间存的是字节码，而 text 中存的是 Beautifulsoup 根据猜测的编码方式将 content 内容编码成字符串。</p>
<p>直接输出 content，会发现前面存在 b' 这样的标志，这是字节字符串的标志，而 text 是，没有前面的 b, 对于纯 ascii 码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode ('utf-8')，中文常用 utf-8 和 GBK，GB2312 等。这样可以手工选择文字编码方式。</p>
<p>所以简而言之，.text 是现成的字符串，.content 还要编码，但是.text 不是所有时候显示都正常，这是就需要用.content 进行手动编码</p>
</li>
<li>
<p>两种常见方法，一般能解决所有中文乱码问题</p>
<ol>
<li>
<p>对爬下来的整个数据改变编码：</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>response<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span></pre></td></tr></table></figure></li>
<li>
<p>对出现问题的对象单独进行编码与解码</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>img_name <span class="token operator">=</span> img_name<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'iso-8859-1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'gbk'</span><span class="token punctuation">)</span></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性算法</title>
    <url>/2024/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>此坑待填</p>
<h2 id="2pctwo-phase-commit"><a class="anchor" href="#2pctwo-phase-commit">#</a> 2PC(two-phase commit)</h2>
<p><strong>2PC 是强一致，中心化的原子提交协议</strong></p>
<p>两个阶段：准备阶段、提交阶段</p>
<p>两个角色：协调者 (coordinator), 参与者 (Participant)</p>
<p>深度理解：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbmd4aWFvMTk5My9hcnRpY2xlL2RldGFpbHMvODgyOTA1MTQ=">正确理解二阶段提交（Two-Phase Commit）_2 阶段提交 - CSDN 博客</span></p>
<h3 id="第一阶段"><a class="anchor" href="#第一阶段">#</a> 第一阶段</h3>
<p><img data-src="phase-1.png" alt="image-20240709230522019"></p>
<p>第三点记录的日志有 redo log 和 undo log</p>
<p>只有所有的 Participant 都返回 yes 才会进入第二阶段。否则 coordinator 发送 global roolback, 各节点根据记录的 undo log 全局回滚，向 client 返回错误。</p>
<h3 id="第二阶段"><a class="anchor" href="#第二阶段">#</a> 第二阶段</h3>
<p><img data-src="phase-2.png" alt="image-20240709235508995"></p>
<p>根据第一阶段的 redo log 提交事务</p>
<h3 id="问题"><a class="anchor" href="#问题">#</a> 问题</h3>
<ol>
<li>同步阻塞：
<ul>
<li>协调者需要等待所有参与者的响应</li>
<li>每个参与者第二阶段的开始需要等待 coordinator 的 global commit 或 global roolback</li>
</ul>
</li>
<li>数据不一致
<ul>
<li>只有一部分参与者回滚成功</li>
<li>只有一部分参与者提交成功</li>
</ul>
</li>
<li>单点问题：太依赖协调者，一旦协调者出故障会很麻烦</li>
<li>太保守，为了保证强一致性牺牲性能。</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习编译器TVM-UserTutorial</title>
    <url>/2023/02/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BC%96%E8%AF%91%E5%99%A8TVM-UserTutorial/</url>
    <content><![CDATA[<h1 id="tvm-usertutorial"><a class="anchor" href="#tvm-usertutorial">#</a> TVM-UserTutorial</h1>
<p>自 2022 年 10 月份选择大创项目 —— 基于 TVM 实现针对国产 AI 芯片的深度算子库项目以来。花了许多时间弄懂什么是 TVM，项目的定位是什么，我们要做的到底是什么事。也经历了期末复习周，由于疫情延期期末考到开学考试，以及小组成员陆续阳性等等事。导致我们的项目在开题答辩之后迟迟没有开始。本学期初在学习了计算系统基础以及编译原理的导论之后，我对 TVM 的认识更加深刻了，项目也重新启动 (2023/2)。</p>
<p><span id="more"></span></p>
<h2 id="introduction"><a class="anchor" href="#introduction">#</a> Introduction</h2>
<p>原文链接： <span class="exturl" data-url="aHR0cHM6Ly90dm0uYXBhY2hlLm9yZy9kb2NzL3R1dG9yaWFsL2ludHJvZHVjdGlvbi5odG1sI3NwaHgtZ2xyLXR1dG9yaWFsLWludHJvZHVjdGlvbi1weQ==">Introduction — tvm 0.11.dev0 documentation (apache.org)</span></p>
<p>TVM 隶属于 Apache 基金会，是开源项目。定义为一个可应用于各种 GPU CPU 深度学习加速器的深度学习编译器。</p>
<h2 id="an-overview-of-tvm-and-model-optimization"><a class="anchor" href="#an-overview-of-tvm-and-model-optimization">#</a> An Overview of TVM and Model Optimization</h2>
<p><img data-src="image-20230228142729726.png" alt="image-20230228142729726"></p>
<p>主要思想： 专用 --&gt; 通用 --&gt; 专用    不同框架转化为统一的 IR 表示，在根据模型所部署的不同硬件的类型转化为对应的字节码 。</p>
<p>TVM 采用了多级 IR 的设计，而且每级之间的转化都会经过各种优化，比如切割子图，图优化，以及 AutoTVM/AutoScheduler (这两个是 TVM 带有的自动优化模块) 进行最优调度的选择。</p>
<p>TVM 支持的后端有 LLVM、NVCC 等，最重要的是可以支持 Embedded and specialized targets, 但是要使用 TVM 提供的 BYOC 功能，也是我们项目最需要实现的部分。</p>
<h2 id="compiling-and-optimizing-a-model-with-tvmc"><a class="anchor" href="#compiling-and-optimizing-a-model-with-tvmc">#</a> compiling and optimizing a Model with TVMC</h2>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly90dm0uYXBhY2hlLm9yZy9kb2NzL3R1dG9yaWFsL3R2bWNfY29tbWFuZF9saW5lX2RyaXZlci5odG1sI3NwaHgtZ2xyLXR1dG9yaWFsLXR2bWMtY29tbWFuZC1saW5lLWRyaXZlci1weQ==">compiling and optimizing a model with TVMC</span></p>
<p>大部分操作已在虚拟机中运行成功</p>
<p>日期：3/1</p>
<p>这章主要熟悉了 TVMC 的简单使用。官方文档提供了一个预训练的 ResNet-50 v2 模型。为 TVM 的 runtime 编译此模型，并在这个模型上跑了一个真实的猫猫图片，得到运行结果。文章还包括了在实际的 CPU 上用 TVM 调优（tune）模型，并且使用 TVM 收集的 tuning data 重编译出一个优化的模型，重新跑一遍优化的模型，并与之前模型的表现进行对比（这部分较难）。</p>
<p>TVMC 是 TVM 的命令行工具，让你能在命令行中使用 TVM，C 表示 command line 的意思。</p>
<p>TVMC 支持 Keras, ONNX, TensorFlow, TFLite and Torch 构建的模型，本章模型用的是 onnx。</p>
<h2 id="编译模型"><a class="anchor" href="#编译模型">#</a> 编译模型</h2>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>tvmc compile <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">--target</span> <span class="token string">"llvm"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre>--input-shapes <span class="token string">"data:[1,3,224,224]"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">--output</span> resnet50-v2-7-tvm.tar <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="5"></td><td><pre>resnet50-v2-7.onnx</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 编译出来一个 tar 文件</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">mkdir</span> model</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">tar</span> <span class="token parameter variable">-xvf</span> resnet50-v2-7-tvm.tar <span class="token parameter variable">-C</span> model</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">ls</span> model</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">#解压后看看有什么</span></pre></td></tr></table></figure><p>有三个东西：</p>
<p><span class="exturl" data-url="aHR0cDovL21vZC5zbw==">mod.so</span> : 就是那个模型，表现为一个 TVM runtime 能运行的 c++ 库</p>
<p>mod.json  : a text representation of the TVM Relay computation graph.</p>
<p>mod.params:  a file containing the parameters for the pre-trained model.--</p>
<p>编译时选择恰当的命令行选项能大大改变编译性能</p>
<h2 id="用tvmc运行模型"><a class="anchor" href="#用tvmc运行模型">#</a> 用 TVMC 运行模型</h2>
<p>为了对模型进行有效输入 要将预备的输入进行一些预处理.TVM 采用.npz 格式文件作为模型输入和输出，这是一个受良好支持的 Numpy 文件格式。</p>
<p>这里文章用一个 python 脚本预处理了猫猫图片（具体见原文），得到了一个 imagenet_cat.npz。</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>tvmc run <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">--inputs</span> imagenet_cat.npz <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token parameter variable">--output</span> predictions.npz <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre>resnet50-v2-7-tvm.tar</pre></td></tr></table></figure><p>同样，这个文件也不是人能看懂的，原文提供了一个后处理脚本，把这个文件转化为人能看懂的结果。（见原文）</p>
<p>结果如下：</p>
<blockquote>
<h4 id="classn02123045-tabby-tabby-cat-with-probability0610553"><a class="anchor" href="#classn02123045-tabby-tabby-cat-with-probability0610553">#</a> class='n02123045 tabby, tabby cat' with probability=0.610553</h4>
<h4 id="classn02123159-tiger-cat-with-probability0367179"><a class="anchor" href="#classn02123159-tiger-cat-with-probability0367179">#</a> class='n02123159 tiger cat' with probability=0.367179</h4>
<h4 id="classn02124075-egyptian-cat-with-probability0019365"><a class="anchor" href="#classn02124075-egyptian-cat-with-probability0019365">#</a> class='n02124075 Egyptian cat' with probability=0.019365</h4>
<h4 id="classn02129604-tiger-panthera-tigris-with-probability0001273"><a class="anchor" href="#classn02129604-tiger-panthera-tigris-with-probability0001273">#</a> class='n02129604 tiger, Panthera tigris' with probability=0.001273</h4>
<h4 id="classn04040759-radiator-with-probability0000261"><a class="anchor" href="#classn04040759-radiator-with-probability0000261">#</a> class='n04040759 radiator' with probability=0.000261</h4>
</blockquote>
<h2 id="自动调优模型"><a class="anchor" href="#自动调优模型">#</a> 自动调优模型</h2>
<p>TVM 的调优是根据具体硬件对模型进行优化，使其在给定目标上运行的更快。调优不会影响预测准确性，只会影响性能！</p>
<p>演示：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>tvmc tune <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">--target</span> <span class="token string">"llvm"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token parameter variable">--output</span> resnet50-v2-7-autotuner_records.json <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre>resnet50-v2-7.onnx</pre></td></tr></table></figure><p>如果为 ——target 指定一个更具体的目标能得到更好的结果，如在 i7 处理器上使用 --target llvm-mcpu=skylake</p>
<p>TVMC 将对模型的参数空间进行搜索，尝试不同的算子配置，并选择在您的平台上运行最快的配置。虽然这是一个基于 CPU 和模型运算的引导搜索，但仍然需要几个小时才能完成搜索。此搜索的输出将保存到 resnet50-v2-7-autotuner_records.json 文件中，稍后将用于编译一个优化的模型。</p>
<h2 id="使用调优数据编译优化模型"><a class="anchor" href="#使用调优数据编译优化模型">#</a> 使用调优数据编译优化模型</h2>
<p>编译器将使用调优结果为指定的目标上的模型生成高性能代码。编译命令为 tvmc compile --tuning-records。现在已经收集了模型的调优数据，我们可以使用优化后的算子重新编译模型，以加快计算速度。</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>tvmc compile <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">--target</span> <span class="token string">"llvm"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre>--tuning-records resnet50-v2-7-autotuner_records.json  <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">--output</span> resnet50-v2-7-tvm_autotuned.tar <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="5"></td><td><pre>resnet50-v2-7.onnx</pre></td></tr></table></figure><p>与之前作对比，重复 100 此次。平均性能快 47%。</p>
<h2 id="getting-starting-using-tvmc-python-a-high-level-api-for-tvm"><a class="anchor" href="#getting-starting-using-tvmc-python-a-high-level-api-for-tvm">#</a> Getting Starting using TVMC Python: a high-level API for TVM</h2>
<p>原文链接： [Getting Starting using TVMC Python: a high-level API for TVM](<span class="exturl" data-url="aHR0cHM6Ly90dm0uYXBhY2hlLm9yZy9kb2NzL3R1dG9yaWFsL3R2bWNfcHl0aG9uLmh0bWw=">Getting Starting using TVMC Python: a high-level API for TVM — tvm 0.11.dev0 documentation (apache.org)</span>)</p>
<p>日期：3/2</p>
<p>这章主要讲的是在 python 文件中怎么使用 tvmc。</p>
<ul>
<li>导入：  <code>from tvm.driver import tvmc</code></li>
<li>把模型转化为 Relay 表示： <code>model = tvmc.load('my_model.onnx')</code></li>
<li>编译： <code>package = tvmc.compile(model, target=&quot;llvm&quot;)</code></li>
<li>运行： <code>result = tvmc.run(package, device=&quot;cpu&quot;)</code></li>
</ul>
<p>可以加入第 1.5 步：调优</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>tvmc<span class="token punctuation">.</span>tune<span class="token punctuation">(</span>model<span class="token punctuation">,</span> target<span class="token operator">=</span><span class="token string">"llvm"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>tvmc<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> target<span class="token operator">=</span><span class="token string">"llvm"</span><span class="token punctuation">,</span> tuning_records <span class="token operator">=</span> <span class="token string">"records.log"</span><span class="token punctuation">)</span> <span class="token comment"># records.log 获取见下文如何保存调优结果</span></pre></td></tr></table></figure><h2 id="附加功能"><a class="anchor" href="#附加功能">#</a> 附加功能</h2>
<p>可以在每一步都把中间结果保存下来。比如保存模型：在第一步后面  <code>model.save(desired_model_path)</code></p>
<p>还能保存 package, 调优结果等</p>
]]></content>
      <categories>
        <category>TVM</category>
      </categories>
      <tags>
        <tag>TVM 深度学习 机器学习 编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理01-词法分析</title>
    <url>/2023/03/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8601-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="编译原理01-词法分析"><a class="anchor" href="#编译原理01-词法分析">#</a> 编译原理 01 - 词法分析</h1>
<p>词法分析： 输入（程序文本 / 字符串 s）--&gt; 输出（词法单元流）</p>
<p><span id="more"></span></p>
<p><img data-src="image-20230309110603730.png" alt="image-20230309110603730"></p>
<h2 id="词法分析器的三种设计方法由易到难"><a class="anchor" href="#词法分析器的三种设计方法由易到难">#</a> 词法分析器的三种设计方法（由易到难）</h2>
<ol>
<li>词法分析器生成器（如 ANTLR）</li>
<li>手写词法分析器</li>
<li>自动化词法分析器 (自己实现一个词法分析器生成器)</li>
</ol>
<p>生产环境下的编译器（如 gcc）通常选择手写词法分析器</p>
<h2 id="antrl的使用"><a class="anchor" href="#antrl的使用">#</a> antrl 的使用</h2>
<p>输入： 词法单元的规约 -<strong>SimpleExpr.g4</strong></p>
<p>输出：词法分析器 -  <strong>SimpleExprLexer.java</strong></p>
<p>​				SimpleExprLexer.java 编译后 接受输入文件 并输出 token 流</p>
<h2 id="g4文件的结构"><a class="anchor" href="#g4文件的结构">#</a> .g4 文件的结构</h2>
<p>第一行： <code>grammar SimpleExpr ;</code>  给接下来的文法起个名字 名字要与文件名一致</p>
<p>​					** 如果文件里只包含词法部分 用 lexer grammar SysYLexer **</p>
<p>​					 每一行都要以分号结尾</p>
<p>@header {} 括号里的东西会自动拷贝到到 java 文件中</p>
<p>语法规则见下面示例</p>
<p>SimpleExpr.g4:</p>
<pre><code class="language-Antlr">grammar SimpleExpr;

import SimpleExprRules;

@header&#123;
package simpleexpr;
&#125;

prog : stat* EOF ;

stat : expr ';'
     | ID '=' expr ';'
     | 'if' expr ';'
     ;

expr : expr ('*' | '/') expr
     | expr ('+' | '-') expr
     | '(' expr ')'
     | ID
     | INT
     | FLOAT
     ;
    // 到这里描述的其实还是语法结构
</code></pre>
<p>SimpleExprRules.g4:</p>
<pre><code class="language-Antlr">lexer grammar SimpleExprRules;

SEMI : ';' ;
ASSIGN : '=' ;
IF : 'if' ;
MUL : '*' ;
DIV : '/' ;
ADD : '+' ;
SUB : '-' ;
LPAREN : '(' ;
RPAREN : ')' ;

ID : (LETTER | '_') WORD* ;
INT : '0' | ([1-9] DIGIT*) ;
FLOAT : INT '.' DIGIT*
      | '.' DIGIT+
      ;

WS : [ \t\r\n]+ -&gt; skip ;

//SL_COMMENT : '//' .*? '\n' -&gt; skip ;
SL_COMMENT2 : '//' ~[\n]* '\n' -&gt; skip;
DOC_COMMENT : '/**' .*? '*/' -&gt; skip ;
ML_COMMENT : '/*' .*? '*/' -&gt; skip ;

fragment LETTER : [a-zA-Z] ;
fragment DIGIT : [0-9] ;
fragment WORD : LETTER | DIGIT | '_' ;
//以上才是真正的词法部分

</code></pre>
<h2 id="用编程方式使用antlr-4-生成的xxxlexerjava"><a class="anchor" href="#用编程方式使用antlr-4-生成的xxxlexerjava">#</a> 用编程方式使用 ANTLR 4 生成的 xxxlexer.java</h2>
<pre><code>package simpleexpr;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class SimpleExprTest &#123;
  public static void main(String[] args) throws IOException &#123;
    System.out.println(&quot;SimpleExprTest ...&quot;);

    InputStream is = System.in;

    String file;
    if (args.length &gt; 0) &#123;
      file = args[0];
      is = new FileInputStream(file);
    &#125;

    CharStream input = CharStreams.fromStream(is);
    //SimpleExprLexer 是.g4文件生成的java类 input必须是CharStream格式
    SimpleExprLexer lexer = new SimpleExprLexer(input);
	
    lexer.getAllTokens().forEach(System.out::println);
  &#125;
&#125;

</code></pre>
<h2 id="正则表达式"><a class="anchor" href="#正则表达式">#</a> 正则表达式</h2>
<p>基本的知识就不记录了 记录一些重要的</p>
<ul>
<li>非贪婪匹配  <code>.*?</code></li>
<li>反向引用 要引用的用（）括起来，后面引用通过子表达式下标访问，如 \1，下标从 1 开始</li>
<li>look ahead ?&lt;= 符号，表示前面字符要满足 xxx，但不匹配 xxx</li>
<li>look back  ?= 符号，表示后面字符要满足 xxx，但不匹配 xxx</li>
</ul>
<h2 id="nfa与dfa"><a class="anchor" href="#nfa与dfa">#</a> NFA 与 DFA</h2>
<p>NFA：非确定性自动机  DFA: 确定性有穷自动机（Deterministic Finite Automaton)</p>
<p><img data-src="image-20230320200945838.png" alt="image-20230320200945838"></p>
<p>区别：</p>
<ul>
<li>NFA 简洁易于理解，便于描述语言 L (A)</li>
<li>DFA 易于判断 x 属于 L (A)，适合产生词法分析器</li>
</ul>
<p>​    其中 L (A) 是使当前自动机能进入接受状态的输入集合</p>
<p>一般用 NFA 描述语言，用 DFA 实现词法分析器</p>
<p><strong>实现词法分析器的步骤：RE --&gt; NFA --&gt; DFA --&gt; 词法分析器</strong></p>
<p>如图： 根据 DFA 生成 RE 不需要掌握</p>
<p><img data-src="image-20230320201739378.png" alt="image-20230320201739378"></p>
<h2 id="thompson构造法从re-到-nfa"><a class="anchor" href="#thompson构造法从re-到-nfa">#</a> Thompson 构造法（从 RE 到 NFA）</h2>
<p><img data-src="image-20230315141912075.png" alt="image-20230315141912075"></p>
<p>构造方法如下：</p>
<p><img data-src="image-20230320203523098.png" alt="image-20230320203523098"></p>
<p><img data-src="image-20230320203542881.png" alt="image-20230320203542881"></p>
<p><img data-src="image-20230320203600728.png" alt="image-20230320203600728"></p>
<p><img data-src="image-20230320203629409.png" alt="image-20230320203629409"></p>
<p>这里是 “一边做构造 一边做证明”，只要保证从最基本的情况开始，每一步 NFA 的构造都保证只会有唯一的开始状态和接受状态即可。综合所有情况下的构造方法，可以看到这一点是正确的。</p>
<p><img data-src="image-20230320203705399.png" alt="image-20230320203705399"></p>
<p><img data-src="image-20230320203721076.png" alt="image-20230320203721076"></p>
<p><img data-src="image-20230315142444609.png" alt="image-20230315142444609"></p>
<p>关于第三点中的运算符合运算分量 gpt 的解释：</p>
<p>正则表达式语言 r 的运算符和运算分量：</p>
<p>常见运算符：</p>
<ul>
<li>|：或运算符，用于匹配两种情况中的一种。</li>
<li>()：分组运算符，用于将多个运算分量组合起来形成一个单元，进行整体匹配或量词修饰。</li>
<li>[]：字符类运算符，用于匹配方括号内任意一个字符。</li>
<li>{}：重复运算符，用于指定运算分量重复出现的次数。</li>
</ul>
<p>运算分量：</p>
<ul>
<li>字符：指定具体的字符，例如 a、b、c 等。</li>
<li>元字符：具有特殊意义的字符，例如 *、?、+ 等。</li>
<li>点号：匹配除换行符以外的任意字符。</li>
</ul>
<p>这些运算符和运算分量可以组合在一起形成复杂的正则表达式，用于模式匹配和字符串搜索。</p>
<p><strong>在每一步构造的时候，最多加一个起始状态，一个终止状态，总共进行了 | r | 次，所以第三点正确</strong></p>
<p>举个例子：(a|b)*abb 的构造（考试会考）</p>
<p><img data-src="image-20230315142551213.png" alt="image-20230315142551213"></p>
<h2 id="子集构造法从nfa到dfa的转换"><a class="anchor" href="#子集构造法从nfa到dfa的转换">#</a> 子集构造法 (从 NFA 到 DFA 的转换)：</h2>
<p><img data-src="image-20230315142711571.png" alt="image-20230315142711571"></p>
<p>举个例子： 可以看出简化了很多，并且遇到某一词法单元改走到那一步更加明确了</p>
<p><img data-src="image-20230610165958021.png" alt="image-20230610165958021"></p>
<p>从 0 号状态开始，通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 转移可以到达 1,2,4,7 因此这 5 个状态合为一个状态 A，然后看 A 状态下可以通过 a 字符和 b 字符转移到哪些状态，即下图的规则三，然后利用规则二和规则一求可到达状态的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 闭包，这个过程循环下去直到结束。</p>
<p><strong>什么时候算结束？</strong></p>
<p>只要 DFA 的某个状态所对应的 NFA 中的状态集合中含有接受状态，则 DFA 的这个状态是接受状态</p>
<p><img data-src="image-20230610174226627.png" alt="image-20230610174226627"></p>
<p>这里 E 对应的 NFA 状态中有 10 号状态，而 10 号状态是 NFA 的接受状态，所以 E 也是接受状态</p>
<p>三个基本规则如下 其中 s 是单个状态 T 是一个状态子集</p>
<p>这个过程一定会有一个终点</p>
<p><img data-src="image-20230315143847385.png" alt="image-20230315143847385"></p>
<p>原理如下：</p>
<p><img data-src="image-20230315143949988.png" alt="image-20230315143949988"></p>
<p><strong>复杂度：NFA 有 n 个状态 DFA 最多有 2 的 n 次方个状态 指数爆炸</strong></p>
<h2 id="dfa最小化算法"><a class="anchor" href="#dfa最小化算法">#</a> DFA 最小化算法</h2>
<p>问题一： 如何定义等价状态</p>
<p>想法一： 其中波浪号意为等价</p>
<p>​					即 s 状态等价与 t 状态 当且仅当 任意 a 属于字母表 s 与 t 在 a 输入下发生转移后的状态是等价的</p>
<p><img data-src="image-20230320210948252.png" alt="image-20230320210948252"></p>
<p>但是这个定义是错误的 课件上有反例</p>
<p>反过来是正确做法：</p>
<p>核心思想<strong>做划分而非合并</strong></p>
<p>接受状态与非接受状态必定不等价 ，然后接着划分，直到不能再分为止。每一步做迭代 对一个状态集合的任意两个状态，如果在字符 a 的驱动下跑到了不同的组，则这两个状态一定不等价。</p>
<p><strong>做之前要补齐死状态。</strong></p>
<p>因为这是所谓的 DFA 最小化算法 首先得保证最小化的是一个 DFA。比如下图中如果一开始只有红字部分，需要加上黄字部分补成一个 DFA。</p>
<p><img data-src="image-20230622220426917.png" alt="image-20230622220426917"></p>
<p>如果某个等价类包含初始状态，那么合并后这个等价类就是初始状态，如果某个等价类包含结束状态，那么合并后这个等价类就是合并状态。</p>
<p><img data-src="image-20230610182322478.png" alt="image-20230610182322478"></p>
<h3 id="复杂度"><a class="anchor" href="#复杂度">#</a> 复杂度</h3>
<p>太复杂了</p>
<h2 id="从dfa得到词法分析器"><a class="anchor" href="#从dfa得到词法分析器">#</a> 从 DFA 得到词法分析器</h2>
<p>需要消除死状态 ，避免徒劳消耗输入流</p>
<p>模拟运行该 DFA, 直到无法继续为止（输入结束或状态无转移）：假设此时状态为 s，若 s 为接受状态，则识别成功，否则，回溯（包括状态与输入流）至最近一次经过的接受状态，识别成功；若没有经过任何接受状态，则报错（忽略第一个字符，重新开始）</p>
<p>用在词法分析器场景下的 DFA 的最小化第一步不同，所有的接受状态一定不等价</p>
<h2 id="根据dfa得到re非重点"><a class="anchor" href="#根据dfa得到re非重点">#</a> 根据 DFA 得到 RE (非重点)</h2>
<h2 id="lab-1"><a class="anchor" href="#lab-1">#</a> lab 1</h2>
<p>编程一小时 配置环境一天的典型代表。</p>
<h3 id="实验输入"><a class="anchor" href="#实验输入">#</a> 实验输入</h3>
<p>本次实验的输入是一个包含了 <code>SysY</code>  源代码的文件，你的程序需要接受一个文件名作为参数</p>
<h3 id="实验内容"><a class="anchor" href="#实验内容">#</a> 实验内容</h3>
<h3 id="part1-词法分析"><a class="anchor" href="#part1-词法分析">#</a> <span class="exturl" data-url="aHR0cDovLzQ3LjEyMi4zLjQwOjgwODEvIy8yMDIzL2xhYjEtbGV4ZXIvbGFiMS1sZXhlcj9pZD1wYXJ0MS0lRTglQUYlOEQlRTYlQjMlOTUlRTUlODglODYlRTYlOUUlOTA=">Part1 词法分析</span></h3>
<ul>
<li>本次实验你需要完成一个词法分析器对使用 SysY 语言书写的源代码进行词法分析，要求如下
<ul>
<li>本次实验要求通过<strong>标准错误输出（stderr, 如 System.err 等）</strong>， 打印程序的 <strong>所有</strong> 运行结果。</li>
<li>当<strong>包含词法错误时</strong>：对于包含词法错误的文件，你需要打印<strong>所有</strong>错误信息，格式为： <code>Error type A at Line [lineNo]:[errorMessage]</code> ，其中 <code>lineNo</code>  为出错的 <code>token</code>  首个字符所在行的行号， <code>errorMessage</code>  可自行定义，本实验不做要求，只要冒号前的信息正确即可。</li>
<li>当<strong>不包含词法错误时</strong>：对于没有任何词法错误的文件，你需要打印所有识别到的 <code>Tokens</code>  信息，具体输出格式可以参见<strong>样例一</strong>。特别要求：输出时忽略所有注释，对十六进制和八进制数字常量输出 <code>token</code>  文本时需输出其十进制的值</li>
</ul>
</li>
</ul>
<h3 id="样例"><a class="anchor" href="#样例">#</a> 样例</h3>
<p>输入</p>
<pre><code class="language-SysY">int main() 
&#123;
   // line comment
   /* 
     block comment
   */
   int i = 0x1;
&#125;
</code></pre>
<p>输出</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token constant">INT</span> <span class="token keyword">int</span> at <span class="token class-name">Line</span> <span class="token number">1.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token constant">IDENT</span> main at <span class="token class-name">Line</span> <span class="token number">1.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token constant">L_PAREN</span> <span class="token punctuation">(</span> at <span class="token class-name">Line</span> <span class="token number">1.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token constant">R_PAREN</span> <span class="token punctuation">)</span> at <span class="token class-name">Line</span> <span class="token number">1.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token constant">L_BRACE</span> <span class="token punctuation">&#123;</span> at <span class="token class-name">Line</span> <span class="token number">2.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token constant">INT</span> <span class="token keyword">int</span> at <span class="token class-name">Line</span> <span class="token number">7.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token constant">IDENT</span> i at <span class="token class-name">Line</span> <span class="token number">7.</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token constant">ASSIGN</span> <span class="token operator">=</span> at <span class="token class-name">Line</span> <span class="token number">7.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token constant">INTEGER_CONST</span> <span class="token number">1</span> at <span class="token class-name">Line</span> <span class="token number">7.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token constant">SEMICOLON</span> <span class="token punctuation">;</span> at <span class="token class-name">Line</span> <span class="token number">7.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token constant">R_BRACE</span> <span class="token punctuation">&#125;</span> at <span class="token class-name">Line</span> <span class="token number">8.</span></pre></td></tr></table></figure><p>解释：</p>
<p>每行输出一个 token 的信息，输出格式为</p>
<pre><code>[token类型] [token文本] at Line [此token首个字符所在行的行号].复制到剪贴板复制失败复制成功!
</code></pre>
<p><strong>输出时忽略所有注释，对十六进制和八进制数字常量输出 token 文本时需输出其十进制的值</strong></p>
<p>特别注意，遇到如 <code>int 2i = 08;</code>  这种输入时，请将 <code>2i</code>  识别为 <code>INTEGER_CONST</code>  和 <code>IDENT</code> ， <code>08</code>  识别为两个 <code>INTEGER_CONST</code> ，这种我们不认为是词法错误，这种错误将在后面的实验中处理</p>
<h3 id="样例二"><a class="anchor" href="#样例二">#</a> <span class="exturl" data-url="aHR0cDovLzQ3LjEyMi4zLjQwOjgwODEvIy8yMDIzL2xhYjEtbGV4ZXIvbGFiMS1sZXhlcj9pZD0lRTYlQTAlQjclRTQlQkUlOEIlRTQlQkElOEM=">样例二</span></h3>
<p>输入:</p>
<pre><code class="language-SysY">int main()&#123;
  int i = 1;
  int j = ~i;
&#125;复制到剪贴板复制失败复制成功!
</code></pre>
<p>输出：</p>
<pre><code>Error type A at Line 3: Mysterious character &quot;~&quot;.
</code></pre>
<h2 id="实验过程"><a class="anchor" href="#实验过程">#</a> 实验过程</h2>
<ul>
<li>
<p>第一个难题就是怎么在 windows 里的 IDEA 编程，但是运行和调试环境是虚拟机中的 ubuntu20.04+lab0 配置好的环境 想法就是用 IDEA 的 remote deployment 功能，在网上搜索教程后发现我的 IDEA 竟然没有这个功能，原因是我的是 community 版本，所以卸载了之前的 IDEA 装了专业版。然后 remote deployment 原理应该是使用 ssh 连接，虽然虚拟机是装在电脑里，但其实和与远程服务器相连原理是一样的。</p>
</li>
<li>
<p>然后编写.g4 文件比较顺利，生成了 SysYlexer.java 文件，但是在 main 函数中使用 SysYlexer 类也遇见了困难，首先是导入 antlr，IDEA 一直报错无法解析 symbol antlr，但是 lab0 中我应该是配好了 antlr 环境的，不知道为什么，所以还是用 IDEA 的 libraries 中导入了 antlr 才好   (回来再看，IDEA 是可以导入本地的 jar 包的)</p>
</li>
<li>
<p>第三个难题就是删除 SysYLexer 中自带的 ErrorListeners, 使用自己编写的 errorlisteners，这里蚂蚁老师上课应该是没有讲的，所以也是无从下手。后面借助搜索引擎和 ChatGPT 学了很久才会。原理很简单，先放上自己实现的 myErrorListener 如下：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> myErrorListener <span class="token keyword">extends</span> <span class="token class-name">BaseErrorListener</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syntaxError</span><span class="token punctuation">(</span><span class="token class-name">Recognizer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">></span></span> recognizer<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>								<span class="token class-name">Object</span> offendingSymbol<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>								<span class="token keyword">int</span> line<span class="token punctuation">,</span> <span class="token keyword">int</span> charPositionInLine<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>								<span class="token class-name">String</span> msg<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>								<span class="token class-name">RecognitionException</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>			<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error type A at Line "</span><span class="token operator">+</span>line<span class="token operator">+</span><span class="token string">": "</span><span class="token operator">+</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>			error <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>主要是重写了 syntaxError 这个函数，他里面的参数应该是报错相关的信息，这里只用到了 line（出错的行）和 msg（具体的报错信息），其它的是什么意思忘记了。应该是每出现一个错误就会调用一次 syntaxError 函数。</p>
</li>
<li>
<p>然后放一下 main 函数部分：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>antlr<span class="token punctuation">.</span>v4<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collection</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> error <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    	<span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>			<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"input path is required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		<span class="token class-name">String</span> source <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token class-name">CharStream</span> input <span class="token operator">=</span> <span class="token class-name">CharStreams</span><span class="token punctuation">.</span><span class="token function">fromFileName</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token class-name">SysYLexer</span> sysYLexer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SysYLexer</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		sysYLexer<span class="token punctuation">.</span><span class="token function">removeErrorListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		sysYLexer<span class="token punctuation">.</span><span class="token function">addErrorListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">myErrorListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Token</span><span class="token punctuation">></span></span> tokens <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Token</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> sysYLexer<span class="token punctuation">.</span><span class="token function">getAllTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>			<span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rulenames <span class="token operator">=</span> sysYLexer<span class="token punctuation">.</span><span class="token function">getRuleNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Token</span> token <span class="token operator">:</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>			<span class="token class-name">String</span> tokenType <span class="token operator">=</span> rulenames<span class="token punctuation">[</span>token<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>			<span class="token class-name">String</span> tokenText <span class="token operator">=</span> <span class="token function">toDemical</span><span class="token punctuation">(</span>token<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>			<span class="token class-name">String</span> tokenLine <span class="token operator">=</span> <span class="token string">""</span><span class="token operator">+</span>token<span class="token punctuation">.</span><span class="token function">getLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>			<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tokenType <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> tokenText <span class="token operator">+</span> <span class="token string">" at Line "</span><span class="token operator">+</span>tokenLine<span class="token operator">+</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> myErrorListener <span class="token keyword">extends</span> <span class="token class-name">BaseErrorListener</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syntaxError</span><span class="token punctuation">(</span><span class="token class-name">Recognizer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">></span></span> recognizer<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="33"></td><td><pre>								<span class="token class-name">Object</span> offendingSymbol<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="34"></td><td><pre>								<span class="token keyword">int</span> line<span class="token punctuation">,</span> <span class="token keyword">int</span> charPositionInLine<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="35"></td><td><pre>								<span class="token class-name">String</span> msg<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="36"></td><td><pre>								<span class="token class-name">RecognitionException</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>			<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error type A at Line "</span><span class="token operator">+</span>line<span class="token operator">+</span><span class="token string">": "</span><span class="token operator">+</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>			error <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre></pre></td></tr><tr><td data-num="44"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">toDemical</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>		<span class="token keyword">if</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"0[0-7]+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>			<span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"0[xX][0-9a-fA-F]+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>			<span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>			<span class="token keyword">return</span> text<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>反正做的时候除了文档里给的框架几乎每一行都想了很久。</p>
</li>
<li>
<p>代码写完后上传又有问题，可能是之前 make compile , make clean 太多次了，导致压缩包超过了 10M 的限制，后来参考助教给的<span class="exturl" data-url="aHR0cHM6Ly93d3cuaG9sbGlzY2h1YW5nLmNvbS9hcmNoaXZlcy8xNzA4">记一次删除 Git 记录中的大文件的过程 - HollisChuang's Blog</span> 按里面的步骤一步步做才完成上传，比较幸运的是一次就 AC 了。（至于为什么压缩包会那么大，我的理解是改动了太多次代码 make compile 了太多次，且每次 git 都会保存版本信息以便于回退，所以改动的所有版本其实都还在 git 保存的隐藏文件夹下的，所以整个目录就会变得很大了）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理03-语义分析</title>
    <url>/2023/04/12/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8603-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="语义分析"><a class="anchor" href="#语义分析">#</a> 语义分析</h1>
<h2 id="符号表"><a class="anchor" href="#符号表">#</a> 符号表</h2>
<p><img data-src="image-20230412154717575.png" alt="image-20230412154717575"></p>
<p>用符号表保存我们已经定义了的变量或者函数以及其相关信息，在遍历语法分析树时，如果发现当前新出现的某些单元与符号表中的信息有冲突，我们就可以发现语义错误。</p>
<h3 id="实现符号表"><a class="anchor" href="#实现符号表">#</a> 实现符号表</h3>
<p>首先构建作用域树：</p>
<p><img data-src="image-20230419140503102.png" alt="image-20230419140503102"></p>
<p><strong>我们在这里犯了一个小错误</strong>，即把函数参数的作用域单独独立出来了，以便于我们编码，实际上函数参数作用域和函数作用域应该是要合并的。</p>
<p>作用域的指针指向父作用域，在查找某个变量是在哪个作用域时要循环从当前作用域到父作用域遍历。</p>
<p>之后可以通过递归遍历等方式进行语义相关的检查。</p>
<p>某个利用 antlr4 实现符号表的类图：</p>
<p>scope 是作用域（持有一个 Map (name, symbol) 的符号表数据类型），symbol 是符号 (持有 name 和 type，是符号表的基本单元)，type 是符号所持有的类型（比如基本类型，array), 通过遍历时</p>
<p><img data-src="image-20230419141503552.png" alt="image-20230419141503552"></p>
<p>浅绿框起来的是接口。</p>
<h2 id="属性文法"><a class="anchor" href="#属性文法">#</a> 属性文法</h2>
<h3 id="为什么要引入属性文法"><a class="anchor" href="#为什么要引入属性文法">#</a> 为什么要引入属性文法</h3>
<p>之前引入上下文无关文法的时候，是因为正则表达式无法表达 a<sup>nb</sup>n 这样的表达式，但是上下文无关文法也有局限，<strong>无法帮助我们进行语义相关的检查</strong>。于是引入 Knuth 发明的属性文法。</p>
<p><img data-src="image-20230421140916771.png" alt="image-20230421140916771"></p>
<p>接下来以实现一个<strong>交互式</strong>的简易计算器为例</p>
<p>前几节课写的简易计算器采用的是 offline 的方法：<br>
<img data-src="image-20230421141650214.png" alt="image-20230421141650214"></p>
<p>本次将采用 online 的方式实现，即在构建语法分析树的过程中加入我们想实现的 action。</p>
<p><img data-src="image-20230421142018201.png" alt="image-20230421142018201"></p>
<p>之前实现计算器的时候遇到了一个问题，listener 模式下，访问某个节点的 enterXXX 与 exitXXX 方法没有返回值，而当前节点的 value 依赖于子节点 value 的值，当时采用了标注语法树的方法。</p>
<p>antlr4 的另一个解决方案：</p>
<p><img data-src="image-20230421143635663.png" alt="image-20230421143635663"></p>
<p>在.g4 文件的 expr 定义后 加上 returns [int val] 后，在 antlr4 生成的 expr 对应的节点类中会附带一个 val 属性。</p>
<p>每一行后大括号裹起来的黑体字是会在语法分析时我们加入的 java 代码，具体可在生成的 parser 类中查看。之后在 @package 中加入需要的头文件并在 @members 中加入 eval，memory 等的 java 实现。(实际上可在 @parser::members 中加入，这样在 lexer 中就不会生成这些无用的代码)</p>
<p>像 expr 这种从子节点的 expr 值计算得到的属性，叫做综合属性。</p>
<p>至于 “交互式” 的实现，主要是 main 函数的实现方式，参照代码仓库。</p>
<p>第二个例子：类型声明文法：</p>
<p><img data-src="image-20230421145230801.png" alt="image-20230421145230801"></p>
<p>第一条语义规则的问题：将 L 的类型赋值为 T 的类型，可是在递归调用的时候，L 并不知道 T 返回了一个类型是 float 还是 int。</p>
<p>解决方法，给 L 一个 inh (inherit) 属性值，这种从左兄弟或者父节点继承来的值，叫做继承属性。</p>
<p><img data-src="image-20230421151150679.png" alt="image-20230421151150679"></p>
<p>antlr4 实现的语法：<br>
<img data-src="image-20230421151912395.png" alt="image-20230421151912395"></p>
<p>vars [String typeStr] 代表 vars 节点将携带一个属性 TypeStr。</p>
<h3 id="语法制导定义"><a class="anchor" href="#语法制导定义">#</a> 语法制导定义</h3>
<p><img data-src="image-20230421152800113.png" alt="image-20230421152800113"></p>
<p>像上面的 g4 语法定义都属于 SDD，每个节点可以有多个属性</p>
<p><img data-src="image-20230421153313913.png" alt="image-20230421153313913"></p>
<p><img data-src="image-20230421153702902.png" alt="image-20230421153702902"></p>
<p>继承属性用于在表达式中从左向右传递中间计算结果</p>
<p>比如：累乘的右递归文法</p>
<p><img data-src="image-20230421154158430.png" alt="image-20230421154158430"></p>
<p><img data-src="image-20230421154959302.png" alt="image-20230421154959302"></p>
<p>信息流向：先从左到右利用继承属性传递信息，再利用综合属性从下到上传递信息。</p>
<p>属性文法的本质：信息的有序流动</p>
<h3 id="l属性定义"><a class="anchor" href="#l属性定义">#</a> L 属性定义</h3>
<p><img data-src="image-20230426140830620.png" alt="image-20230426140830620"></p>
<p>例子 1：</p>
<p>用属性文法实现得到表达式的后缀表示形式</p>
<p><img data-src="image-20230426141239902.png" alt="image-20230426141239902"></p>
<p><img data-src="image-20230426141906728.png" alt="image-20230426141906728"></p>
<p>例子 2：得到数组的类型表达式</p>
<p><strong>比如 int [2] [3] -&gt; (2,(3,int))</strong></p>
<p><img data-src="image-20230504101715454.png" alt="image-20230504101715454"></p>
<p><img data-src="image-20230426142516412.png" alt="image-20230426142516412"></p>
<p>antlr4 实现文法：<br>
<img data-src="image-20230426143619377.png" alt="image-20230426143619377"></p>
<p>例子 3：判断赋值号左右类型是否相等</p>
<p><img data-src="image-20230426151226852.png" alt="image-20230426151226852"></p>
<p>数组声明相关文法已经在例子 2 中完成了。</p>
<p><img data-src="image-20230504121851839.png" alt="image-20230504121851839"></p>
<p>具体代码可在 github 代码仓库中查找。</p>
<p>属性文法缺点：要在 antlr 中编写 java 代码，而且要完成编译器的话会需要很多代码，这些代码与 antlr 的文法混合在一起。</p>
<h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2>
<p><img data-src="image-20230426152847006.png" alt="image-20230426152847006"></p>
<p>两种语义分析方法，各有优势。Offline 简单，Online 性能更高。</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理02-语法分析</title>
    <url>/2023/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8602-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="编译原理02-语法分析"><a class="anchor" href="#编译原理02-语法分析">#</a> 编译原理 02 - 语法分析</h1>
<p>主要内容：如何用 antlr4 生成一个语法分析器。手写语法分析器比较困难，不作要求。</p>
<p>lesson1 任务： 用 cymbol 语言（龙书中提供的一种简化版 c 语言）写一段程序，并生成如下的函数调用关系图。</p>
<p><img data-src="image-20230326120955042.png" alt="image-20230326120955042"></p>
<p>lesson2 任务：写一个简单的计算器</p>
<p>在为自己的语言编写语法分析器时，可能会遇到一些问题。</p>
<h2 id="问题一二义性文法"><a class="anchor" href="#问题一二义性文法">#</a> 问题一：二义性文法</h2>
<p>考虑下列定义：</p>
<p><img data-src="image-20230324142546278.png" alt="image-20230324142546278"></p>
<p><code>if a then if b then c else d</code>  可以有两种解释</p>
<p><img data-src="image-20230324142701632.png" alt="image-20230324142701632"></p>
<p>龙书上给的无二义性语法：</p>
<p><img data-src="image-20230324143323221.png" alt="image-20230324143323221"></p>
<p>难题是如何证明没有二义性（见龙书）</p>
<p>在 antlr4 中，写在前面的定义如果能被匹配到，就会优先选择写在前面的定义，以防止歧义出现的错误。</p>
<h3 id="运算符的结合性带来的二义性"><a class="anchor" href="#运算符的结合性带来的二义性">#</a> 运算符的结合性带来的二义性</h3>
<p><img data-src="image-20230324143744282.png" alt="image-20230324143744282"></p>
<p>没有规定是左结合还是右结合，可以有两种解释，导致结果不一样。</p>
<p>antlr4 规定运算符默认是左结合的，以消除这种歧义。</p>
<p>如何明确指明是右结合的（如乘方运算符要规定为右结合的）：</p>
<p><img data-src="image-20230324143947465.png" alt="image-20230324143947465"></p>
<h3 id="运算符优先级带来的二义性"><a class="anchor" href="#运算符优先级带来的二义性">#</a> 运算符优先级带来的二义性</h3>
<p><img data-src="image-20230324144400266.png" alt="image-20230324144400266"></p>
<p>在 antlr4 里，写在前面的运算符优先级更高。</p>
<p>如果不是 antlr4，比如在某些比较古老的工具中，需要我们自己处理。</p>
<h2 id="如何根据代码生成函数调用图"><a class="anchor" href="#如何根据代码生成函数调用图">#</a> 如何根据代码生成函数调用图</h2>
<p>先用 antlr4 生成语法分析树，然后用 dfs 方法遍历语法树。</p>
<h3 id="铺垫"><a class="anchor" href="#铺垫">#</a> 铺垫</h3>
<p>antlr4 提供了 listener, 在 antlr 帮我们遍历语法树时，当 antlr4 进入一类节点时，会触发 enter 节点事件，离开时会触发 exit 节点事件。</p>
<p>问题：需要细分，比如函数调用和 赋值语句都是 expr，那么进入 expr 节点的时候都会触发 enterExpr 事件，不好针对特定情况处理。</p>
<p>情况一：</p>
<p>​	function call 和 赋值语句都是 expr，因此触发了 enterExpr 时间后也无法细分是哪类 expr。</p>
<p>解决方法：在 g4 文件对应的定义后加上  <code># fuctioncall</code> , 要加的话后面的也要加上</p>
<p>情况二： <code>expr ('*' |  '/') expr</code>  被定义为 MutiDiv, 则进入 MutiDiv 的时候不知道是还是除法。</p>
<p>解决方法：</p>
<p><code> expr (op = '*' | op = '/') expr</code>  进入时判断变量 op 的值是什么便可</p>
<h2 id="如何生成一个调用图"><a class="anchor" href="#如何生成一个调用图">#</a> 如何生成一个调用图</h2>
<p>按 Graphviz 语法编写.dot 文件，会自动生成调用图</p>
<p><img data-src="image-20230326201151771.png" alt="image-20230326201151771"></p>
<h2 id="实现一个简单的计算器"><a class="anchor" href="#实现一个简单的计算器">#</a> 实现一个简单的计算器</h2>
<h3 id="listener模式的一个弊端"><a class="anchor" href="#listener模式的一个弊端">#</a> listener 模式的一个弊端</h3>
<p>antlr 提供的 listener 模式方法的返回值是 void，但是我们想实现一个计算器的话，在 dfs 语法树的时候就必须利用子节点的值来计算。为了解决这个问题，antlr4 提供了一个标注（Annotate) 语法树的功能。</p>
<p>eg:</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//calcuListener 里的方法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exitParens</span><span class="token punctuation">(</span><span class="token class-name">CymbolParser<span class="token punctuation">.</span>ParensContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	values<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span>values<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exitAddSub</span><span class="token punctuation">(</span><span class="token class-name">CymbolParser<span class="token punctuation">.</span>AddSubContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">int</span> lvalue <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//lhs (left hand side) 在.g4 文件中赋值为前面的 expr</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">int</span> rvalue <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>op<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">ADD</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		values<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> lvalue<span class="token operator">+</span>rvalue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		values<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span>lvalue<span class="token operator">-</span>rvalue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="上下文无关文法"><a class="anchor" href="#上下文无关文法">#</a> 上下文无关文法</h2>
<p><img data-src="image-20230329150049799.png" alt="image-20230329150049799"></p>
<p>编写 g4 文件时实际上用的就是上下文无关文法</p>
<h3 id="什么是上下文相关文法"><a class="anchor" href="#什么是上下文相关文法">#</a> 什么是上下文相关文法</h3>
<p><img data-src="image-20230329150412566.png" alt="image-20230329150412566"></p>
<p>以第三行与第七行为例：B 是展开为 Z 还是 b 与它的上下文（这里是前面的字符）有关</p>
<p>这段文法表示的是 a<sup>n*b</sup>n*c^n ，可以证明用上下文无关文法是无法描述这个语言的。</p>
<h3 id="推导"><a class="anchor" href="#推导">#</a> 推导</h3>
<p><img data-src="image-20230329150648976.png" alt="image-20230329150648976"></p>
<p><img data-src="image-20230329150810626.png" alt="image-20230329150810626"></p>
<h3 id="为什么不使用正则表达式去描述语法"><a class="anchor" href="#为什么不使用正则表达式去描述语法">#</a> 为什么不使用正则表达式去描述语法</h3>
<p><img data-src="image-20230329153448085.png" alt="image-20230329153448085"></p>
<p>证明如下：</p>
<p><img data-src="image-20230329153850498.png" alt="image-20230329153850498"></p>
<p>其中 Ai 对应的是 DFA 中的第 i-1 个状态</p>
<p><img data-src="image-20230329154356116.png" alt="image-20230329154356116"></p>
<p>因为 m &gt; k, 所以一定存在状态 si ，在 si 停留了两次，假设又经过了 j 步能够到达第二次 si</p>
<p>根据假设，a<sup>ib</sup>i 能够到达终止状态，那么 a<sup>(i+j)b</sup>i 也能到达终止状态，与假设矛盾，证明完毕。</p>
<h2 id="ll1语法分析器"><a class="anchor" href="#ll1语法分析器">#</a> LL (1) 语法分析器</h2>
<h3 id="总览"><a class="anchor" href="#总览">#</a> 总览</h3>
<p><img data-src="image-20230411205542981.png" alt="image-20230411205542981"></p>
<p><img data-src="image-20230331143754540.png" alt="image-20230331143754540"></p>
<h3 id="自顶向下的含义"><a class="anchor" href="#自顶向下的含义">#</a> 自顶向下的含义</h3>
<p><img data-src="image-20230331140837017.png" alt="image-20230331140837017"></p>
<h3 id="两个l的含义"><a class="anchor" href="#两个l的含义">#</a> 两个 L 的含义</h3>
<p><img data-src="image-20230331141034044.png" alt="image-20230331141034044"></p>
<h3 id="递归下降的含义"><a class="anchor" href="#递归下降的含义">#</a> 递归下降的含义</h3>
<p><img data-src="image-20230331141214747.png" alt="image-20230331141214747"></p>
<p>eg: 先默认选择产生式的问题已经被解决了，只演示递归下降的过程</p>
<p><img data-src="image-20230331141731554.png" alt="image-20230331141731554"></p>
<p><img data-src="image-20230331142317647.png" alt="image-20230331142317647"></p>
<h3 id="如何选择产生式"><a class="anchor" href="#如何选择产生式">#</a> 如何选择产生式</h3>
<p><img data-src="image-20230331142728269.png" alt="image-20230331142728269"></p>
<p><img data-src="image-20230331142916987.png" alt="image-20230331142916987"></p>
<h3 id="什么是ll1文法"><a class="anchor" href="#什么是ll1文法">#</a> 什么是 LL (1) 文法</h3>
<p><img data-src="image-20230331143057195.png" alt="image-20230331143057195"></p>
<p><strong>LL（1）中 1 的含义：只需要查看当前的输入符号就可以确定选择哪条产生式进行展开</strong></p>
<h3 id="ll1的伪代码"><a class="anchor" href="#ll1的伪代码">#</a> LL (1) 的伪代码</h3>
<p><strong>假设预测分析表已经有了</strong></p>
<p><img data-src="image-20230331143540005.png" alt="image-20230331143540005"></p>
<p><img data-src="image-20230331143718582.png" alt="image-20230331143718582"></p>
<h3 id="难点如何生成预测分析表"><a class="anchor" href="#难点如何生成预测分析表">#</a> 难点：如何生成预测分析表</h3>
<p><img data-src="image-20230331150322238.png" alt="image-20230331150322238"></p>
<p>竖着看：什么时候选择展开为 func_call, 还是 decl。很简单，看当前输入的前面是 int 还是 ID。</p>
<p>横着看：如何确定 optional_init 是否展开为空串</p>
<p>问题：什么时候可以选择空串展开？ 见后</p>
<p><img data-src="image-20230331151147854.png" alt="image-20230331151147854"></p>
<p><img data-src="image-20230331151439293.png" alt="image-20230331151439293"></p>
<p><img data-src="image-20230331151512669.png" alt="image-20230331151512669"></p>
<p><img data-src="image-20230331152131492.png" alt="image-20230331152131492"></p>
<p>为什么中间两步要去除空串，比如：因为即使 Y1 可以被展开为空串，后面的 Y2-YK 不一定能展开为空串，X 的开头不一定是空串。空串要单独判断</p>
<p><img data-src="image-20230331152345075.png" alt="image-20230331152345075"></p>
<p><img data-src="image-20230411223059716.png" alt="image-20230411223059716"></p>
<p>dollar 符是文件结束符号</p>
<p>因为 follow 集合考虑的是终结符，所以规则 3 要去掉空串</p>
<p><img data-src="image-20230407140712901.png" alt="image-20230407140712901"></p>
<p>例子：</p>
<p><img data-src="image-20230407140907285.png" alt="image-20230407140907285"></p>
<p>这个例子中只看 c 无法确定 Y 是由 3 号还是 4 号规则展开，则不是 LL (1) 文法</p>
<h3 id="非递归的预测分析算法不作要求"><a class="anchor" href="#非递归的预测分析算法不作要求">#</a> 非递归的预测分析算法（不作要求）</h3>
<p><img data-src="image-20230407141535578.png" alt="image-20230407141535578"></p>
<h2 id="改造为ll1文法"><a class="anchor" href="#改造为ll1文法">#</a> 改造为 LL (1) 文法</h2>
<p><img data-src="image-20230407141907838.png" alt="image-20230407141907838"></p>
<p>为什么左递归不是 LL (1) 文法：</p>
<p>LL (1) 的递归下降算法会出问题：</p>
<p>E 展开为 E+T，然后 E+T 中的 E 展开为 E+T。。。</p>
<p><img data-src="image-20230407142036246.png" alt="image-20230407142036246"></p>
<p><img data-src="image-20230407142224345.png" alt="image-20230407142224345"></p>
<p>问题：改写成右递归比较复杂，而且改造后可读性较差</p>
<h3 id="直接左递归的改造"><a class="anchor" href="#直接左递归的改造">#</a> 直接左递归的改造</h3>
<p>改造的模板：</p>
<p><img data-src="image-20230407142538910.png" alt="image-20230407142538910"></p>
<h3 id="间接左递归的改造"><a class="anchor" href="#间接左递归的改造">#</a> 间接左递归的改造</h3>
<p><img data-src="image-20230407142905861.png" alt="image-20230407142905861"></p>
<p>思路：改造后的文法中的每一条展开式都应该满足红框里的条件 因为展开后的编号越来越大，就永远回不到自己。</p>
<p>例子：</p>
<ol>
<li>首先对所有的非终结符编号： S：A1， A：A2， B：A3</li>
<li>看所有的非终结符的展开式是否满足单调递增性质</li>
</ol>
<p><img data-src="image-20230407143533868.png" alt="image-20230407143533868"></p>
<ol start="3">
<li>发现 B-&gt; Sa|a 不满足改造条件， 将非终结符慢慢展开，发现展开为最后一行时变成了直接左递归，直接左递归用上面的方法处理。</li>
</ol>
<h3 id="左递归改造算法要求"><a class="anchor" href="#左递归改造算法要求">#</a> 左递归改造算法要求：</h3>
<p><img data-src="image-20230407143729991.png" alt="image-20230407143729991"></p>
<h3 id="左公因子的改造"><a class="anchor" href="#左公因子的改造">#</a> 左公因子的改造</h3>
<p><img data-src="image-20230407144035629.png" alt="image-20230407144035629"></p>
<p>为什么左公因子不行 ，比如第八行原来的 decl 内容，两个展开式开头都是 'int'。</p>
<p>改造方法简单，如第 13 行的定义</p>
<h2 id="adaptive-ll语法分析算法"><a class="anchor" href="#adaptive-ll语法分析算法">#</a> Adaptive LL (*) 语法分析算法</h2>
<p>也称 ALL STAR 算法，antrl4 采用这种算法</p>
<p>ChatGPT 评价：</p>
<p><img data-src="image-20230407144342359.png" alt="image-20230407144342359"></p>
<p>第 2,3 行 含有 LL (1) 的特性：不用猜测 自顶向下</p>
<p>第 4 行： 解决二义性</p>
<p>第 7 行：解决左递归</p>
<p><img data-src="image-20230407145002698.png" alt="image-20230407145002698"></p>
<h3 id="antrl4对左递归的改造将左递归改造成循环迭代"><a class="anchor" href="#antrl4对左递归的改造将左递归改造成循环迭代">#</a> antrl4 对左递归的改造，将左递归改造成循环 (迭代)</h3>
<p><img data-src="image-20230407150629592.png" alt="image-20230407150629592"></p>
<p>参数_p 指的是优先级，优先级按下面书写的顺序（ID 1,INT 2, 加法 3 乘法 4） 当 3 &gt;= _p 时 才能展开为加法。展开后变成了 expr [4]，优先级升了一级（优先级上升算法名称的由来）</p>
<p><img data-src="image-20230407152404434.png" alt="image-20230407152404434"></p>
<p>以 1+2+3 为例，右侧手写部分为算法伪代码</p>
<p><img data-src="image-20230407152625774.png" alt="image-20230407152625774"></p>
<p>以 1+2*3 为例</p>
<h3 id="右结合运算符的处理"><a class="anchor" href="#右结合运算符的处理">#</a> 右结合运算符的处理</h3>
<p>想让一个运算符为右结合，再递归调用的时候传入的优先级应该不变。</p>
<h2 id="antlr4是如何进行错误报告的"><a class="anchor" href="#antlr4是如何进行错误报告的">#</a> antlr4 是如何进行错误报告的</h2>
<p><img data-src="image-20230407154816857.png" alt="image-20230407154816857"></p>
<p>LexerNoViableAltException: 词法分析的时候遇到未知字符，出现错误</p>
<p>NoViableAltException: 面对当前的输入时，要展开当前的非终结符，发现没有备选分支可选</p>
<p>InputMismatchException: 根据选择好的备选分支展开时，发生终结符不匹配错误。</p>
<p><strong>antlr4 的强大之处在于其报错之后不会马上结束程序，而是以报错， 恢复， 继续分析的流程来解析程序</strong></p>
<h3 id="antlr4的基本策略"><a class="anchor" href="#antlr4的基本策略">#</a> antlr4 的基本策略</h3>
<p><img data-src="image-20230412141343590.png" alt="image-20230412141343590"></p>
<p><strong>四项基本原则</strong>：</p>
<ul>
<li>特殊情况，特殊处理</li>
<li>一般情况，统一处理</li>
<li>统一处理，精细控制</li>
<li>自定义错误处理策略</li>
</ul>
<h3 id="特殊情况特殊处理"><a class="anchor" href="#特殊情况特殊处理">#</a> 特殊情况，特殊处理</h3>
<p><img data-src="image-20230412141619597.png" alt="image-20230412141619597"></p>
<p>单词法符号移除： class <strong>9</strong> T {int i;} 9 会被移除</p>
<p>单词法符号补全： class {int i;} 会在 class 后面补一个符号</p>
<h3 id="一般情况统一处理"><a class="anchor" href="#一般情况统一处理">#</a> 一般情况，统一处理</h3>
<p><img data-src="image-20230417235837973.png" alt="image-20230417235837973"></p>
<p>例子：</p>
<p><img data-src="image-20230412142107657.png" alt="image-20230412142107657"></p>
<p>antlr4 看到一个中括号，可以报错：中间缺失一个 expr</p>
<p>antlr 通过递归调用匹配，发现当前终结符匹配不了，于是递归返回，每一层看当前符号是不是一个<strong>想要的符号</strong>（所谓想要的符号，即假装当前想匹配的非终结符已经匹配成功，接下来应该遇到什么终结符，类似 Follow 集合，但不等价，称为 Following 集合）, 恢复到 expr 层，假装 expr 已经匹配成功，右中括号可以匹配，然后继续解析后面的。</p>
<p>注意 Follow（静态）集合与 Following（动态）集合的区别。</p>
<p>恢复时的动作是：丢弃词法单元直到碰到当前 Following 集合中的某个词法单元，然后从当前规则中恢复，也就是返回上一层，继续分析。比如，在 [] 例子中（见上图），atom 期望 INT/ID，与] 不匹配，则不断丢弃输入中的词法单元，直到遇到 ^ 或者 ]。对于这个例子，恰巧当前词法单元就是 ]，所以并没有丢弃任何词法单元，就能从 atom 中恢复，返回到 expr 层。expr 期望看到 ^，与 ] 也不匹配，则不断丢弃词法单元直到遇到 ]。这里同样也没有丢弃任何词法单元，就能从 expr 中恢复，返回到 group 层。group 期望看到 ]，与当前词法单元匹配，成功恢复。</p>
<h3 id="统一处理精细控制"><a class="anchor" href="#统一处理精细控制">#</a> 统一处理，精细控制</h3>
<p><img data-src="image-20230412143257921.png" alt="image-20230412143257921"></p>
<p>所谓优雅：即以最小的代价恢复过来</p>
<p>例子：</p>
<p><img data-src="image-20230412143706102.png" alt="image-20230412143706102"></p>
<p>类的文法定义为 <em><strong>class ID { member+ }</strong></em></p>
<p>不优雅的错误恢复：匹配 member 的时候，看到 y 不属于一个 member，直接退出 while 循环，即整个 member + 匹配失败。</p>
<p>优雅的错误恢复，相当于在匹配 member 的 while 循环中加了一个 continue，继续匹配之后的 member。</p>
<h3 id="自定义错误处理策略"><a class="anchor" href="#自定义错误处理策略">#</a> 自定义错误处理策略</h3>
<p>比如，（已知语法正确）关闭默认错误处理功能，提高运行效率</p>
<p>比如，（出错代价太大）在遇到第一个语法错误时，就停止分析</p>
<p>使用 antrl4 提供的 strategy 模式：</p>
<p><img data-src="image-20230412144102502.png" alt="image-20230412144102502"></p>
<h2 id="all-star算法的基本思想-构建lookahead-dfa"><a class="anchor" href="#all-star算法的基本思想-构建lookahead-dfa">#</a> All Star 算法的基本思想  构建 lookahead DFA</h2>
<p>例子：</p>
<p><img data-src="image-20230418234205988.png" alt="image-20230418234205988"></p>
<p>这个文法不属于 LL（k) 文法 因为它表示的字符串为 **(a*b)(c|d)**。但给出 bc 或 bd antlr4 能判断出从 Ac 和 Ad 哪条展开式展开。</p>
<p><img data-src="image-20230412150939866.png" alt="image-20230412150939866"></p>
<p>对每一个非终结符都画一个增强迁移网络 ATN (Augmented Transitjion Network), 如上图所示。All star 算法的核心思想: **Incrementally and dynamically build up a lookahead DFA that map lookahead phrases to predicated productions.** 关键：增量式构造，“向前看” DFA。</p>
<p>lookahead DFA 作用：帮助选择备选分支。（比如当看到 S 不知道选哪条展开式，使用 DFA 辅助判断）。</p>
<p>策略：既然不知道要选哪条备选分支，就并行地探索所有的备选分支。</p>
<p><img data-src="image-20230412151956767.png" alt="image-20230412151956767"></p>
<p>期望情况：只有一条路径成功走到了最后</p>
<p>有歧义问题：多条路径还在走的时候，没有了输入，或者多条路径处理时汇合。</p>
<p><img data-src="image-20230412154019808.png" alt="image-20230412154019808"></p>
<p>每个状态有三个分量：第一个是状态名，第二个是选择的备选分支，第三个分量表示递归调用完当前 DFA 后到达的状态。状态是怎么定的：注意通过 ε 能到达的节点是分不开的。（求每个节点的 ε 闭包）</p>
<p>看到 d 和 c 后就能发现第二个分量分离了，即能确定用哪条分支展开了。</p>
<h2 id="lr0-语法分析器"><a class="anchor" href="#lr0-语法分析器">#</a> LR (0) 语法分析器</h2>
<p>LL (k) 的弱点：</p>
<p>​	在仅看到右部的前 k 个词法单元时就必须预测要使用哪条产生式</p>
<p>LR (k) 的优点：</p>
<p>​	看到与正在考虑的这个产生式的整个右部对应的词法单元之后再决定</p>
<p><img data-src="image-20230524141208555.png" alt="image-20230524141208555"></p>
<p><img data-src="image-20230524141434136.png" alt="image-20230524141434136"></p>
<p><img data-src="image-20230524141809217.png" alt="image-20230524141809217"></p>
<p>rm： right most 最右推导</p>
<p>为什么是最右推导：</p>
<p>​		因为规约的顺序实际上是一个反向最右推导的过程，为了我们要从左往右扫描输入相匹配</p>
<p><img data-src="image-20230524142410243.png" alt="image-20230524142410243"></p>
<p><img data-src="image-20230524142507347.png" alt="image-20230524142507347"></p>
<p><img data-src="image-20230524143658693.png" alt="image-20230524143658693"></p>
<p>在栈中，交替进行移入和规约操作</p>
<p>问题转化为：</p>
<p><img data-src="image-20230524143738090.png" alt="image-20230524143738090"></p>
<p><img data-src="image-20230524143946746.png" alt="image-20230524143946746"></p>
<p>利用 LR 分析表指导语法分析过程：</p>
<p><img data-src="image-20230524144146911.png" alt="image-20230524144146911"></p>
<p>一开始处于 0 号状态，看到当前词法单元为 id，进行 s5 操作。</p>
<p>s5 操作含义：</p>
<p>​	s： shift 移入， 将 id 移入栈中</p>
<p>​	5： 调整当前语法分析器状态为 5</p>
<p>​	然后要右移指向当前词法单元的指针（小点）</p>
<p><img data-src="image-20230524144356599.png" alt="image-20230524144356599"></p>
<p>右边 “GOTO” 的小表中的数字前应该有一个 g</p>
<p>比如 0 号状态下压入一个 F ，查表发现应该实现 g3，即将 F 压入栈，转向 3 号状态。</p>
<h3 id="栈上操作"><a class="anchor" href="#栈上操作">#</a> “栈” 上操作</h3>
<p><img data-src="image-20230623163900518.png" alt="image-20230623163900518"></p>
<p>一开始栈中不为空，要压入一个 s0，表示起始处于 0 号状态，s 表示开始。</p>
<ol>
<li>遇到 id 查表发现 0 号状态遇到 id 是 s5，则将 id 压入栈中，并在右边加上数字 5 表示当前处于 5 号状态。即压入 id5。指针右移指向 * 号。</li>
<li>查表，5 号状态遇到 * 号，做 r6 操作。用 6 号产生式规约，将栈顶的 id5 弹出，此时底下剩一个 s0，处于 0 号状态，然后要压入 F，查表，0 号状态移入 F 要 g3，压入 F3，转向 3 号状态。<strong>指针不变</strong>。</li>
<li>。。。</li>
</ol>
<h3 id="lr分析表如何生成"><a class="anchor" href="#lr分析表如何生成">#</a> LR 分析表如何生成</h3>
<p><img data-src="image-20230524151050006.png" alt="image-20230524151050006"></p>
<p>什么是句柄：</p>
<p><img data-src="image-20230524151111643.png" alt="image-20230524151111643"></p>
<h3 id="一个永远正确的定理"><a class="anchor" href="#一个永远正确的定理">#</a> 一个永远正确的定理</h3>
<p><strong>这个定理的推导不需掌握，但是这个定理是正确的</strong></p>
<p><img data-src="image-20230524151625361.png" alt="image-20230524151625361"></p>
<p><img data-src="image-20230524152213719.png" alt="image-20230524152213719"></p>
<p>LR 自动机在追踪所有产生式的状态</p>
<p>小点表示当前追踪到了哪一个位置</p>
<p><img data-src="image-20230623170950451.png" alt="image-20230623170950451"></p>
<h3 id="增广文法"><a class="anchor" href="#增广文法">#</a> 增广文法</h3>
<p><img data-src="image-20230524152728413.png" alt="image-20230524152728413"></p>
<p>S 是开始符号，仅仅是技术上的一些处理。</p>
<h3 id="lr0状态机的构造"><a class="anchor" href="#lr0状态机的构造">#</a> LR (0) 状态机的构造</h3>
<p><img data-src="image-20230524153005769.png" alt="image-20230524153005769"></p>
<p><strong>如果要期望看到的文法符号串开头是一个非终结符，要做闭包！</strong></p>
<p>比如 0 号状态一开始只有 E'-&gt; . E</p>
<p>下面想要看到一个 E，但是 E 是一个非终结符，它可以展开为 1 号和 2 号产生式，2 号产生式又可以做闭包，直到所有产生式都包含进来了。</p>
<p>LR (0) 语法分析器在做句柄识别的时候，依赖的是一个 LR (0) 句柄识别有穷状态机</p>
<p>eg：</p>
<p><strong>I1 状态是怎么构造的？</strong></p>
<p>I0 看到一个 E，发现满足第一行和第二行的需求，于是将第一行与第二行移入 I1，并将小点右移。</p>
<p><strong>I4 状态是怎么构造的？</strong></p>
<p>I0 状态看到（ ，发现倒数第二行满足，于是将倒数第二行移入 I4，并将小点右移，然后发现接下来期望看到的 E 是一个非终结符，于是对 E 进行闭包展开。</p>
<p><img data-src="image-20230623173005062.png" alt="image-20230623173005062"></p>
<p>哪些是接受状态？ 图中红框圈出来的是，因为其中包含了一些项，小点已经走到了末尾，表示发现了一个完整的句柄。而至于要不要规约，是接下来的事。</p>
<h3 id="根据lr0自动机怎么构建分析表"><a class="anchor" href="#根据lr0自动机怎么构建分析表">#</a> 根据 LR (0) 自动机怎么构建分析表</h3>
<p><img data-src="image-20230524154927521.png" alt="image-20230524154927521"></p>
<p>可以看到，这张表与之前的那张表不太一样。之前的表是在构造了 LR (0) 语法分析器后，<strong>利用 SLR</strong> 的语法规范构造的表。而上图的表是利用 LR (0) 的规范构造的。</p>
<p>如何填写右边的表？</p>
<p>先填所有的 s 和 g。比如 0 号状态碰到 id 变到 5 号状态，则在 action 对应位置填入 s5。0 号状态碰到 E 进入 1 号状态，则在 goto 表中填入 g1。这是前两条规则。</p>
<p>填 r 的规则如下图的规则 3，在 LR (0) 中，如果碰到了可以做规约的第 k 个表达式，并且表达式的左部不是增广文法中的开始条件，则在 action 表对应位置填入 rk。</p>
<p>比如下图中的 I2 状态有一个可以规约的 E-&gt;T. 其中 E—&gt;T 对应 2 号产生式，则在 2 号状态下遇到所有的符号都做规约，即 2 号产生式对应的行都填入 r2。同理 10 号产生式对应的行都填入 r3</p>
<p><img data-src="image-20230531140938844.png" alt="image-20230531140938844"></p>
<p>之前规定了 A 不能是开始符号，如果是开始符号，采用规则 4。</p>
<p><img data-src="image-20230531141121981.png" alt="image-20230531141121981"></p>
<p>四条规则总结：</p>
<p><img data-src="image-20230531141214903.png" alt="image-20230531141214903"></p>
<p>要求 A 不是增广文法中扩展的 S'</p>
<p><img data-src="image-20230531141304037.png" alt="image-20230531141304037"></p>
<p>上表中 s7,s2 s7,s1 有移入规约冲突，所以不是 LR (0) 文法</p>
<p>以 2 号产生式 E-&gt;T 为例，可以求出 FOLLOW (E) = {+,),$} 如果在二号状态遇到了 * 号，如果进行 r2 操作，即将栈里的 T 变成 E，则现在 E 的后边就跟着一个 * 号了 这是错误的。</p>
<h2 id="lr1语法分析器"><a class="anchor" href="#lr1语法分析器">#</a> LR (1) 语法分析器</h2>
<h3 id="slr1语法分析器"><a class="anchor" href="#slr1语法分析器">#</a> SLR (1) 语法分析器</h3>
<p>S 的含义：simple</p>
<p>把 L (0) 语法分析表构建的第三条规则修改后，就可以得到 SLR (1) 分析表</p>
<p +，),$>可算出 FOLLOW (E)=</p>
<p><img data-src="image-20230531141739236.png" alt="image-20230531141739236"><br>
<img data-src="image-20230531142412456.png" alt="image-20230531142412456"></p>
<p><img data-src="image-20230531143303240.png" alt="image-20230531143303240"></p>
<p><img data-src="image-20230531144019374.png" alt="image-20230531144019374"></p>
<p>为什么优于 SLR (1)， 因为 FIRST (gamma) 包含于 FOLLOW (A)</p>
<p><img data-src="image-20230531150929602.png" alt="image-20230531150929602"></p>
<p>为什么 β 后面跟着 a，因为 β 可能是空串</p>
<p><img data-src="image-20230531152400747.png" alt="image-20230531152400747"></p>
<p><img data-src="image-20230531153030143.png" alt="image-20230531153030143"></p>
<p>LR(0) &lt; LALR(1) &lt; LR(1)</p>
<p>问题：合并后会不会影响到关联的其它状态？</p>
<p>不会，LR (0) 项相同，出边和对应的到达状态也是可以合并的</p>
<p>但是合并还是可能引起冲突的</p>
<p><img data-src="image-20230531154243826.png" alt="image-20230531154243826"></p>
<p><img data-src="image-20230531154844166.png" alt="image-20230531154844166"></p>
<h2 id="lr算法的特点"><a class="anchor" href="#lr算法的特点">#</a> LR 算法的特点</h2>
<p><img data-src="image-20230602141654975.png" alt="image-20230602141654975"></p>
<p>为什么？ 因为一个 L 语言可以用 G1 文法和 G2 文法表示，这时 G1 可能刚好满足 SLR（1），G2 刚好满足 LR（1）</p>
<p>要区分 <strong>文法</strong> 和 <strong>语言</strong></p>
<p>也就是一个语言能写出 LR (1) 的文法，就一定能写出 SLR (1) 的文法</p>
<p><img data-src="image-20230602142434949.png" alt="image-20230602142434949"></p>
<p><img data-src="image-20230602142715980.png" alt="image-20230602142715980"></p>
<p>{+,*} 属于 FOLLOW (E)</p>
<p>譬如这里的 I7 状态： + 号即属于 Follow (E) 也是当前看到的下一个符号，因此看到＋号既可以规约也可以移入，产生冲突。</p>
<p>这里根据实际地考量（优先级与结合性），即如果碰到 E+E+E 应该先算出左边两个 E 相加的结果，因此 E+E . 碰到＋号应该选择规约</p>
<h2 id="lab2"><a class="anchor" href="#lab2">#</a> lab2</h2>
<h3 id="实验内容"><a class="anchor" href="#实验内容">#</a> 实验内容</h3>
<ul>
<li>本次实验需要完成语法分析与高亮，要求如下
<ul>
<li>根据实验指导内提供的文档完成 SysyParser.g4 并将 SysYParser.g4 中按下面已经给出的写法将 exp 和 cond 写成左递归</li>
<li>当<strong>输入文件存在语法错误时</strong>：输出语法错误在哪一行，格式为 <code>Error type B at Line [lineNo]:[errorMessage]</code>  其中 lineNo 为出错的 token 首个字符所在行的行号，errorMessage 可自行定义，本实验不做要求，只要冒号前的信息正确即可，需要输出所有的错误</li>
<li>当<strong>输入文件不存在语法错误时</strong>：按照规定格式输出语法树 (含高亮)，输出格式详见<strong>样例一</strong></li>
<li>使用 ** 标准错误输出（System.err）** 打印所有运行结果</li>
</ul>
</li>
</ul>
<h3 id="实验过程"><a class="anchor" href="#实验过程">#</a> 实验过程</h3>
<p>仍然需要重写 BaseErrorListener 实现一个自己的 myErrorListener。与实验一不同的是，除法 ErrorListener 的方式不同，本次实验要在语法分析的过程中进行错误检查。改写的 main 函数如下：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>			<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"input path is required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		<span class="token class-name">String</span> source <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>		<span class="token class-name">CharStream</span> input <span class="token operator">=</span> <span class="token class-name">CharStreams</span><span class="token punctuation">.</span><span class="token function">fromFileName</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//		SysYLexer sysYLexer = new SysYLexer(input);</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//		sysYLexer.removeErrorListeners();</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">//		sysYLexer.addErrorListener(new myErrorListener());</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">//		List&lt;Token> tokens = (List&lt;Token>) sysYLexer.getAllTokens();</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token class-name">SysYLexer</span> sysYLexer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SysYLexer</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token class-name">CommonTokenStream</span> tokens <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommonTokenStream</span><span class="token punctuation">(</span>sysYLexer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token class-name">SysYParser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SysYParser</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		parser<span class="token punctuation">.</span><span class="token function">removeErrorListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		parser<span class="token punctuation">.</span><span class="token function">addErrorListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">myErrorListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token class-name">ParseTree</span> tree <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">program</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>			<span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		<span class="token class-name">Visitor</span> visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Visitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>		visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">//		String[] rulenames = sysYLexer.getRuleNames();</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">//		for (Token token : tokens) &#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">//			String tokenType = rulenames[token.getType()-1];</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">//			String tokenText = toDemical(token.getText());</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">//			String tokenLine = ""+token.getLine();</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">//			System.err.println(tokenType + " " + tokenText + " at Line "+tokenLine+'.');</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">//		&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中注释掉的部分是实验一的代码。这次要将 errorlistener 加到语法分析器 parser 上 并且利用 parser.program () 触发错误检查并生成语法树。注意，之所以用 program () 方法当做入口方法是因为 SysYParser.g4 的定义中 program 是最高的语言层次。</p>
<p>本次实验最重要的内容就是重写了一个继承自 SysYParserBaseVisitor 的类 Vistor 代码如下：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token keyword">extends</span> <span class="token class-name">SysYParserBaseVisitor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>		<span class="token keyword">public</span> <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>		<span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		<span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">visitChildren</span><span class="token punctuation">(</span><span class="token class-name">RuleNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>			<span class="token class-name">Void</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">defaultResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>			<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>			sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>			<span class="token keyword">int</span> num <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getRuleContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRuleIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>			<span class="token class-name">String</span> ruleName <span class="token operator">=</span> <span class="token class-name">SysYParser</span><span class="token punctuation">.</span>ruleNames<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>			ruleName <span class="token operator">=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span>ruleName<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> ruleName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>			sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ruleName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>			<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>			<span class="token keyword">int</span> n <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getChildCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">shouldVisitNextChild</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>				depth <span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>				<span class="token class-name">ParseTree</span> c <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getChild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>				<span class="token class-name">Void</span> childResult <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>				result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">aggregateResult</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> childResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>				depth <span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>			<span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>		<span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="26"></td><td><pre>		<span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">visitTerminal</span><span class="token punctuation">(</span><span class="token class-name">TerminalNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>			<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>			sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>			<span class="token keyword">int</span> num <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getSymbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ruleNames<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>				sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token function">toDemical</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>				sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ruleNames<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>				<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre>		<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ruleNames <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>				<span class="token string">"CONST[orange]"</span><span class="token punctuation">,</span> <span class="token string">"INT[orange]"</span><span class="token punctuation">,</span> <span class="token string">"VOID[orange]"</span><span class="token punctuation">,</span> <span class="token string">"IF[orange]"</span><span class="token punctuation">,</span> <span class="token string">"ELSE[orange]"</span><span class="token punctuation">,</span> <span class="token string">"WHILE[orange]"</span><span class="token punctuation">,</span> <span class="token string">"BREAK[orange]"</span><span class="token punctuation">,</span> <span class="token string">"CONTINUE[orange]"</span><span class="token punctuation">,</span> <span class="token string">"RETURN[orange]"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="40"></td><td><pre>				<span class="token string">"PLUS[blue]"</span><span class="token punctuation">,</span> <span class="token string">"MINUS[blue]"</span><span class="token punctuation">,</span> <span class="token string">"MUL[blue]"</span><span class="token punctuation">,</span> <span class="token string">"DIV[blue]"</span><span class="token punctuation">,</span> <span class="token string">"MOD[blue]"</span><span class="token punctuation">,</span> <span class="token string">"ASSIGN[blue]"</span><span class="token punctuation">,</span> <span class="token string">"EQ[blue]"</span><span class="token punctuation">,</span> <span class="token string">"NEQ[blue]"</span><span class="token punctuation">,</span> <span class="token string">"LT[blue]"</span><span class="token punctuation">,</span> <span class="token string">"GT[blue]"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="41"></td><td><pre>				<span class="token string">"LE[blue]"</span><span class="token punctuation">,</span> <span class="token string">"GE[blue]"</span><span class="token punctuation">,</span> <span class="token string">"NOT[blue]"</span><span class="token punctuation">,</span> <span class="token string">"AND[blue]"</span><span class="token punctuation">,</span> <span class="token string">"OR[blue]"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="42"></td><td><pre>				<span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"IDENT[red]"</span><span class="token punctuation">,</span> <span class="token string">"INTEGER_CONST[green]"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="43"></td><td><pre>				<span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="44"></td><td><pre>				<span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span></pre></td></tr><tr><td data-num="45"></td><td><pre>		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>visitChildren 是当 dfs 遍历每个语法节点时都会触发的方法，一开始没有想到在遍历某个节点时如何得到该节点的深度，后面通过维护一个全局变量 depth 来实现。当进入节点前 depth 会 + 1 退出时会 - 1。</p>
<p><img data-src="image-20230328210917158.png" alt="image-20230328210917158"></p>
<p>这里简单的把 accept 方法理解为会调用 visitor.visitChildren (currentnode) 的函数就好了。</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理04-中间代码生成</title>
    <url>/2023/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8604-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="编译原理04-中间代码生成"><a class="anchor" href="#编译原理04-中间代码生成">#</a> 编译原理 04 - 中间代码生成</h1>
<h2 id="llvm-ir简介"><a class="anchor" href="#llvm-ir简介">#</a> LLVM IR 简介</h2>
<p><img data-src="image-20230505140807839.png" alt="image-20230505140807839"></p>
<p>LLVM 这个项目与最初的名字含义已经完全不同了，可以将 LLVM 理解为全称。目前 LLVM 是开发新的编译器的<strong>基础</strong>。</p>
<p><img data-src="image-20230505141735207.png" alt="image-20230505141735207"></p>
<p>前端经过语法分析，词法分析，生成 IR</p>
<p><strong>“IR 设计的优秀与否决定着整个编译器的好坏”</strong></p>
<p><img data-src="image-20230505141928962.png" alt="image-20230505141928962"></p>
<p>一个.c 文件对应生成一个.ll 文件。Module 实际上就是一个文件 file, Module 里有多个函数，一个函数具有多个<strong>基本块 (Basic Block)</strong>, 每一个基本块都由多个指令构成。</p>
<p>使用 clang <strong>-S -emit-llvm</strong> factorial0.c -o f0-opt0.ll 表示用 clang 生成到 llvm 中间代码阶段停止。</p>
<p>中间代码示例：<br>
<img data-src="image-20230505143323681.png" alt="image-20230505143323681"></p>
<p>像 %3 %4 这样的是分配一个虚拟寄存器， alloca 表示内存分配， align 表示内存对齐</p>
<p><code>store i32 0, i32* %3</code>  表示把 0 存到 %3 寄存器中</p>
<p>call 一行表示函数调用</p>
<p>下一行表示结果与 7 相乘， nsw 表示 no signed wrap</p>
<p>zext: zero - extension 将一 bit 的 %8 扩展为 32 位</p>
<p>%2 哪去了？ 被分配为 entry 基本块的名称</p>
<p>限制：任何一个变量都只能一次赋值， 好处是使用变量时明确知道在什么时候定义过的。</p>
<h2 id="控制流图"><a class="anchor" href="#控制流图">#</a> 控制流图</h2>
<p><img data-src="image-20230505150416543.png" alt="image-20230505150416543"></p>
<p>控制流图的定义：<br>
<img data-src="image-20230505150719324.png" alt="image-20230505150719324"></p>
<p>例子：<br>
<img data-src="image-20230505151157414.png" alt="image-20230505151157414"></p>
<p>中间代码的数据流图：</p>
<p><img data-src="image-20230505151318630.png" alt="image-20230505151318630"></p>
<p>问题：%6 和 %7 基本块中要约定好把想 ret 的结果放在某一个寄存器中</p>
<p>开了 o1 优化后：</p>
<p><img data-src="image-20230505152003795.png" alt="image-20230505152003795"></p>
<p>o1 优化会去掉所有的内存分配，store load 指令。</p>
<p>phi 指令 根据从哪个块跳转出来决定赋值给 %8 寄存器的值</p>
<p>然而 phi 指令只是为了简化中间代码的大小产生的，是一个虚拟指令，实际上仍然可能会使用基本方案。</p>
<h2 id="llvm-java-api"><a class="anchor" href="#llvm-java-api">#</a> LLVM JAVA API</h2>
<p><img data-src="image-20230506141752865.png" alt="image-20230506141752865"></p>
<p>在配置文件中加依赖</p>
<p><img data-src="image-20230506142227366.png" alt="image-20230506142227366"></p>
<p>可以参照 LLVM 官方的教程，c++ 语言如何翻译为中间代码。</p>
<h2 id="中间代码翻译"><a class="anchor" href="#中间代码翻译">#</a> 中间代码翻译</h2>
<p><img data-src="image-20230506143047512.png" alt="image-20230506143047512"></p>
<p>这里的 || 符号是 then 的意思，不是或者。</p>
<p><img data-src="image-20230506144459580.png" alt="image-20230506144459580"></p>
<p><img data-src="image-20230506144737646.png" alt="image-20230506144737646"></p>
<p><img data-src="image-20230506145121379.png" alt="image-20230506145121379"></p>
<p>例子： int a [2] [3]; c + a [i] [j];</p>
<p><img data-src="image-20230506150834033.png" alt="image-20230506150834033"></p>
<p>在 llvm IR 中：会用 getelementptr（GEP）指令处理数组引用</p>
<p><img data-src="image-20230506151202417.png" alt="image-20230506151202417"></p>
<p>GEP 指令有四个参数，其中第四个参数不限个数，可以有多个 index。</p>
<p>第一个 index 比较特殊，表示 base-type 的一个元素的大小，用于 a++ 这样的操作，后面的 index 才用于进入数组获取元素，即没多一个 index 脱掉一层中括号。</p>
<p><img data-src="image-20230506151901102.png" alt="image-20230506151901102"></p>
<p>GEP provides a way to access arrays and manipulate pointers.</p>
<p>GEP abstract away details like size of types.</p>
<p>有了 GEP 指令后就不用像上面那样递归的计算偏移量了。</p>
<p><img data-src="image-20230506154154393.png" alt="image-20230506154154393"></p>
<h3 id="控制流语句的翻译"><a class="anchor" href="#控制流语句的翻译">#</a> 控制流语句的翻译</h3>
<p>简单的思路会带来冗余的代码</p>
<p>要生成简短高效的代码，就需要<strong>创造困难</strong></p>
<p><strong>简单 mode：</strong></p>
<p><img data-src="image-20230510141125754.png" alt="image-20230510141125754"></p>
<p>将 B 的值保存到临时变量 t1 中，翻译 if 语句时用 br 语句测试 t1 的值并根据情况跳转到两个基本块中。</p>
<p>以 Control 语言为例：</p>
<p><img data-src="image-20230510142838861.png" alt="image-20230510142838861"></p>
<p>选择实现方式的范围： Listeners, Visitors, Attributed Grammar</p>
<p>前两种方法能做到的 属性方法都能做到，但是属性文法本身比较困难，所以在前两种中方法中选择。</p>
<p>Listener 模式有一个问题： 比如 B -&gt; B1 || B2 的翻译：</p>
<p>要在 exitB () 方法拼接 B1.code 和 B2.code 。但是考虑出现了短路求值的问题时，由于在 exitB 的时候 B1 和 B2 的代码都生成好了，因此要在拼接 B1.code 和 B2.code 中间插入判断短路求值的代码，不能及时输出生成的中间代码，不能避免频繁的字符串拼接操作。简要来说，访问完 B1，将中间代码保存下来，才能进行接下来的操作，不能在访问 B1 和访问 B2 中间插入一些操作，这是 Listener 模式的缺陷。</p>
<p>具体代码见代码仓库<em> 2023-compilers-coding-0/src/main/java/codegen/CodeGenVisitor.java</em></p>
<p>true 和 false 的翻译：</p>
<p><img data-src="image-20230510144428568.png" alt="image-20230510144428568"></p>
<p>AND 语句：</p>
<p>有一个小错误 String temp = getNewTemp () 要放在 emitLabel (trueLabel) 之上。</p>
<p><img data-src="image-20230510151933288.png" alt="image-20230510151933288"></p>
<p>if 语句：</p>
<p><img data-src="image-20230510151955477.png" alt="image-20230510151955477"></p>
<p>while 语句：</p>
<p><img data-src="image-20230510152502018.png" alt="image-20230510152502018"></p>
<p>一个问题：break 语句怎么翻译，多层嵌套的循环语句怎么办</p>
<p>解决方法：使用一个栈，保存 break 语句要跳转到的地方。，参照 while 语句中的压栈出栈语句。</p>
<p>短路求值问题： 参照 And 中的实现</p>
<p><strong>复杂 mode</strong>：</p>
<p><img data-src="image-20230510154721641.png" alt="image-20230510154721641"></p>
<p>为什么让事情变得更复杂：</p>
<p>eg：</p>
<p><img data-src="image-20230517140632912.png" alt="image-20230517140632912"></p>
<p>如果使用简单方案，将会生成 12 行中间代码，然而实际上这是一个死循环</p>
<p>解决方案：利用继承属性让布尔表达式知道要跳转到哪</p>
<p><img data-src="image-20230517141735294.png" alt="image-20230517141735294"></p>
<h3 id="需要的继承属性"><a class="anchor" href="#需要的继承属性">#</a> 需要的继承属性</h3>
<p><img data-src="image-20230517142425226.png" alt="image-20230517142425226"></p>
<h3 id="if语句"><a class="anchor" href="#if语句">#</a> if 语句</h3>
<p><img data-src="image-20230517142712190.png" alt="image-20230517142712190"></p>
<p>S.next 是之前准备好的</p>
<p><img data-src="image-20230517143447956.png" alt="image-20230517143447956"></p>
<p>bool 表达式直接翻译成 goto 语句</p>
<h3 id="if-else-语句"><a class="anchor" href="#if-else-语句">#</a> if else 语句</h3>
<p><img data-src="image-20230517144609460.png" alt="image-20230517144609460"></p>
<p>eg：<img data-src="image-20230517144946527.png" alt="image-20230517144946527"></p>
<h3 id="while语句"><a class="anchor" href="#while语句">#</a> while 语句</h3>
<p><img data-src="image-20230517150821390.png" alt="image-20230517150821390"></p>
<h3 id="顺序语句"><a class="anchor" href="#顺序语句">#</a> 顺序语句：</h3>
<p><img data-src="image-20230517152329272.png" alt="image-20230517152329272"></p>
<h3 id="短路求值"><a class="anchor" href="#短路求值">#</a> 短路求值</h3>
<p><img data-src="image-20230517153441075.png" alt="image-20230517153441075"></p>
<p><img data-src="image-20230517153732513.png" alt="image-20230517153732513"></p>
<h2 id="地址回填技术"><a class="anchor" href="#地址回填技术">#</a> 地址回填技术</h2>
<p><img data-src="image-20230519140559966.png" alt="image-20230519140559966"></p>
<p>java 字节码中不使用符号化的标签作为跳转目标，而采用直接的地址值作为跳转目标。</p>
<p>问题：往回跳简单，往前跳不知道跳转的地址，如何一趟扫描中就知道跳转目标的真实地址？</p>
<p><img data-src="image-20230519141028791.png" alt="image-20230519141028791"></p>
<p><img data-src="image-20230519141358466.png" alt="image-20230519141358466"></p>
<p>解决方案： B 在 goto 语句后面空着，交给父节点 S 来回填。</p>
<p><img data-src="image-20230519141905148.png" alt="image-20230519141905148"></p>
<p>从底向上看怎么使用地址回填技术：(每幅图的下半部分是之前的翻译方案)</p>
<p><img data-src="image-20230519143110842.png" alt="image-20230519143110842"></p>
<p><img data-src="image-20230519143543907.png" alt="image-20230519143543907"></p>
<p><img data-src="image-20230519143840206.png" alt="image-20230519143840206"></p>
<p>到这里已经可以确定一些跳转的地址了：</p>
<p>M 是一个辅助的符号，用来确定 B2 第一个指令的地址的值是多少</p>
<p><img data-src="image-20230519144434026.png" alt="image-20230519144434026"></p>
<p><img data-src="image-20230519150121225.png" alt="image-20230519150121225"></p>
<p>布尔表达式结束 到达更高层：</p>
<p><img data-src="/image-20230519151840965.png" alt="image-20230519151840965"></p>
<p><img data-src="image-20230519152628678.png" alt="image-20230519152628678"></p>
<p><img data-src="image-20230519153118656.png" alt="image-20230519153118656"></p>
<p>顺序语句：</p>
<p><img data-src="image-20230519153706714.png" alt="image-20230519153706714"></p>
<p>总结：</p>
<p><img data-src="image-20230519154323985.png" alt="image-20230519154323985"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理05-目标代码生成</title>
    <url>/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8605-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="编译原理05-目标代码生成"><a class="anchor" href="#编译原理05-目标代码生成">#</a> 编译原理 05 - 目标代码生成</h1>
<h2 id="risc-v指令集"><a class="anchor" href="#risc-v指令集">#</a> RISC-V 指令集</h2>
<p><img data-src="image-20230602144012905.png" alt="image-20230602144012905"></p>
<p>精简指令集，精简的含义就是一条指令要么做运算，要么存，取内存。</p>
<h3 id="寄存器"><a class="anchor" href="#寄存器">#</a> 寄存器</h3>
<p>RISC-V 有 32 个寄存器，名称分别为 X0,X1...X31</p>
<p>但实际上不会按这些名称来使用，而是按照约定来使用，一些寄存器有专门的用途</p>
<p><img data-src="image-20230602150421869.png" alt="image-20230602150421869"></p>
<p>X0： zero 寄存器，专门存放数字 0</p>
<p>ra： 存放 return address</p>
<p>pc(X31): program counter</p>
<h3 id="指令"><a class="anchor" href="#指令">#</a> 指令</h3>
<p>li ： 加载立即数	li t0,0</p>
<p>add: 加法，有三个操作数： add t5,t3,t4 , t5 = t3+t4</p>
<p>addi： 加法，但有一个操作数是立即数</p>
<p>risc-v 里没有 mov 指令，或者说 mov 指令是一个伪指令，实际上是用 add， target, source, zero 来实现的</p>
<p>在.data 段声明全局变量：</p>
<p>.data:</p>
<p>g:  .word 0	想.word 这样的是给汇编器看的，表示占用 4B</p>
<p>数组：</p>
<p>g: .word 0,1,2</p>
<p>字符串：</p>
<p>msg: .string &quot;The result is :&quot; #后面会自动加上 '\0' 不想加就用.ascii</p>
<p>使用全局变量：</p>
<p>la t0, g  	#la; load address</p>
<p>lw t0, 0 (t0)	#lw: load word 这里 0 表示偏移量 并且以字节为单位</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
