{
    "version": "https://jsonfeed.org/version/1",
    "title": "MikeMao's blog • All posts by \"c++\" category",
    "description": "a student of NJU who use this website to record learning experience",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "title": "Effective C++读书笔记",
            "date_published": "2024-07-28T09:38:31.000Z",
            "content_html": "<p>C++ 是我最喜欢的一门语言，C++ programer 一直为其拥有的非同寻常的能力范围和表现力而自豪（当然如果能正确使用的话）。正如 Scott Meyers, 本书作者所言：学习一种编程语言的基础是一回事；学习如何用那种语言设计和实现高效率的程序完全是另外一回事。断断续续学习了两年的 C++ programing language, 我的追求从学会语言基础，逐渐变为追求更加高效，并同时具备高可扩展性和可维护性的编程。</p>\n<p>Effetive C++ 是一本主要面向 C++  03 标准及之前的 C++ 编程过程中的一些编程 guidelines 的，自 C++  11 以来，C++ 不断推陈出新，关于一些场景作者提出的解决方案也许有了更好的替代方案。但作为一切的基础，以及一系列书目的开山之作（more Efective C++, Effective Modern C++)，此书仍然被许多人认为是 CPP programer 进阶的必看书目。此读书笔记仅供我自己查阅，提供简单的总结与感想，以从作者引人入胜但对于已经认真体会的读者而言无益的行文中走出 (TLDR)。并对书中的一些问题尝试使用 C++ 11 后的新特性解决。</p>\n<p>我不想成为一个语言学家，阅读之后还需要更多的编程练习来巩固所学习的知识。</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"杂项\"><a class=\"anchor\" href=\"#杂项\">#</a> 杂项</h2>\n<h3 id=\"item1-将c视为-federation-of-languages语言联合体\"><a class=\"anchor\" href=\"#item1-将c视为-federation-of-languages语言联合体\">#</a> item1 将 C++ 视为 federation of languages (语言联合体)</h3>\n<p>将 C++ 从一门编程语言看作四门互相联系但有各自主体思想的子语言的结合体：</p>\n<ul>\n<li>C: 包括 built-in 数据结构，流程控制语句等，提供语法基础。</li>\n<li>Object-Oriented C++：C++ 的面向对象部分，主要设计封装继承多态这三个方面</li>\n<li>Template C++：泛型编程部分，对多数程序员少用但及其强大的 C++ 语言部分，提供包括 TMP (模板元编程) 这样的黑魔法。</li>\n<li>STL：containers,iterators,algorithms,functions objects... 方便地使用大佬们提供的编程工具，优化编程体验，不用像 C 那样 array simulate everything 了。</li>\n</ul>\n<p>每一种子语言都有一套自己常用的编程理念，在不同的子语言下编程时，可能会要从不同的规则中进行转换（比如传值的方式）。</p>\n<h3 id=\"item2-用consts-enums和inlines-取代defines\"><a class=\"anchor\" href=\"#item2-用consts-enums和inlines-取代defines\">#</a> item2 用 consts, enums, 和 inlines 取代 #defines</h3>\n<p><strong>#defines 无法提供包括作用域控制，类型检查等功能，因此能避免就避免。一般只在控制编译逻辑的时候配合 #ifdef/#ifndef 使用，比如根据某些宏修改一些 objects 的定义，而不要用在编程的逻辑中。</strong></p>\n<ul>\n<li>想使用 #defines 定义常量时 比如 <code>#define PI 3.1415926</code> ，使用 const 替代，以获取更好的编译器报错体验与类型检查</li>\n<li>想使用 #defines 定义<strong>类属常量</strong>时，比如<strong>在类中</strong>定义 <code>static const int a = 5;</code>  这里涉及到了类属常量的初始化问题，简要来说，一些编译器禁止 static integral class constants（静态整型族类属常量）的 in-class specification 而不得不在类外使用 <code>const int MyClass::a = 5;</code>  这样的初始化方式。（ps： 都是很老的编译器了，在作者那个年代都算过时的了，gcc4.0.4 都可以在类中定义整型族常量）。对于静态非整型族类属常量，比如 <code>static const string s = &quot;hello&quot;</code> ，或者 <code>static const string s = nullptr</code>  这样的语句是不允许出现在类的定义中的。你必须要在类外初始化。for example:</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> cst <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// allowed</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> string s<span class=\"token punctuation\">;</span> <span class=\"token comment\">// static const string s = \"hello\"? not allowed</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p <span class=\"token punctuation\">;</span> <span class=\"token comment\">// static const int* p = nullter? not allowed</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> string MyClass<span class=\"token double-colon punctuation\">::</span>s <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> MyClass<span class=\"token double-colon punctuation\">::</span>p <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>这个过程体现了 C++ 令人难以忍受的缺陷，对于很多东西，它具有很多的特例，并且你很难理解为什么，没有什么规则是通用的</strong>。一个好消息是，C++ 17 后做出了补救 (又有新东西要记了)：</p>\n<p>according to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU2Mzg5Ny9ob3ctY2FuLXlvdS1kZWZpbmUtYS1zdGF0aWMtZGF0YS1tZW1iZXItb2YtdHlwZS1jb25zdC1zdGRzdHJpbmc=\">c++ - How can you define a static data member of type const std::string? - Stack Overflow</span></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">constexpr</span> <span class=\"token keyword\">int</span> cst <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">constexpr</span> std<span class=\"token double-colon punctuation\">::</span>string_view STRING <span class=\"token operator\">=</span> <span class=\"token string\">\"some useful string constant\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">constexpr</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ul>\n<li>想使用 #defines 定义函数时，使用 inline 的模版函数替代，以获取函数参数具有的参数类型检查功能，并且拥有不输于 defines 的性能。还有，在使用 defines 定义函数时，你不得不给参数加括号 😃</li>\n</ul>\n<p>对了 忘了提 enums 了，这里作者使用了一个叫做 the enum hack 的技术，主要来源于一个 enumerated type（枚举类型）的值可以用在一个需要 ints 的地方。for example:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">GamePlayer</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">&#123;</span> NumTurns <span class=\"token operator\">=</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// \"the enum hack\" - makes</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                                     <span class=\"token comment\">// NumTurns a symbolic name for 5</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">int</span> scores<span class=\"token punctuation\">[</span>NumTurns<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// fine</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用这项技术，你可以禁止对 NumTurns 的取地址行为，第二个理由是，大量的代码在使用它（作为模版元编程的基本技术之一），所以最好还是认识一下。</p>\n<p><strong>by the way, 当你声明一个常量指针的时候，最好别忘了把这个指针也设为 const。</strong></p>\n<h3 id=\"item3-只要可能就用const\"><a class=\"anchor\" href=\"#item3-只要可能就用const\">#</a> item3 只要可能就用 const</h3>\n<p>use <em>const</em> as long as possible, 经常看到的一句话了，这节内容主要分为三点：</p>\n<ol>\n<li>const 关键字提供了语义上的表达，有助于编译器发现错误。const 用途广泛，可用于对象，函数参数，返回类型，成员函数等。（这点为大部分程序员对此节标题的唯一理解）</li>\n<li>编译器坚持的是<strong> bitwise constness</strong> (二进制位常量性), 但程序员应当使用<strong> conceptual constness</strong> (概念上的常量性) 来编程。</li>\n<li>当 const 和 non-const 成员函数本质上具有相同的实现的时候，使用 non-const 版本调用 const 版本可以避免代码重复。</li>\n</ol>\n<p>关于第二点的理解：</p>\n<p>二进制位常量性是指当你声明一个变量为 const 的时候，编译器只需要检查它在内存中存储的二进制位有没有被更改就行了，因为这样实现十分方便，比如当你声明一个指针为 const 时候，你不能改变指针的值，但是你可以改变指针指向的对象的值。但是当你声明一个类为 const 的时候，只能调用 const 成员函数，并且不能改变其任何成员变量，这实在是太苛刻了。</p>\n<p>for example: 一个可以存储文本块长度的类：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">CTextBlock</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>size_t <span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pText<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>size_t textLength<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// last calculated length of textblock</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token keyword\">bool</span> lengthIsValid<span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// whether length is currently valid</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>size_t <span class=\"token class-name\">CTextBlock</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>lengthIsValid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    textLength <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>pText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// error! can't assign to textLength</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    lengthIsValid <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// and lengthIsValid in a const</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                   <span class=\"token comment\">// member function</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token keyword\">return</span> textLength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>对于 length () 成员函数，由于语义的需要必须定义为 const。但不想每次都调用 strlen 计算文本长度，这会带来许多开销，于是便用上述方法存储字符串长度。但是这违反了二进制常量性，毕竟改变了成员变量。</p>\n<p>因此引入了逻辑常量性的概念，这一理念认为，** 一个 const 成员函数可以改变对象中的一些 bits, 但是只能用客户无法察觉的方法。** 这种理念的实现是通过 mutable 关键字实现的，比如将上面的 textLength 和 lengthIsValid 变量用 mutable 修饰即可。</p>\n<p>对于第三点的理解：</p>\n<p>一般来说，类中重载的 const 成员函数和非 const 成员函数的逻辑都是差不多的，这带来了额外的编译时间，维护成本以及代码膨胀，这对于一些程序员来说是不可忍受的。因此可以使用这样一个 trick: 通过强制转型，让 non-const 成员函数调用 const 版本。for example:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">TextBlock</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t position<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>     <span class=\"token comment\">// same as before</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">[</span>position<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t position<span class=\"token punctuation\">)</span>         <span class=\"token comment\">// now just calls const op[]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token generic-function\"><span class=\"token function\">const_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">&amp;</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>                         <span class=\"token comment\">// cast away const on</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                                                 <span class=\"token comment\">// op[]'s return type;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">const</span> TextBlock<span class=\"token operator\">&amp;</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>     <span class=\"token comment\">// add const to *this's type;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>          <span class=\"token punctuation\">[</span>position<span class=\"token punctuation\">]</span>                             <span class=\"token comment\">// call const version of op[]</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这样的代码通过不了选美比赛 😄 ，但是它有效。</p>\n<p><strong>注意，反过来让 const 版本调用 non-const 版本不可取，因为违反了 const 的语义，你将承受改变成员变量的风险。</strong></p>\n<h3 id=\"item-4-确保对象在使用前被初始化\"><a class=\"anchor\" href=\"#item-4-确保对象在使用前被初始化\">#</a> item 4 确保对象在使用前被初始化</h3>\n<p>对于 C++ 的对象，当你不初始化它们时，有些时候它们会自动初始化，有时候不会，因此为了避免 ub，再声明的同时最好也初始化它们。</p>\n<p>要点：</p>\n<ul>\n<li>\n<p>手动初始化 built-in type 的 objects，因为 C++ 只在某些时候才会自己初始化它们</p>\n</li>\n<li>\n<p>在 constructor 中，用 member initialization list 代替函数体中的 assignment。initialization list 中 data members 的排列顺序要与它们在 class（类）中被声明的顺序相同。因为在构造函数赋值之前，成员变量已经被默认初始化好了，这样做能提升性能。除此之外的是，有些时候，初始化列表式可选项，有时候是必选项，因此为了方便记忆，一律使用初始化列表即可。</p>\n</li>\n<li>\n<p>通过用 local static objects（局部静态对象）代替 non-local static objects（非局部静态对象）来避免跨 translation units（编译单元）的 初始化顺序问题。</p>\n</li>\n</ul>\n<p>即将在全局中定义一个 <code>static FileSystem fs; </code>  替换为提供一个函数，有点像单例模式：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FileSystem<span class=\"token operator\">&amp;</span> <span class=\"token function\">tfs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\">// this replaces the tfs object; it could be</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>                                   <span class=\"token comment\">// static in the FileSystem class</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">static</span> FileSystem fs<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// define and initialize a local static object</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">return</span> fs<span class=\"token punctuation\">;</span>                        <span class=\"token comment\">// return a reference to it</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"构造-析构与赋值\"><a class=\"anchor\" href=\"#构造-析构与赋值\">#</a> 构造、析构与赋值</h2>\n<h3 id=\"item5-了解c为你默认编写并调用了哪些函数\"><a class=\"anchor\" href=\"#item5-了解c为你默认编写并调用了哪些函数\">#</a> item5 了解 C++ 为你默认编写并调用了哪些函数</h3>\n<ul>\n<li>编译器可以隐式生成一个 class（类）的 default constructor（缺省构造函数），copy constructor（拷贝构造函数），copy assignment operator（拷贝赋值运算符）和 destructor（析构函数）。C++11 后还增加了移动构造和移动赋值。</li>\n</ul>\n<p><strong>对于以下场景：深拷贝，类中有 const 或引用成员变量，以及析构函数有 virtual 需求的时候，默认生成的函数可能不会符合要求</strong>。</p>\n<h3 id=\"item6-若不想使用编译器生成函数就明确拒绝\"><a class=\"anchor\" href=\"#item6-若不想使用编译器生成函数就明确拒绝\">#</a> item6 若不想使用编译器生成函数，就明确拒绝</h3>\n<p>在 C++ 11 之前，作者是通过将相应的成员函数声明为 private 实现的，或者继承自一个使用这种方法实现的 Uncopyable 的基类。</p>\n<p>C++ 11 之后，使用 <code>= delete</code>  即可</p>\n<h3 id=\"item7-为多态基类声明虚析构函数\"><a class=\"anchor\" href=\"#item7-为多态基类声明虚析构函数\">#</a> item7 为多态基类声明虚析构函数</h3>\n<p>为了防止内存泄露，必须将多态基类的析构函数声明为虚函数</p>\n<p>除此之外还要注意两点：</p>\n<ul>\n<li>普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价</li>\n<li>如果一个类型没有被设计成多态基类，又有被误继承的风险，可以使用 C++ 11 中的 <code>final</code>  关键字，这样禁止派生可以防止误继承造成上述问题。</li>\n</ul>\n<h3 id=\"item8-防止异常逃离析构函数\"><a class=\"anchor\" href=\"#item8-防止异常逃离析构函数\">#</a> item8 防止异常逃离析构函数</h3>\n<p>两个要点：</p>\n<ul>\n<li>destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后<strong>抑制它们或者终止程序</strong>。这里的抑制指的是在 try catch 语句中捕获并处理。</li>\n<li>如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。</li>\n</ul>\n<p>对于第二点，一个常见例子是使用各种 db 的连接池的场景，通常用户需要使用 db.close () 显式释放资源，对于拥有 RAII 机制的 C++ 来说，为什么还需要这样做呢。因为通过 db.close () 这样的普通成员函数，用户可以通过 try catch 语句自行对这个异常做出回应。在析构函数中，同样可以继续使用 RAII 机制，记录用户有无手动释放，没有则自行调用 db.close ()</p>\n<h3 id=\"item9-避免在构造函数或者析构函数中调用虚函数\"><a class=\"anchor\" href=\"#item9-避免在构造函数或者析构函数中调用虚函数\">#</a> item9 避免在构造函数或者析构函数中调用虚函数</h3>\n<p>简单来说，在构造和析构的时候，对象的类型是不确定的，因此想要调用的虚函数可能不会如你所愿。</p>\n<p>这点看似简单，却十分容易踩坑，考虑以下场景，为了避免重复代码，我们可能将不同的变量初始化放到一个 init () 函数之中，即使这个函数不是虚函数，但如果其中调用了虚函数，还是违背了这一原则，并且以难以察觉的方式。</p>\n<h3 id=\"item10-在赋值运算符中返回一个reference-to-this\"><a class=\"anchor\" href=\"#item10-在赋值运算符中返回一个reference-to-this\">#</a> item10 在赋值运算符中返回一个 reference to *this</h3>\n<p>简单来说 这样做是为了支持链式赋值并让自己的接口和内置类型的接口尽可能相似。因此，请将赋值操作符的返回类型设为 ObjectClass&amp; 并返回 * this。</p>\n",
            "tags": [
                "C++ 读书笔记"
            ]
        },
        {
            "id": "http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/",
            "url": "http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/",
            "title": "C++：移动语义与右值引用",
            "date_published": "2022-11-14T08:08:33.000Z",
            "content_html": "<h1 id=\"c的移动语义与右值引用\"><a class=\"anchor\" href=\"#c的移动语义与右值引用\">#</a> C++ 的移动语义与右值引用</h1>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"preview.jpg\" alt=\"Gaze\"></p>\n<h2 id=\"移动语义\"><a class=\"anchor\" href=\"#移动语义\">#</a> 移动语义</h2>\n<h3 id=\"为何需要移动语义\"><a class=\"anchor\" href=\"#为何需要移动语义\">#</a> 为何需要移动语义</h3>\n<p>假设有如下代码：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; vstr;// build up a vector of 20000 strings,each of 1000 characters\nvector&lt;string&gt; vstr_copy1(vstr);\n</code></pre>\n<p>为了初始化 vstr_copy1 先调用 vector 的复制构造函数，使用 new 给 20000 个 string 对象分配内存，而每个 string 对象又调用 string 的复制构造函数，为 1000 个字符分配内存。这很浪费时间，但如果 vstr 与 vstr_copy1 都需要使用，这很难避免。</p>\n<p>可有时候这样不太妥当，例如 vstr 不再被使用时。例如如下定义的函数：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; allcaps(const vector&lt;string&gt; &amp; vs)\n&#123;\n    vector&lt;string&gt; temp;\n    //让temp存储vs中string的大写版本的代码\n    return temp;\n&#125;\n</code></pre>\n<p>并这样使用它：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; vstr;\nvector&lt;string&gt; vstr_copy1(vstr); //#1\nvector&lt;string&gt; vstr_copy2(allcaps(vstr)); //#2\n</code></pre>\n<p>allcaps () 创建了对象 temp，该对象管理着 20000000 个字符；语句二使用 vector 和 string 的复制构造函数创建了一个 temp 的副本，然后删除了 temp，做了大量无用功。如果编译器直接把 temp 对数据的所有权转让给 vstr_copy2，将会更好。</p>\n<p>实际上，我们可以把实际内容保留在原来地方，而之修改记录，这就是移动语义的本质，它避免了移动原始数据，而转为修改记录。</p>\n<p>要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制。这就是右值引用发挥作用的地方。可定义两个构造函数，其中一个是常规复制构造函数，它使用 const 左值引用作为参数，如语句 #1。另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参，如语句 #2 中 allcaps (vstr) 的返回值。移动构造函数可能修改其实参，这意味着右值引用参数不应是 const。</p>\n<h3 id=\"如何使用\"><a class=\"anchor\" href=\"#如何使用\">#</a> 如何使用</h3>\n<p>直接将变量的值赋值为参数的变量值，如果变量为指针，为了防止 double free，还需将参数的指针改为 nullptr。</p>\n<p>例如：</p>\n<pre><code>Useless(Useless &amp;&amp; f) : n(f.n)\n&#123;\n\t++ct;\n\tpc = f.pc;\n\tf.pc = nullptr;\n\tf.n = 0;\n&#125;\n</code></pre>\n<h3 id=\"强制移动\"><a class=\"anchor\" href=\"#强制移动\">#</a> 强制移动</h3>\n<p>移动构造函数和移动赋值运算符使用右值，如果要让它们使用左值，该怎么办？例如，将一个左值变量赋值给一个对象，并立刻丢弃这个变量。此时可以使用头文件 utility 中声明的函数 std::move。</p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/",
            "url": "http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/",
            "title": "STL学习-01-智能指针与vector",
            "date_published": "2022-10-05T11:54:58.000Z",
            "content_html": "<h1 id=\"c-的标准模板库\"><a class=\"anchor\" href=\"#c-的标准模板库\">#</a> c++ 的标准模板库</h1>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"%E9%9B%A8%E5%A4%A9-%E5%A5%B3%E5%AD%A9-%E5%95%86%E5%BA%97.jpg\" alt=\"雨天 女孩 商店\"></p>\n<h2 id=\"智能指针模板类\"><a class=\"anchor\" href=\"#智能指针模板类\">#</a> 智能指针模板类</h2>\n<p>智能指针是类似于指针的类对象，比较方便内存管理。传统的指针必须时时刻刻记得 new 与 delete 的配套使用，很容易造成内存泄漏。而智能指针实际上类似于一个类，有自己的析构函数，所以编译器再不需要智能指针时便可以自动调用其析构函数释放内存，也就是可以略去 delete 操作。</p>\n<h3 id=\"使用智能指针\"><a class=\"anchor\" href=\"#使用智能指针\">#</a> 使用智能指针</h3>\n<p>要创建智能指针对象，必须包含头文件 memory 然后使用通常的模板语法来实例化所需类型的指针。</p>\n<p>声明：  <code> template &lt;class X&gt; class auto_ptr</code></p>\n<p>使用 eg：  <code> auto_ptr&lt;double&gt; pd(new double);</code></p>\n<p>​\t\t\t\t\t  <code>auto_ptr&lt;string&gt; ps(new string);</code></p>\n<p>注意： 智能指针模板位于名称空间 std 中。</p>\n<h3 id=\"有关智能指针的注意事项\"><a class=\"anchor\" href=\"#有关智能指针的注意事项\">#</a> 有关智能指针的注意事项</h3>\n<p>c++ 目前有三种常见智能指针：auto_ptr, unique_ptr,shared_ptr</p>\n<p>在使用智能指针时，可能会遇到问题，比如如果两个智能指针指向同一块内存区域，则程序会删除同一个对象两次，这是会造成极大错误的。为避免这种问题，方法有多种。</p>\n<ul>\n<li>建立所有权概念，对于特定对象，只有一个智能指针可以拥有他。 这是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 更严格</li>\n<li>创建智能更高的指针，跟踪引用特定对象的智能指针数，这称为引用计数。当最后一个指针过期时，才调用 delete。这是 shared_ptr 的策略</li>\n<li>执行深拷贝</li>\n</ul>\n<p>auto_ptr 和 unique_ptr 的区别：</p>\n<p>​\t\t两个 auto_ptr 指向同一块内存区域时，可以通过编译，但可能在运行时报错。两个 unique_ptr 指向同一块内存区域时，会在编译阶段就报错（除非赋值给其中一个 unique_ptr 的另一个 unique_ptr 是一个用完即毁的智能指针，如某一函数中 new 出来的 unique_ptr 的返回）。</p>\n<h2 id=\"模板类vector\"><a class=\"anchor\" href=\"#模板类vector\">#</a> 模板类 vector</h2>\n<h3 id=\"创建vector\"><a class=\"anchor\" href=\"#创建vector\">#</a> 创建 vector</h3>\n<p>要创建 vector 模板对象， 可使用通常的 &lt;type&gt; 表示法来指出要使用的类型。另外，vector 模板使用动态内存分配，因此可以用初始化参数指出需要多少元素。</p>\n<p><code> vector&lt;int&gt; ratings(5);  // a vector of 5 ints</code></p>\n<h3 id=\"可对vector执行的操作\"><a class=\"anchor\" href=\"#可对vector执行的操作\">#</a> 可对 vector 执行的操作</h3>\n<p>size ()—— 返回容器中元素数目        swap ()—— 交换两个容器的内容             begin ()—— 返回一个指向容器中第一个元素的 <em><strong>迭代器</strong></em>      end () 返回一个表示超过容器尾的<em><strong>迭代器</strong></em></p>\n<p>什么是迭代器？ 它是一个广义的指针，可以对其执行类似指针的操作，如解除引用 *、递增 ++</p>\n<p>STL 的每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，作用域为整个类。如要为 vector 的 double 类型规范声明一个迭代器，可以这样做：</p>\n<p>​\t <code>vector&lt;double&gt;::iterator pd;//  pd an iterator</code></p>\n<p>假设 scores 是一个 vector&lt;double&gt; 对象，可以利用好 auto 关键字简化书写：</p>\n<p><code>auto pd = scores.begin()</code></p>\n<p>vector 还支持 push_back () (内存不够会自动扩充容器), erase () insert () 等方法</p>\n<h3 id=\"其它操作\"><a class=\"anchor\" href=\"#其它操作\">#</a> 其它操作</h3>\n<p>有两个具有代表性的 STL 函数：for_each () 和 sort () 。</p>\n<p>for_each () 函数可用于很多容器类，它接受 3 个参数。前两个是定义容器中的迭代器，最后一个是一个函数指针。for_each () 函数将被指向的函数应用于容器区间中的各个元素，可以用 for_each () 函数来代替 for 循环。</p>\n<p>eg:  <code>for_each(books.begin(), books.end(), ShowReview);</code></p>\n<p>sort () 函数也要求函数支持随机访问。该函数接收两个定义区间的迭代器参数。如果容器中的元素有内置的 &lt; 运算符进行值比较，可以直接使用。如果容器中的元素是用户定义的类对象，则用户需要利用重载定义 &lt; 运算符。</p>\n<p>还有第二个版本的 sort () 函数，它接收第三个参数，该参数是一个函数指针，不一定是用于比较的 operator&lt;()，而是一个返回值可转换为 bool 类型的函数，它接收两个容器中的元素，返回为 false 表示两个参数的顺序不正确。</p>\n",
            "tags": [
                "STL C++"
            ]
        }
    ]
}