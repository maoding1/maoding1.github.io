{
    "version": "https://jsonfeed.org/version/1",
    "title": "MikeMao's blog • All posts by \"c++\" category",
    "description": "a student of NJU who use this website to record learning experience",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/",
            "url": "http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/",
            "title": "C++：移动语义与右值引用",
            "date_published": "2022-11-14T08:08:33.000Z",
            "content_html": "<h1 id=\"c的移动语义与右值引用\"><a class=\"anchor\" href=\"#c的移动语义与右值引用\">#</a> C++ 的移动语义与右值引用</h1>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"preview.jpg\" alt=\"Gaze\"></p>\n<h2 id=\"移动语义\"><a class=\"anchor\" href=\"#移动语义\">#</a> 移动语义</h2>\n<h3 id=\"为何需要移动语义\"><a class=\"anchor\" href=\"#为何需要移动语义\">#</a> 为何需要移动语义</h3>\n<p>假设有如下代码：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; vstr;// build up a vector of 20000 strings,each of 1000 characters\nvector&lt;string&gt; vstr_copy1(vstr);\n</code></pre>\n<p>为了初始化 vstr_copy1 先调用 vector 的复制构造函数，使用 new 给 20000 个 string 对象分配内存，而每个 string 对象又调用 string 的复制构造函数，为 1000 个字符分配内存。这很浪费时间，但如果 vstr 与 vstr_copy1 都需要使用，这很难避免。</p>\n<p>可有时候这样不太妥当，例如 vstr 不再被使用时。例如如下定义的函数：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; allcaps(const vector&lt;string&gt; &amp; vs)\n&#123;\n    vector&lt;string&gt; temp;\n    //让temp存储vs中string的大写版本的代码\n    return temp;\n&#125;\n</code></pre>\n<p>并这样使用它：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; vstr;\nvector&lt;string&gt; vstr_copy1(vstr); //#1\nvector&lt;string&gt; vstr_copy2(allcaps(vstr)); //#2\n</code></pre>\n<p>allcaps () 创建了对象 temp，该对象管理着 20000000 个字符；语句二使用 vector 和 string 的复制构造函数创建了一个 temp 的副本，然后删除了 temp，做了大量无用功。如果编译器直接把 temp 对数据的所有权转让给 vstr_copy2，将会更好。</p>\n<p>实际上，我们可以把实际内容保留在原来地方，而之修改记录，这就是移动语义的本质，它避免了移动原始数据，而转为修改记录。</p>\n<p>要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制。这就是右值引用发挥作用的地方。可定义两个构造函数，其中一个是常规复制构造函数，它使用 const 左值引用作为参数，如语句 #1。另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参，如语句 #2 中 allcaps (vstr) 的返回值。移动构造函数可能修改其实参，这意味着右值引用参数不应是 const。</p>\n<h3 id=\"如何使用\"><a class=\"anchor\" href=\"#如何使用\">#</a> 如何使用</h3>\n<p>直接将变量的值赋值为参数的变量值，如果变量为指针，为了防止 double free，还需将参数的指针改为 nullptr。</p>\n<p>例如：</p>\n<pre><code>Useless(Useless &amp;&amp; f) : n(f.n)\n&#123;\n\t++ct;\n\tpc = f.pc;\n\tf.pc = nullptr;\n\tf.n = 0;\n&#125;\n</code></pre>\n<h3 id=\"强制移动\"><a class=\"anchor\" href=\"#强制移动\">#</a> 强制移动</h3>\n<p>移动构造函数和移动赋值运算符使用右值，如果要让它们使用左值，该怎么办？例如，将一个左值变量赋值给一个对象，并立刻丢弃这个变量。此时可以使用头文件 utility 中声明的函数 std::move。</p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/",
            "url": "http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/",
            "title": "STL学习-01-智能指针与vector",
            "date_published": "2022-10-05T11:54:58.000Z",
            "content_html": "<h1 id=\"c-的标准模板库\"><a class=\"anchor\" href=\"#c-的标准模板库\">#</a> c++ 的标准模板库</h1>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"%E9%9B%A8%E5%A4%A9-%E5%A5%B3%E5%AD%A9-%E5%95%86%E5%BA%97.jpg\" alt=\"雨天 女孩 商店\"></p>\n<h2 id=\"智能指针模板类\"><a class=\"anchor\" href=\"#智能指针模板类\">#</a> 智能指针模板类</h2>\n<p>智能指针是类似于指针的类对象，比较方便内存管理。传统的指针必须时时刻刻记得 new 与 delete 的配套使用，很容易造成内存泄漏。而智能指针实际上类似于一个类，有自己的析构函数，所以编译器再不需要智能指针时便可以自动调用其析构函数释放内存，也就是可以略去 delete 操作。</p>\n<h3 id=\"使用智能指针\"><a class=\"anchor\" href=\"#使用智能指针\">#</a> 使用智能指针</h3>\n<p>要创建智能指针对象，必须包含头文件 memory 然后使用通常的模板语法来实例化所需类型的指针。</p>\n<p>声明：  <code> template &lt;class X&gt; class auto_ptr</code></p>\n<p>使用 eg：  <code> auto_ptr&lt;double&gt; pd(new double);</code></p>\n<p>​\t\t\t\t\t  <code>auto_ptr&lt;string&gt; ps(new string);</code></p>\n<p>注意： 智能指针模板位于名称空间 std 中。</p>\n<h3 id=\"有关智能指针的注意事项\"><a class=\"anchor\" href=\"#有关智能指针的注意事项\">#</a> 有关智能指针的注意事项</h3>\n<p>c++ 目前有三种常见智能指针：auto_ptr, unique_ptr,shared_ptr</p>\n<p>在使用智能指针时，可能会遇到问题，比如如果两个智能指针指向同一块内存区域，则程序会删除同一个对象两次，这是会造成极大错误的。为避免这种问题，方法有多种。</p>\n<ul>\n<li>建立所有权概念，对于特定对象，只有一个智能指针可以拥有他。 这是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 更严格</li>\n<li>创建智能更高的指针，跟踪引用特定对象的智能指针数，这称为引用计数。当最后一个指针过期时，才调用 delete。这是 shared_ptr 的策略</li>\n<li>执行深拷贝</li>\n</ul>\n<p>auto_ptr 和 unique_ptr 的区别：</p>\n<p>​\t\t两个 auto_ptr 指向同一块内存区域时，可以通过编译，但可能在运行时报错。两个 unique_ptr 指向同一块内存区域时，会在编译阶段就报错（除非赋值给其中一个 unique_ptr 的另一个 unique_ptr 是一个用完即毁的智能指针，如某一函数中 new 出来的 unique_ptr 的返回）。</p>\n<h2 id=\"模板类vector\"><a class=\"anchor\" href=\"#模板类vector\">#</a> 模板类 vector</h2>\n<h3 id=\"创建vector\"><a class=\"anchor\" href=\"#创建vector\">#</a> 创建 vector</h3>\n<p>要创建 vector 模板对象， 可使用通常的 &lt;type&gt; 表示法来指出要使用的类型。另外，vector 模板使用动态内存分配，因此可以用初始化参数指出需要多少元素。</p>\n<p><code> vector&lt;int&gt; ratings(5);  // a vector of 5 ints</code></p>\n<h3 id=\"可对vector执行的操作\"><a class=\"anchor\" href=\"#可对vector执行的操作\">#</a> 可对 vector 执行的操作</h3>\n<p>size ()—— 返回容器中元素数目        swap ()—— 交换两个容器的内容             begin ()—— 返回一个指向容器中第一个元素的 <em><strong>迭代器</strong></em>      end () 返回一个表示超过容器尾的<em><strong>迭代器</strong></em></p>\n<p>什么是迭代器？ 它是一个广义的指针，可以对其执行类似指针的操作，如解除引用 *、递增 ++</p>\n<p>STL 的每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，作用域为整个类。如要为 vector 的 double 类型规范声明一个迭代器，可以这样做：</p>\n<p>​\t <code>vector&lt;double&gt;::iterator pd;//  pd an iterator</code></p>\n<p>假设 scores 是一个 vector&lt;double&gt; 对象，可以利用好 auto 关键字简化书写：</p>\n<p><code>auto pd = scores.begin()</code></p>\n<p>vector 还支持 push_back () (内存不够会自动扩充容器), erase () insert () 等方法</p>\n<h3 id=\"其它操作\"><a class=\"anchor\" href=\"#其它操作\">#</a> 其它操作</h3>\n<p>有两个具有代表性的 STL 函数：for_each () 和 sort () 。</p>\n<p>for_each () 函数可用于很多容器类，它接受 3 个参数。前两个是定义容器中的迭代器，最后一个是一个函数指针。for_each () 函数将被指向的函数应用于容器区间中的各个元素，可以用 for_each () 函数来代替 for 循环。</p>\n<p>eg:  <code>for_each(books.begin(), books.end(), ShowReview);</code></p>\n<p>sort () 函数也要求函数支持随机访问。该函数接收两个定义区间的迭代器参数。如果容器中的元素有内置的 &lt; 运算符进行值比较，可以直接使用。如果容器中的元素是用户定义的类对象，则用户需要利用重载定义 &lt; 运算符。</p>\n<p>还有第二个版本的 sort () 函数，它接收第三个参数，该参数是一个函数指针，不一定是用于比较的 operator&lt;()，而是一个返回值可转换为 bool 类型的函数，它接收两个容器中的元素，返回为 false 表示两个参数的顺序不正确。</p>\n",
            "tags": [
                "STL C++"
            ]
        }
    ]
}