{
    "version": "https://jsonfeed.org/version/1",
    "title": "MikeMao's blog • All posts by \"c++\" category",
    "description": "a student of NJU && record learning experience",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/2024/08/31/Efective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "title": "Efective Modern C++读书笔记",
            "date_published": "2024-08-31T12:44:57.000Z",
            "content_html": "<p>本书主要设计 C++11/14 的新语言特性，Modern C++ 带来的各种改变是亡羊补牢，还是脱胎换骨，通过阅读本书可能会得到答案。</p>\n<p>看书是一件乐趣，写读书笔记可不是😢。但是就阅读《Efective C++》的经历而言，减慢阅读速度而留下记录是很重要的，不知本篇何时才能完成。</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"chapter-1-类型推导\"><a class=\"anchor\" href=\"#chapter-1-类型推导\">#</a> chapter 1 类型推导</h2>\n<h3 id=\"item1-理解模板类型推导\"><a class=\"anchor\" href=\"#item1-理解模板类型推导\">#</a> item1 理解模板类型推导</h3>\n<p>模板类型推导，是 C++ 一个广泛应用的特性，并且可以被称为一个良好的设计，因为很多程序员都在完全不了解其底层运行机制的情况下，获得了满意的结果。C++ 11 带来了 <code>auto</code> ，模板类型推导也是其运行的基础，一个坏消息是有些时候它的应用并不符合直觉，因此了解模板类型推导的一些细节就有些重要了。</p>\n<p>考虑如下一个函数模板：</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nvoid f(ParamType param)\n</code></pre>\n<p>这里的 ParamType 是与 T 有关的一个类型，比如 <code>const T</code>  , <code>T &amp;</code>  等</p>\n<p>对于某一次调用 <code>f(expr)</code>  , T 的推导结果会是什么呢，答案是，<strong>既与 expr 的类型有关也和 ParamType 有关</strong>，具体要分为三种情况讨论。</p>\n<h4 id=\"情况1-paramtype是一个指针或引用但不是一个万能引用\"><a class=\"anchor\" href=\"#情况1-paramtype是一个指针或引用但不是一个万能引用\">#</a> 情况 1： ParamType 是一个指针或引用，但不是一个万能引用</h4>\n<p>这种情况下，类型推导会这样运作：</p>\n<ol>\n<li>若 expr 具有引用类型，先将引用部分忽略</li>\n<li>然后，对 <code>expr</code>  的类型和 <code>ParamType</code>  的类型执行模式匹配，来决定 T 的类型。</li>\n</ol>\n<p>for example:</p>\n<pre><code class=\"language-c++\">// 对与如下模式\ntemplate&lt;typename T&gt;\nvoid f(T&amp; param) // param 是一个引用\n\nint x = 27;\nconst int cx = x;\nconst int&amp; rx = x;\n\nf(x);                           //T是int，param的类型是int&amp;\nf(cx);                          //T是const int，param的类型是const int&amp;\nf(rx);                          //T是const int，param的类型是const int&amp;\n\n</code></pre>\n<p>这些例子只展示了左值引用，但是类型推导会如左值引用一样对待右值引用。</p>\n<h4 id=\"情况2-paramtype-是一个万能引用\"><a class=\"anchor\" href=\"#情况2-paramtype-是一个万能引用\">#</a> 情况 2： ParamType 是一个万能引用</h4>\n<p>对于使用万能引用形参的模板而言，规则就没那么显明了：</p>\n<ol>\n<li>如果 expr 是左值， <code>T</code>  和 ParamType 都会被推导为左值引用。这个结果又两点比较奇怪：首先，这是在模板类型推导中，T 被推导为引用类型的唯一情形。其次，尽管在声明时使用的是右值引用语法，它的类型推导结果却是左值引用。</li>\n<li>如果 expr 是一个右值，则应用情况 1 中的规则</li>\n</ol>\n<p>例如：</p>\n<pre><code class=\"language-c++\">template&lt;typename T&gt;\nvoid f(T&amp;&amp; param);              //param现在是一个通用引用类型\n        \nint x=27;                       //如之前一样\nconst int cx=x;                 //如之前一样\nconst int &amp; rx=cx;              //如之前一样\n\nf(x);                           //x是左值，所以T是int&amp;，\n                                //param类型也是int&amp;\n\nf(cx);                          //cx是左值，所以T是const int&amp;，\n                                //param类型也是const int&amp;\n\nf(rx);                          //rx是左值，所以T是const int&amp;，\n                                //param类型也是const int&amp;\n\nf(27);                          //27是右值，所以T是int，\n                                //param类型就是int&amp;&amp;\n</code></pre>\n<p>item24 详细解释了为什么这些例子是像这样发生的。这里关键在于通用引用的类型推导规则是不同于普通的左值或者右值引用的。尤其是，当通用引用被使用时，类型推导会区分左值实参和右值实参，但是对非通用引用时不会区分。</p>\n<h3 id=\"情况3-paramtype既非指针也非引用\"><a class=\"anchor\" href=\"#情况3-paramtype既非指针也非引用\">#</a> 情况 3： ParamType 既非指针，也非引用</h3>\n<p>当 <code>ParamType</code>  既非引用也非指针时，我们面对的就是所谓的按值传递了，这意味着无论传入的是什么，param 都会是它的一个副本，即一个全新的对象。具体来说：</p>\n<ol>\n<li>和之前一样，如果 <code>expr</code>  的类型是一个引用，忽略这个引用部分</li>\n<li>如果忽略 <code>expr</code>  的引用性之后，如果 <code>expr</code>  具有 <code>const</code>  或 <code>volatile</code>  属性，都会被忽略。</li>\n</ol>\n<p>例如：</p>\n<pre><code class=\"language-c++\">int x=27;                       //如之前一样\nconst int cx=x;                 //如之前一样\nconst int &amp; rx=cx;              //如之前一样\n\nf(x);                           //T和param的类型都是int\nf(cx);                          //T和param的类型都是int\nf(rx);                          //T和param的类型都是int\n\n</code></pre>\n<p>这是因为根据按值传递的思想， <code>expr</code>  是 const 或者 volatile 不意为着它的拷贝也不能被修改。</p>\n<p>认识到只有在传值给形参时才会忽略 <code>const</code> （和 <code>volatile</code> ）这一点很重要，正如我们看到的，对于 reference-to- <code>const</code>  和 pointer-to- <code>const</code>  形参来说， <code>expr</code>  的常量性在推导时会被保留。但是考虑这样的情况， <code>expr</code>  是一个 <code>const</code>  指针，指向 <code>const</code>  对象， <code>expr</code>  通过传值传递给 <code>param</code> ：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                <span class=\"token comment\">// 仍然以传值的方式处理 param</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> ptr <span class=\"token operator\">=</span>         <span class=\"token comment\">//ptr 是一个常量指针，指向常量对象 </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token string\">\"Fun with pointers\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                         <span class=\"token comment\">// 传递 const char * const 类型的实参</span></pre></td></tr></table></figure><p>在这里，解引用符号（*）的右边的 <code>const</code>  表示 <code>ptr</code>  本身是一个 <code>const</code> ： <code>ptr</code>  不能被修改为指向其它地址，也不能被设置为 null（解引用符号左边的 <code>const</code>  表示 <code>ptr</code>  指向一个字符串，这个字符串是 <code>const</code> ，因此字符串不能被修改）。当 <code>ptr</code>  作为实参传给 <code>f</code> ，组成这个指针的每一比特都被拷贝进 <code>param</code> 。像这种情况， <code>ptr</code> <strong> 自身的值会被传给形参</strong>，根据类型推导的第三条规则， <code>ptr</code>  自身的常量性将会被省略，所以 <code>param</code>  是 <code>const char*</code> ，也就是一个可变指针指向 <code>const</code>  字符串。在类型推导中，这个指针指向的数据的常量性将会被保留，但是当拷贝 <code>ptr</code>  来创造一个新指针 <code>param</code>  时， <code>ptr</code>  自身的常量性将会被忽略。</p>\n<h4 id=\"数组实参与函数实参\"><a class=\"anchor\" href=\"#数组实参与函数实参\">#</a> 数组实参与函数实参</h4>\n<p>在模板类型推导过程中，数组或函数类型的实参会退化成对应的指针，除非它们被用来初始化引用</p>\n<h3 id=\"item2-理解auto类型推导\"><a class=\"anchor\" href=\"#item2-理解auto类型推导\">#</a> item2 理解 auto 类型推导</h3>\n<p>继续使用上一节的这个例子来解释 auto 类型推导是如何和模板类型推导联系在一起的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>ParmaType param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                        <span class=\"token comment\">// 使用一些表达式调用 f</span></pre></td></tr></table></figure><p>当变量采用 auto 来声明时，auto 扮演了模板中 T 的角色，变量的类型饰词扮演了 ParamType 的角色。</p>\n<p>比如说：</p>\n<pre><code class=\"language-c++\">auto x = 27;\t//类型饰词是auto\nconst auto cx = x;\t//类型饰词是const auto\nconst auto&amp; rx = x;\t//类型饰词是const auto &amp;\n</code></pre>\n<p>在这里例子中要推导 x，cx 和 rx 的类型，编译器的行为看起来就像是认为这里每个声明都有一个模板，然后使用合适的初始化表达式进行调用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>            <span class=\"token comment\">// 概念化的模板用来推导 x 的类型</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">func_for_x</span><span class=\"token punctuation\">(</span>T param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">func_for_x</span><span class=\"token punctuation\">(</span><span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// 概念化调用：</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                                <span class=\"token comment\">//param 的推导类型是 x 的类型</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>            <span class=\"token comment\">// 概念化的模板用来推导 cx 的类型</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">func_for_cx</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> T param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">func_for_cx</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// 概念化调用：</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                                <span class=\"token comment\">//param 的推导类型是 cx 的类型</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>            <span class=\"token comment\">// 概念化的模板用来推导 rx 的类型</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">func_for_rx</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> T <span class=\"token operator\">&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">func_for_rx</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// 概念化调用：</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                                <span class=\"token comment\">//param 的推导类型是 rx 的类型</span></pre></td></tr></table></figure><p>除了一个例外，就是使用初始化列表时。</p>\n<p>例如：</p>\n<pre><code class=\"language-c++\">auto x = &#123; 11, 23, 9 &#125;;         //x的类型是std::initializer_list&lt;int&gt;\n\ntemplate&lt;typename T&gt;            //带有与x的声明等价的\nvoid f(T param);                //形参声明的模板\n\nf(&#123; 11, 23, 9 &#125;);               //错误！不能推导出T\n\n</code></pre>\n<p>C++\\14 中允许 <code>auto</code>  用户函数返回值，也允许 lambda 函数的形参声明中使用 <code>auto</code> , 但在这些情况下 <code>auto</code>  实际上使用模板类型推导那一套规则在工作，因此下面的代码不会通过编译：</p>\n<pre><code class=\"language-c++\">auto createInitList()\n&#123;\n    return &#123; 1, 2, 3 &#125;;         //错误！不能推导&#123; 1, 2, 3 &#125;的类型\n&#125;\n\nstd::vector&lt;int&gt; v;\n…\nauto resetV = \n    [&amp;v](const auto&amp; newValue)&#123; v = newValue; &#125;;        //C++14\n…\nresetV(&#123; 1, 2, 3 &#125;);            //错误！不能推导&#123; 1, 2, 3 &#125;的类型\n\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>在一般情况下，auto 类型推导和模板类型推导是一模一样的，但是 auto 类型推导会假定用大括号扩起的初始化表达式代表一个 std::initializer_list, 但模板类型推导不会。</li>\n<li>在函数返回值或 lambda 的形参中使用 auto，意思是使用模板类型推导规则而不是 auto 类型推导规则。</li>\n</ul>\n<h3 id=\"item3-理解decltype\"><a class=\"anchor\" href=\"#item3-理解decltype\">#</a> item3 理解 decltype</h3>\n<p>打了一大段但是忘保存了:😢, 不过相信作者的总结已经够用了。</p>\n<blockquote>\n<p>总结：</p>\n<ul>\n<li>绝大多数情况下，decltype 会得出变量或表达式的类型而不作任何修改。</li>\n<li>对于类型为 T 的左值表达式，除非改表达式仅有一个名字，decltype 总是得出类型 T&amp;</li>\n<li>C++14 支持 decltype (auto), 和 auto 一样，它会从其初始化表达式出发来推导类型，但是它的类型推导使用的是 decltype 的规则。</li>\n</ul>\n</blockquote>\n<h3 id=\"item4-掌握查看类型推导结果的方法\"><a class=\"anchor\" href=\"#item4-掌握查看类型推导结果的方法\">#</a> item4 掌握查看类型推导结果的方法</h3>\n<p>比较推荐的方法：使用 IDE 编辑器直接查看，或者使用编译器诊断信息， 而作者提到的第三种方法，使用运行时输出方法的正确性和易读性方面都有缺陷。</p>\n<p>对于使用编译器诊断信息这种方法，一个很好的方法是使用一个没有定义的类模板：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token comment\">// 只声明 TD (Type Displayer) 而不定义</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">TD</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>只要试图具现该模板，就会诱发一个错误信息，原因是找不到具现模板所需要的定义，如果想查看 x 和 y 的类型，用 x 和 y 的类型去具现 TD 即可：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>TD<span class=\"token operator\">&lt;</span><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> xType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>TD<span class=\"token operator\">&lt;</span><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> yType<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这样，编译器就可能会给出这样的信息：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>error<span class=\"token operator\">:</span> aggregate <span class=\"token char\">'TD&lt;int> xType'</span> has incomplete type <span class=\"token operator\">and</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        cannot be defined</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>error<span class=\"token operator\">:</span> aggregate <span class=\"token char\">'TD&lt;const int *> yType'</span> has incomplete type <span class=\"token operator\">and</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        cannot be defined</pre></td></tr></table></figure><p><strong>当然，即使有一些工具，理解 C++ 的类型推导规则也是很必要的。</strong></p>\n<h2 id=\"chapter2-auto\"><a class=\"anchor\" href=\"#chapter2-auto\">#</a> chapter2 auto</h2>\n<p>从概念上来说， <code>auto</code>  要多简单有多简单，但是细究起来里面却大有文章。使用 <code>auto</code>  可以少打一些字，没错，但好处不止这些：它还能阻止那些由于手动指定类型带来的潜在错误和性能问题。还有，某些 <code>auto</code>  类型推导结果尽管是按部就班地符合标准规定的推导算法，然而从程序员的视角来看却是错误的。如果是这样的情况，那就很有必要知道如何去引导 <code>auto</code>  得出正确结果，因为退回手工指定类型的声明，是通常需要避免的途径。</p>\n<p>这个小小的章节讨论了有关 <code>auto</code>  的一切。</p>\n<h3 id=\"item5-优先选用auto而非显示类型声明\"><a class=\"anchor\" href=\"#item5-优先选用auto而非显示类型声明\">#</a> item5 优先选用 <code>auto</code> , 而非显示类型声明</h3>\n<p>使用 <code>auto</code>  的好处有无数条，但是它几乎唯一的一个缺点却难以说服一些人使用 <code>auto</code> ，即 <code>auto</code>  为代码可维护性和可读性的坏影响。但是，相比于全篇使用或根本不用，了解作者提到的一些优点，适当地使用 <code>auto</code> , 我认为是很有必要的。</p>\n<ul>\n<li>\n<p><code>auto</code>  要求变量在定义的时候提供初始化，这能减少错误并提升性能。</p>\n</li>\n<li>\n<p>在使用 <code>auto</code>  声明迭代器类型或者 lambda 表达式这种复杂类型的时候，能减轻很多负担</p>\n</li>\n<li>\n<p>使用 <code>auto</code>  能减少一些隐式类型转换带来的问题，因为 programer 有时显式使用的类型与表达式实际类型并不完全相等。</p>\n</li>\n</ul>\n<p>前两点易于理解，对于第三点，考虑下面这段代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>unordered_map<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> m<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>…</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>pair<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> p <span class=\"token operator\">:</span> m<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    …                                   <span class=\"token comment\">// 用 p 做一些事</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>看起来合情合理，但是暗藏隐患。对于 <code>std::unordered_map</code>  来说，它的键值部分是 const，所以哈希表中的 <code>std::pair</code>  的类型并不是 <code>std::pair&lt;std::string,int&gt;</code> , 而是 std::pair&lt;const std::string,int&gt;。可是在上面的循环中，用来声明 <code>p</code>  的类型却不是这个。因此编译器就会想要使用某种方法把 <code>std::pair&lt;const std::string,int&gt;</code>  对象转换成 <code>std::pair&lt;std::string, int&gt;</code>  对象。这一步是可以成功的，方法是对 <code>m</code>  中的每个对象都做一次复制操作，形成一个 <code>p</code>  想要绑定的类型的临时对象，然后把 <code>p</code>  这个引用绑定到该临时对象。并且在循环的每次迭代结束时，该临时对象都会被析构一次，这之间带来的开销与使用 <code>const auto&amp;</code>  相比来说可太大了。</p>\n<h3 id=\"item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom\"><a class=\"anchor\" href=\"#item6-auto推导不符合要求时使用显式类型初始化惯用法explicitly-typed-initializer-idiom\">#</a> item6 auto 推导不符合要求时，使用显式类型初始化惯用法 (explicitly typed initializer idiom)</h3>\n<p><code>auto</code>  在大多数情况下都很好用，但在遇到一些 &quot;代理&quot; 类型的时候，可能会带来意料之外的错误。</p>\n<p>一个常见的例子是遇到 <code>vector&lt;bool&gt;</code>  的时候，对其它的 vector 容器，operator [] 通常会返回一个引用类型，可是 <code>vector&lt;bool&gt;</code>  不一样，它会返回一个 <code>std::vector&lt;bool&gt;::reference</code>  类型，原因是由于 bool 类型实际上通过 1bit 就可以表示， <code>vector&lt;bool&gt;</code>  为了节省空间，会对 bool 类型压缩为 1bit 来表示。但是这和 <code>vector&lt;bool&gt;</code>  不返回一个 <code>bool&amp;</code>  有什么关系呢，原因是，C++ 禁止返回对一个比特的引用，因此 <code>vector&lt;bool&gt;</code>  的 <code>operator[]</code>  不得不返回一个 <code>std::vector&lt;bool&gt;::reference</code>  对象，然后为了让它在使用其它所有 <code>bool&amp;</code>  的地方保证它能用，让其支持向 <code>bool</code>  类型隐式类型转换（虽然实际更复杂）。</p>\n<p>嗯，但是既然 <code>std::vector&lt;bool&gt;::reference</code>  支持向 <code>bool</code>  类型的隐式转换了，那么 <code>auto</code>  将一个表达式推导为 <code>std::vector&lt;bool&gt;::reference</code>  或者 <code>bool</code>  类型又有什么关系呢？在下面的例子中，可能会引发问题：</p>\n<p>假如我有一个函数，参数为 <code>Widget</code> ，返回一个 <code>std::vector&lt;bool&gt;</code> ，这里的 <code>bool</code>  表示 <code>Widget</code>  是否提供一个独有的特性。更进一步假设第 5 个<em> bit</em> 表示 <code>Widget</code>  是否具有高优先级，我们可以写这样的代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> <span class=\"token function\">features</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Widget<span class=\"token operator\">&amp;</span> w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">auto</span> highPriority <span class=\"token operator\">=</span> <span class=\"token function\">features</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//w 高优先级吗？</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">processWidget</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">,</span>highPriority<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// 未定义行为！</span></pre></td></tr></table></figure><p>通过上面的讲述，我们知道这里的 <code>auto</code>  会将 <code>highPriority</code>  推导为 <code>std::vector&lt;bool&gt;::reference</code>  类型，并用一个<strong>临时的</strong> <code>vector&lt;bool&gt;</code>  类型的 <code>opertor[]</code>  返回的对象来初始化它。问题是， <code>std::vector&lt;bool&gt;::reference</code>  对象中可能包含一个指针，并指向一个机器字 (word), 该机器字中含有实际上被压缩的那个 1bit 的 <code>bool</code> 。但是随着临时 <code>vector&lt;bool&gt;</code>  对象的析构，这个指针指向的地方马上就会被析构，因此 <code>highPriority</code>  中也会包含一个野指针！对它的使用自然也会包含未定义行为了。</p>\n<p>综上，程序员应该避免写出这样的代码:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">auto</span> someVar <span class=\"token operator\">=</span> expression of <span class=\"token string\">\"invisible\"</span> proxy <span class=\"token keyword\">class</span> <span class=\"token class-name\">type</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在这里， <code>auto</code>  本身并不是一个问题，而是其没有推导出想要的类型，一个解决方案是使用<strong>显式类型初始化惯用法</strong>，在上面那个例子中，可以这样操作：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">auto</span> highPriority <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">features</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>但是，这与下面这样的代码有何不同，况且还更简单：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">bool</span> highPriority <span class=\"token operator\">=</span> <span class=\"token function\">features</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>优势是，通过使用 static_cast&lt;bool&gt;，<strong>显式的指明了这里发生了一次类型转换</strong>，而让事情更加显而易见了。</p>\n<p>总结：</p>\n<ul>\n<li>不可见的代理类可能会使 <code>auto</code>  从表达式中推导出 “错误的” 类型</li>\n<li>显式类型初始化惯用法强制 <code>auto</code>  推导出你想要的结果</li>\n</ul>\n<h2 id=\"chapter3-转向现代c\"><a class=\"anchor\" href=\"#chapter3-转向现代c\">#</a> chapter3 转向现代 C++</h2>\n<h3 id=\"item7-在创建对象时注意区分和\"><a class=\"anchor\" href=\"#item7-在创建对象时注意区分和\">#</a> item7 在创建对象时注意区分 () 和 {}</h3>\n<p>总结：</p>\n<ul>\n<li>大括号初始化可以应用的语境最为广泛，可以阻止内建类型之间进行隐式窄化类型转换 (如 double 转 int)，还可以对最令人烦恼的解析语法免疫 (使用小括号初始化的时候要注意，C++ 会优先将表达式解释为声明，比如 <code>Widget w3();</code>  是一个函数声明)</li>\n<li>在构造函数重载匹配期间，只要有任何可能，大括号初始化就会与带有 <code>std::initializer_list</code>  类型的形参相匹配，即使其他重载版本有这更加匹配的形参表</li>\n<li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 <code>std::vector</code>  对象。</li>\n<li>在模板内容进行对象创建时，到底应该使用小括号还是大括号是需要仔细考虑的。</li>\n</ul>\n<h3 id=\"item8-优先使用nullptr而非0或null\"><a class=\"anchor\" href=\"#item8-优先使用nullptr而非0或null\">#</a> item8 优先使用 nullptr, 而非 0 或 NULL</h3>\n<p>优先使用 nullptr 的主要原因是，0 和 NULL 实际上是一个整型，并非指针，这在重载了支持整型和指针类型参数的函数中有时会引起问题。</p>\n<p>其次是在模板推导的时候，0 和 NULL 会被推导为 int 类型。</p>\n<h3 id=\"item9-优先选用别名声明而非typedef\"><a class=\"anchor\" href=\"#item9-优先选用别名声明而非typedef\">#</a> item9 优先选用别名声明，而非 typedef</h3>\n<p>优先选用别名声明的主要优势在于别名声明可以模板化，而 <code>typedef</code>  不行。为了达到相同效果，C++98 程序员不得不使用嵌套在模板的 struct 中的 typedef。比如下面两个分别使用别名声明和 <code>typedef</code>  来达到相同效果的例子：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> MyAllocList <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span>list<span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span>MyAlloc<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>MyAllocList<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> lw<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// client </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">MyAllocList</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">typedef</span> std<span class=\"token double-colon punctuation\">::</span>list<span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span> MyAlloc<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">>></span> type<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>MyAllocList<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>type lw<span class=\"token punctuation\">;</span> <span class=\"token comment\">// client</span></pre></td></tr></table></figure><p>另一个优点是使用模板可以让人免写 &quot;::type&quot; 后缀，并且在模板内，对于内嵌 <code>typedef</code>  的使用经常要求加上 <code>typename</code>  前缀 (见 Effective C++ 对于依赖模板类型的说明)。</p>\n<h3 id=\"item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型\"><a class=\"anchor\" href=\"#item10-优先选用限定作用域的枚举类型而非不限作用域的枚举类型\">#</a> item10 优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3>\n<p>总结：</p>\n<ul>\n<li>C++98 风格的枚举类型，现在称为不限范围的枚举类型。</li>\n<li>限定作用域的枚举类型仅在枚举类型内可见。它们只能通过强制类型转换以转换至其他类型。</li>\n<li>限定作用域的枚举类型和不限范围的枚举类型都支持底层类型指定。限定作用域的枚举类型的默认底层类型是 <code>int</code> , 而不限范围的枚举类型没有默认底层类型。</li>\n<li>限定作用域的枚举类型总是可以进行前置声明，而不限范围的枚举类型却只有在指定了默认底层类型的前提下才可以进行前置声明。</li>\n</ul>\n<h3 id=\"item11-优先选用删除函数而非private未定义函数\"><a class=\"anchor\" href=\"#item11-优先选用删除函数而非private未定义函数\">#</a> item11 优先选用删除函数，而非 <code>private</code>  未定义函数</h3>\n<ul>\n<li>优先选用删除函数，而非 <code>private</code>  未定义函数</li>\n<li>任何函数都可以删除，包括非成员函数和模板具现。</li>\n</ul>\n",
            "tags": [
                "C++ 读书笔记"
            ]
        },
        {
            "id": "http://example.com/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "title": "Effective C++读书笔记",
            "date_published": "2024-07-28T09:38:31.000Z",
            "content_html": "<p>C++ 是我最喜欢的一门语言，C++ programer 一直为其拥有的非同寻常的能力范围和表现力而自豪（当然如果能正确使用的话）。正如 Scott Meyers, 本书作者所言：学习一种编程语言的基础是一回事；学习如何用那种语言设计和实现高效率的程序完全是另外一回事。断断续续学习了两年的 C++ programing language, 我的追求从学会语言基础，逐渐变为追求更加高效，并同时具备高可扩展性和可维护性的编程。</p>\n<p>Effetive C++ 是一本主要面向 C++  03 标准及之前的 C++ 编程过程中的一些编程 guidelines 的，自 C++  11 以来，C++ 不断推陈出新，关于一些场景作者提出的解决方案也许有了更好的替代方案。但作为一切的基础，以及一系列书目的开山之作（more Efective C++, Effective Modern C++)，此书仍然被许多人认为是 CPP programer 进阶的必看书目。此读书笔记仅供我自己查阅，提供简单的总结与感想，以从作者引人入胜但对于已经认真体会的读者而言无益的行文中走出 (TLDR)。并对书中的一些问题尝试使用 C++ 11 后的新特性解决。</p>\n<p>我不想成为一个语言学家，阅读之后还需要更多的编程练习来巩固所学习的知识。</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"一些基础的杂项\"><a class=\"anchor\" href=\"#一些基础的杂项\">#</a> 一些基础的杂项</h2>\n<h3 id=\"item1-将c视为-federation-of-languages语言联合体\"><a class=\"anchor\" href=\"#item1-将c视为-federation-of-languages语言联合体\">#</a> item1 将 C++ 视为 federation of languages (语言联合体)</h3>\n<p>将 C++ 从一门编程语言看作四门互相联系但有各自主体思想的子语言的结合体：</p>\n<ul>\n<li>C: 包括 built-in 数据结构，流程控制语句等，提供语法基础。</li>\n<li>Object-Oriented C++：C++ 的面向对象部分，主要设计封装继承多态这三个方面</li>\n<li>Template C++：泛型编程部分，对多数程序员少用但及其强大的 C++ 语言部分，提供包括 TMP (模板元编程) 这样的黑魔法。</li>\n<li>STL：containers,iterators,algorithms,functions objects... 方便地使用大佬们提供的编程工具，优化编程体验，不用像 C 那样 array simulate everything 了。</li>\n</ul>\n<p>每一种子语言都有一套自己常用的编程理念，在不同的子语言下编程时，可能会要从不同的规则中进行转换（比如传值的方式）。</p>\n<h3 id=\"item2-用consts-enums和inlines-取代defines\"><a class=\"anchor\" href=\"#item2-用consts-enums和inlines-取代defines\">#</a> item2 用 consts, enums, 和 inlines 取代 #defines</h3>\n<p><strong>#defines 无法提供包括作用域控制，类型检查等功能，因此能避免就避免。一般只在控制编译逻辑的时候配合 #ifdef/#ifndef 使用，比如根据某些宏修改一些 objects 的定义，而不要用在编程的逻辑中。</strong></p>\n<ul>\n<li>想使用 #defines 定义常量时 比如 <code>#define PI 3.1415926</code> ，使用 const 替代，以获取更好的编译器报错体验与类型检查</li>\n<li>想使用 #defines 定义<strong>类属常量</strong>时，比如<strong>在类中</strong>定义 <code>static const int a = 5;</code>  这里涉及到了类属常量的初始化问题，简要来说，一些编译器禁止 static integral class constants（静态整型族类属常量）的 in-class specification 而不得不在类外使用 <code>const int MyClass::a = 5;</code>  这样的初始化方式。（ps： 都是很老的编译器了，在作者那个年代都算过时的了，gcc4.0.4 都可以在类中定义整型族常量）。对于静态非整型族类属常量，比如 <code>static const string s = &quot;hello&quot;</code> ，或者 <code>static const string s = nullptr</code>  这样的语句是不允许出现在类的定义中的。你必须要在类外初始化。for example:</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> cst <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// allowed</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> string s<span class=\"token punctuation\">;</span> <span class=\"token comment\">// static const string s = \"hello\"? not allowed</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p <span class=\"token punctuation\">;</span> <span class=\"token comment\">// static const int* p = nullter? not allowed</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> string MyClass<span class=\"token double-colon punctuation\">::</span>s <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> MyClass<span class=\"token double-colon punctuation\">::</span>p <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>这个过程体现了 C++ 令人难以忍受的缺陷，对于很多东西，它具有很多的特例，并且你很难理解为什么，没有什么规则是通用的</strong>。一个好消息是，C++ 17 后做出了补救 (又有新东西要记了)：</p>\n<p>according to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU2Mzg5Ny9ob3ctY2FuLXlvdS1kZWZpbmUtYS1zdGF0aWMtZGF0YS1tZW1iZXItb2YtdHlwZS1jb25zdC1zdGRzdHJpbmc=\">c++ - How can you define a static data member of type const std::string? - Stack Overflow</span></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">constexpr</span> <span class=\"token keyword\">int</span> cst <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">constexpr</span> std<span class=\"token double-colon punctuation\">::</span>string_view STRING <span class=\"token operator\">=</span> <span class=\"token string\">\"some useful string constant\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">constexpr</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ul>\n<li>想使用 #defines 定义函数时，使用 inline 的模版函数替代，以获取函数参数具有的参数类型检查功能，并且拥有不输于 defines 的性能。还有，在使用 defines 定义函数时，你不得不给参数加括号 😃</li>\n</ul>\n<p>对了 忘了提 enums 了，这里作者使用了一个叫做 the enum hack 的技术，主要来源于一个 enumerated type（枚举类型）的值可以用在一个需要 ints 的地方。for example:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">GamePlayer</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">&#123;</span> NumTurns <span class=\"token operator\">=</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// \"the enum hack\" - makes</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                                     <span class=\"token comment\">// NumTurns a symbolic name for 5</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">int</span> scores<span class=\"token punctuation\">[</span>NumTurns<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// fine</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用这项技术，你可以禁止对 NumTurns 的取地址行为，第二个理由是，大量的代码在使用它（作为模版元编程的基本技术之一），所以最好还是认识一下。</p>\n<p><strong>by the way, 当你声明一个常量指针的时候，最好别忘了把这个指针也设为 const。</strong></p>\n<h3 id=\"item3-只要可能就用const\"><a class=\"anchor\" href=\"#item3-只要可能就用const\">#</a> item3 只要可能就用 const</h3>\n<p>use <em>const</em> as long as possible, 经常看到的一句话了，但是看了这节后刷新了我的认知，这节内容主要分为三点：</p>\n<ol>\n<li>const 关键字提供了语义上的表达，有助于编译器发现错误。const 用途广泛，可用于对象，函数参数，返回类型，成员函数等。（这点为大部分程序员对此节标题的唯一理解）</li>\n<li>编译器坚持的是<strong> bitwise constness</strong> (二进制位常量性), 但程序员应当使用<strong> conceptual constness</strong> (概念上的常量性) 来编程。</li>\n<li>当 const 和 non-const 成员函数本质上具有相同的实现的时候，使用 non-const 版本调用 const 版本可以避免代码重复。</li>\n</ol>\n<p>关于第二点的理解：</p>\n<p>二进制位常量性是指当你声明一个变量为 const 的时候，编译器只需要检查它在内存中存储的二进制位有没有被更改就行了，因为这样实现十分方便，比如当你声明一个指针为 const 时候，你不能改变指针的值，但是你可以改变指针指向的对象的值。但是当你声明一个类为 const 的时候，只能调用 const 成员函数，并且不能改变其任何成员变量，这实在是太苛刻了。</p>\n<p>for example: 一个可以存储文本块长度的类：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">CTextBlock</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>size_t <span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pText<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>size_t textLength<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// last calculated length of textblock</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token keyword\">bool</span> lengthIsValid<span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// whether length is currently valid</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>size_t <span class=\"token class-name\">CTextBlock</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>lengthIsValid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    textLength <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>pText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// error! can't assign to textLength</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    lengthIsValid <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// and lengthIsValid in a const</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                   <span class=\"token comment\">// member function</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token keyword\">return</span> textLength<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>对于 length () 成员函数，由于语义的需要必须定义为 const。但不想每次都调用 strlen 计算文本长度，这会带来许多开销，于是便用上述方法存储字符串长度。但是这违反了二进制常量性，毕竟改变了成员变量。</p>\n<p>因此引入了逻辑常量性的概念，这一理念认为，** 一个 const 成员函数可以改变对象中的一些 bits, 但是只能用客户无法察觉的方法。** 这种理念的实现是通过 mutable 关键字实现的，比如将上面的 textLength 和 lengthIsValid 变量用 mutable 修饰即可。</p>\n<p>对于第三点的理解：</p>\n<p>一般来说，类中重载的 const 成员函数和非 const 成员函数的逻辑都是差不多的，这带来了额外的编译时间，维护成本以及代码膨胀，这对于一些程序员来说是不可忍受的。因此可以使用这样一个 trick: 通过强制转型，让 non-const 成员函数调用 const 版本。for example:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">TextBlock</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t position<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>     <span class=\"token comment\">// same as before</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">[</span>position<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t position<span class=\"token punctuation\">)</span>         <span class=\"token comment\">// now just calls const op[]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token generic-function\"><span class=\"token function\">const_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">&amp;</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>                         <span class=\"token comment\">// cast away const on</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                                                 <span class=\"token comment\">// op[]'s return type;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">const</span> TextBlock<span class=\"token operator\">&amp;</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>     <span class=\"token comment\">// add const to *this's type;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>          <span class=\"token punctuation\">[</span>position<span class=\"token punctuation\">]</span>                             <span class=\"token comment\">// call const version of op[]</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这样的代码通过不了选美比赛 😄 ，但是它有效。</p>\n<p><strong>注意，反过来让 const 版本调用 non-const 版本不可取，因为违反了 const 的语义，你将承受改变成员变量的风险。</strong></p>\n<h3 id=\"item-4-确保对象在使用前被初始化\"><a class=\"anchor\" href=\"#item-4-确保对象在使用前被初始化\">#</a> item 4 确保对象在使用前被初始化</h3>\n<p>对于 C++ 的对象，当你不初始化它们时，有些时候它们会自动初始化，有时候不会，因此为了避免 ub，再声明的同时最好也初始化它们。</p>\n<p>要点：</p>\n<ul>\n<li>\n<p>手动初始化 built-in type 的 objects，因为 C++ 只在某些时候才会自己初始化它们</p>\n</li>\n<li>\n<p>在 constructor 中，用 member initialization list 代替函数体中的 assignment。initialization list 中 data members 的排列顺序要与它们在 class（类）中被声明的顺序相同。因为在构造函数赋值之前，成员变量已经被默认初始化好了，这样做能提升性能。除此之外的是，有些时候，初始化列表式可选项，有时候是必选项，因此为了方便记忆，一律使用初始化列表即可。</p>\n</li>\n<li>\n<p>通过用 local static objects（局部静态对象）代替 non-local static objects（非局部静态对象）来避免跨 translation units（编译单元）的 初始化顺序问题。</p>\n</li>\n</ul>\n<p>即将在全局中定义一个 <code>static FileSystem fs; </code>  替换为提供一个函数，有点像单例模式：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FileSystem<span class=\"token operator\">&amp;</span> <span class=\"token function\">tfs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\">// this replaces the tfs object; it could be</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>                                   <span class=\"token comment\">// static in the FileSystem class</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">static</span> FileSystem fs<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// define and initialize a local static object</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">return</span> fs<span class=\"token punctuation\">;</span>                        <span class=\"token comment\">// return a reference to it</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"构造-析构与赋值\"><a class=\"anchor\" href=\"#构造-析构与赋值\">#</a> 构造、析构与赋值</h2>\n<h3 id=\"item5-了解c为你默认编写并调用了哪些函数\"><a class=\"anchor\" href=\"#item5-了解c为你默认编写并调用了哪些函数\">#</a> item5 了解 C++ 为你默认编写并调用了哪些函数</h3>\n<ul>\n<li>编译器可以隐式生成一个 class（类）的 default constructor（缺省构造函数），copy constructor（拷贝构造函数），copy assignment operator（拷贝赋值运算符）和 destructor（析构函数）。C++11 后还增加了移动构造和移动赋值。</li>\n</ul>\n<p><strong>对于以下场景：深拷贝，类中有 const 或引用成员变量，以及析构函数有 virtual 需求的时候，默认生成的函数可能不会符合要求</strong>。</p>\n<h3 id=\"item6-若不想使用编译器生成函数就明确拒绝\"><a class=\"anchor\" href=\"#item6-若不想使用编译器生成函数就明确拒绝\">#</a> item6 若不想使用编译器生成函数，就明确拒绝</h3>\n<p>在 C++ 11 之前，作者是通过将相应的成员函数声明为 private 实现的，或者继承自一个使用这种方法实现的 Uncopyable 的基类。</p>\n<p>C++ 11 之后，使用 <code>= delete</code>  即可</p>\n<h3 id=\"item7-为多态基类声明虚析构函数\"><a class=\"anchor\" href=\"#item7-为多态基类声明虚析构函数\">#</a> item7 为多态基类声明虚析构函数</h3>\n<p>为了防止内存泄露，必须将多态基类的析构函数声明为虚函数</p>\n<p>除此之外还要注意两点：</p>\n<ul>\n<li>普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价</li>\n<li>如果一个类型没有被设计成多态基类，又有被误继承的风险，可以使用 C++ 11 中的 <code>final</code>  关键字，这样禁止派生可以防止误继承造成上述问题。</li>\n</ul>\n<h3 id=\"item8-防止异常逃离析构函数\"><a class=\"anchor\" href=\"#item8-防止异常逃离析构函数\">#</a> item8 防止异常逃离析构函数</h3>\n<p>两个要点：</p>\n<ul>\n<li>destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后<strong>抑制它们或者终止程序</strong>。这里的抑制指的是在 try catch 语句中捕获并处理。</li>\n<li>如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。</li>\n</ul>\n<p>对于第二点，一个常见例子是使用各种 db 的连接池的场景，通常用户需要使用 db.close () 显式释放资源，对于拥有 RAII 机制的 C++ 来说，为什么还需要这样做呢。因为通过 db.close () 这样的普通成员函数，用户可以通过 try catch 语句自行对这个异常做出回应。在析构函数中，同样可以继续使用 RAII 机制，记录用户有无手动释放，没有则自行调用 db.close ()</p>\n<h3 id=\"item9-避免在构造函数或者析构函数中调用虚函数\"><a class=\"anchor\" href=\"#item9-避免在构造函数或者析构函数中调用虚函数\">#</a> item9 避免在构造函数或者析构函数中调用虚函数</h3>\n<p>简单来说，在构造和析构的时候，对象的类型是不确定的，因此想要调用的虚函数可能不会如你所愿。可以这样理解，再析构和构造函数中虚函数表的构造和析构的时机是不确定的，因此调用虚函数会存在问题。</p>\n<p>这点看似简单，却十分容易踩坑，考虑以下场景，为了避免重复代码，我们可能将不同的变量初始化放到一个 init () 函数之中，即使这个函数不是虚函数，但如果其中调用了虚函数，还是违背了这一原则，并且以难以察觉的方式。</p>\n<h3 id=\"item10-在赋值运算符中返回一个reference-to-this\"><a class=\"anchor\" href=\"#item10-在赋值运算符中返回一个reference-to-this\">#</a> item10 在赋值运算符中返回一个 reference to *this</h3>\n<p>简单来说 这样做是为了支持链式赋值并让自己的接口和内置类型的接口尽可能相似。因此，请将赋值操作符的返回类型设为 ObjectClass&amp; 并返回 * this。</p>\n<h3 id=\"item11-在赋值运算符中处理自赋值\"><a class=\"anchor\" href=\"#item11-在赋值运算符中处理自赋值\">#</a> item11 在赋值运算符中处理自赋值</h3>\n<p>当给一个对象赋值时，一般来说，这个对象需要释放现有资源，然后通过赋值获取新资源，这个逻辑在处理自我赋值的时候会失效，因为释放的资源可能永远找不到了。</p>\n<p>解决这个问题的一个方案是，通过特判处理自赋值情况，很简单也常见的一种思路如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>SomeClass<span class=\"token operator\">&amp;</span> SomeClass<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> SomeClass<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">delete</span> ptr<span class=\"token punctuation\">;</span>\t</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  ptr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">DataBlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>rhs<span class=\"token punctuation\">.</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 如果此处抛出异常，ptr 将指向一块已经被删除的内存。</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>首先这种方案的一个问题是：当释放已有资源后，获取新资源的过程可能发生异常，此时指针会指向被释放的资源，导致后续程序出错。</p>\n<p>解决的思路也很简单，即先获取新的资源，然后再释放原有的资源：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>SomeClass<span class=\"token operator\">&amp;</span> SomeClass<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> SomeClass<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  DataBlock<span class=\"token operator\">*</span> pOrg <span class=\"token operator\">=</span> ptr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  ptr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">DataBlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>rhs<span class=\"token punctuation\">.</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 如果此处抛出异常，ptr 仍然指向之前的内存。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">delete</span> pOrg<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>同样，这种方案也不用特判是否是自赋值语句了，还有一点好处是，通过减少 if 语句，可能会对指令流水线的工作有益。</p>\n<p>还有一种方案是使用 copy-and-swap 方法，不过本人感觉性能可能会稍低，因此不作讨论。</p>\n<h3 id=\"item12-拷贝一个对象的所有组成成分\"><a class=\"anchor\" href=\"#item12-拷贝一个对象的所有组成成分\">#</a> item12 拷贝一个对象的所有组成成分</h3>\n<p>即时刻注意以下三点：</p>\n<ul>\n<li>为类增加成员时，别忘了更改拷贝相关的函数中的逻辑</li>\n<li><mark>在继承的场景下，子类需要并且必须通过调用父类的拷贝构造或拷贝赋值来进行父类成员的拷贝。</mark></li>\n<li>拷贝构造和拷贝赋值不能互相调用，如果想减少代码重复，就将通用功能放入一个第三方的函数中。</li>\n</ul>\n<h2 id=\"资源管理\"><a class=\"anchor\" href=\"#资源管理\">#</a> 资源管理</h2>\n<h3 id=\"item13-使用对象管理资源\"><a class=\"anchor\" href=\"#item13-使用对象管理资源\">#</a> item13 使用对象管理资源</h3>\n<p>经典的 RAII 思想，即利用析构函数退出作用域自动调用的特点处理资源的释放。</p>\n<p>C++11 后有了智能指针，因此 RAII 的实践已经很简单了。没想到那时候的智能指针已经存在于 tr1 库里了😄</p>\n<h3 id=\"item14-谨慎考虑资源管理类的拷贝行为\"><a class=\"anchor\" href=\"#item14-谨慎考虑资源管理类的拷贝行为\">#</a> item14 谨慎考虑资源管理类的拷贝行为</h3>\n<p>即需要考虑在不同情况下是否要禁止或以其他方式控制对资源的拷贝。</p>\n<p>C++11 后有了 shared_ptr 和 unique_ptr 后，应该能应付各种场景了。</p>\n<h3 id=\"item15-在资源管理类中准备访问裸资源raw-resources\"><a class=\"anchor\" href=\"#item15-在资源管理类中准备访问裸资源raw-resources\">#</a> item15 在资源管理类中准备访问裸资源（raw resources）</h3>\n<p>在智能指针中，可以发现，它们提供了 get () 方法获取保管的资源。为什么？</p>\n<p>因为很多 API 的参数中，是和资源本身打交道的，因此一个 RAII 资源管理类需要提供访问裸资源的接口。</p>\n<p>一个疑问是，这样是否违反了封装性？答案是不会，因为 RAII 只是为了保证资源释放这个行为的发生，封装不是其存在的目的。同时，如果你提供隐式转换，可能会导致一些预期之外的错误，因此资源管理类仅提供显示转换是最合理的。</p>\n<h3 id=\"item16-使用相同形式的new和delete\"><a class=\"anchor\" href=\"#item16-使用相同形式的new和delete\">#</a> item16 使用相同形式的 new 和 delete</h3>\n<p>即 new 和 delete，new [] 和 delete [] 搭配使用</p>\n<h3 id=\"item17-在一个独立的语句中将new出来的对象存入智能指针\"><a class=\"anchor\" href=\"#item17-在一个独立的语句中将new出来的对象存入智能指针\">#</a> item17 在一个独立的语句中将 new 出来的对象存入智能指针</h3>\n<p>此条是为了防止非常微妙的内存泄漏，这种 bug 发生概率很小，但一旦出现很难被解决。</p>\n<p>对于这样的两个函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">priority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">processWidget</span><span class=\"token punctuation\">(</span>share_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> sp<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> priority<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一个简洁的调用方法是：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">processWidget</span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">share_ptr</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>widget<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">priority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>但这个语句的一大特点是，可能变为这样的执行顺序：</p>\n<ol>\n<li>\n<p>执行 &quot;new Widget&quot;。</p>\n</li>\n<li>\n<p>调用 priority。</p>\n</li>\n<li>\n<p>调用 shared_ptr 的构造函数。</p>\n</li>\n</ol>\n<p>当在第二点中发生了异常，第一点的 new Widget () 构造的类可能就会发生内存泄漏。</p>\n<p>避免类似问题的方法很简单：用一个单独的语句创建 Widget 并将它存入一个智能指针，然后将这个智能指针传递给 processWidget</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token function\">pw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// store newed object</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>                                      <span class=\"token comment\">// in a smart pointer in a</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t\t\t\t\t\t\t\t  <span class=\"token comment\">// standalone statement</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">processWidget</span><span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">,</span> <span class=\"token function\">priority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// this call won't leak</span></pre></td></tr></table></figure><p>这样做是因为编译器在不同的语句之间重新安排操作顺序的活动余地比在一个语句之内要小得多</p>\n<h2 id=\"设计与声明\"><a class=\"anchor\" href=\"#设计与声明\">#</a> 设计与声明</h2>\n<h3 id=\"item18-让接口容易被正确使用\"><a class=\"anchor\" href=\"#item18-让接口容易被正确使用\">#</a> item18 让接口容易被正确使用</h3>\n<p>本条款讨论如何<strong>帮助你的客户在使用你的接口时避免他们犯错误</strong>。</p>\n<p>在设计接口时，我们常常会错误地假设，接口的调用者<strong>拥有某些必要的知识来规避一些常识性的错误</strong>。但事实上，接口的调用者并不总是像正在设计接口的我们一样 “聪明” 或者知道接口实现的” 内幕信息 “，结果就是，我们错误的假设使接口表现得不稳定。这些不稳定因素可能是由于调用者缺乏某些先验知识，也有可能仅仅是代码上的粗心错误。接口的调用者可能是别人，也可能是未来的你。所以一个合理的接口，应该尽可能的从<strong>语法层面</strong>并在<strong>编译之时运行之前</strong>，帮助接口的调用者规避可能的风险。</p>\n<ul>\n<li>使用<strong>外覆类型（wrapper）<strong>提醒调用者传参错误检查，将参数的附加条件限制在</strong>类型本身</strong></li>\n</ul>\n<p>当调用者试图传入数字 “13” 来表达一个 “月份” 的时候，你可以在函数内部做运行期的检查，然后提出报警或一个异常，但这样的做法更像是一种责任转嫁 —— 调用者只有在尝试过后才发现自己手残把 “12” 写成了 “13”。如果在设计参数类型时就把 “月份” 这一类型抽象出来，比如使用 enum class（强枚举类型），就能帮助客户在编译时期就发现问题，把参数的附加条件限制在类型本身，可以让接口更易用。</p>\n<ul>\n<li>从<strong>语法层面</strong>限制调用者<strong>不能做的事</strong></li>\n</ul>\n<p>接口的调用者往往无意甚至没有意识到自己犯了个错误，所以接口的设计者必须在语法层面做出限制。一个比较常见的限制是加上 <code>const</code> ，比如在 <code>operate*</code>  的返回类型上加上 <code>const</code>  修饰，可以防止无意错误的赋值 <code>if (a * b = c)</code> 。</p>\n<ul>\n<li>接口应表现出与内置类型的一致性</li>\n</ul>\n<p>让自己的类型和内置类型的一致性，比如自定义容器的接口在命名上和 STL 应具备一致性，可以有效防止调用者犯错误。或者你有两个对象相乘的需求，那么你最好重载 <code>operator*</code>  而并非设计名为”multiply” 的成员函数。</p>\n<ul>\n<li>从语法层面限制调用者<strong>必须做的事</strong></li>\n</ul>\n<p><strong>别让接口的调用者总是记得做某些事情</strong>，接口的设计者应在假定他们<strong>总是忘记</strong>这些条条框框的前提下设计接口。比如用智能指针代替原生指针就是为调用者着想的好例子。如果一个核心方法需要在使用前后设置和恢复环境（比如获取锁和归还锁），更好的做法是将设置和恢复环境设置成纯虚函数并要求调用者继承该抽象类，强制他们去实现。在核心方法前后对设置和恢复环境的调用，则应由接口设计者操心。</p>\n<p><strong>当方法的调用者（我们的客户）责任越少，他们可能犯的错误也就越少。</strong></p>\n<h3 id=\"item19-将class的设计当成设计一个type\"><a class=\"anchor\" href=\"#item19-将class的设计当成设计一个type\">#</a> item19 将 class 的设计当成设计一个 type</h3>\n<p>本条款提醒我们设计 class 需要考虑的问题：</p>\n<ul>\n<li>对象该如何创建销毁：包括构造函数、析构函数以及 new 和 delete 操作符的重构需求。</li>\n<li>对象的初始化与赋值行为应有何区别。</li>\n<li>对象被拷贝时应考虑的行为：拷贝构造函数。</li>\n<li>对象的合法值是什么？在成员函数内部对参数做合法性检查。</li>\n<li>新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题。</li>\n<li>新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非 explicit 函数之间的取舍。</li>\n<li>新类型是否需要重载操作符。</li>\n<li>什么样的接口应当暴露在外，而什么样的接口应当封装在内（public 和 private）</li>\n<li>新类型的效率、资源获取归还、线程安全性和异常安全性如何保证。</li>\n<li>这个类是否具备 template 的潜质，如果有的话，就应改为模板类。</li>\n</ul>\n<h3 id=\"item20-尽量使用pass-by-reference-to-const替换pass-by-value\"><a class=\"anchor\" href=\"#item20-尽量使用pass-by-reference-to-const替换pass-by-value\">#</a> item20 尽量使用 pass-by-reference-to-const 替换 pass-by-value</h3>\n<p>值传参的问题有：</p>\n<ul>\n<li>按值传参涉及大量参数的复制，这些副本大多是没有必要的。</li>\n<li>如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。</li>\n<li><strong>对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。</strong></li>\n<li>小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。</li>\n</ul>\n<p>尽管如此，面对内置类型和 STL 的迭代器与函数对象，我们通常还是会选择按值传参的方式设计接口。因为，对于内置类型和迭代器，它们往往很小，值传递开销低，有时甚至胜过引用。至于函数对象，值传递主要解决多线程中的同步问题。</p>\n<h3 id=\"item21-必须返回对象时切忌返回reference\"><a class=\"anchor\" href=\"#item21-必须返回对象时切忌返回reference\">#</a> item21 必须返回对象时，切忌返回 reference</h3>\n<p>主要是一些程序员妄想减少拷贝的开销，而试图将函数的返回值设为引用，而导致对象析构后还试图调用引发错误。</p>\n<p>C++ 11 之后，通过 std::move () 和移动构造函数即可解决这个问题。</p>\n<h3 id=\"item22-将成员变量声明为private\"><a class=\"anchor\" href=\"#item22-将成员变量声明为private\">#</a> item22 将成员变量声明为 private</h3>\n<p>结论：** 请对 class 内所有成员变量声明为 <code>private</code> ， <code>private</code>  意味着对变量的封装。** 作者提供了更有价值的信息在于不同的属性控制 —— <code>public</code> , <code> private</code>  和 <code>protected</code> ——<strong> 代表的设计思想</strong>。</p>\n<p>简单的来说，把所有成员变量声明为 private 的好处有两点。首先，所有的变量都是 private 了，那么所有的 public 和 protected 成员都是函数了，用户在使用的时候也就无需区分，这就是<strong>语法一致性</strong>；其次，对变量的封装意味着，<strong>可以尽量减小因类型内部改变造成的类外外代码的必要改动。增加可维护性</strong>。</p>\n<p>作者还提出了一个观点，对 <code>private</code>  来说 ** <code>public</code>  和 <code>protected</code>  属性在一定程度上是等价的 **。一个自定义类型被设计出来就是供客户使用的，那么客户的使用方法无非是两种 ——<strong> 用这个类创建对象</strong>或者<strong>继承这个类以设计新的类</strong> —— 以下简称为第一类客户和第二类客户。那么从封装的角度来说，一个 <code>public</code>  的成员说明了<strong>类的作者决定对类的第一种客户不封装此成员</strong>，而一个 <code>protected</code>  的成员说明了<strong>类的作者对类的第二种客户不封装此成员</strong>。也就是说，当我们把类的两种客户一视同仁了以后， <code>public</code> 、 <code>protected</code>  和 <code>private</code>  三者反应的即类设计者对类成员封装特性的不同思路 —— 对成员封装还是不封装，如果不封装是对第一类客户不封装还是对第二类客户不封装。</p>\n<p>有意思的是 Java 就删除了 protected 继承，因为这个功能太鸡肋了吧，至少在 C++ 中我还没有见到过使用 protected 的例子。</p>\n<h3 id=\"item23-用非成员非友元函数取代成员函数\"><a class=\"anchor\" href=\"#item23-用非成员非友元函数取代成员函数\">#</a> item23 用非成员非友元函数取代成员函数</h3>\n<p>用非成员非友元函数取代成员函数，<strong>可以提高封装性与可扩展性</strong></p>\n<p>比如对一个浏览器清除 cookie，cache 和 history 的函数，到底是应该选择 choice1:  <code>WebBrowzer.clearEverything()</code>  这样一个接口，还是应该选择 choice2:  <code>clearBrowser(WebBrowser &amp;wb)</code>  呢，注意 WebBrowzer 类已经提供了基本的清除 cookie,cache 和 history 的接口，如下所示：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">WebBrowser</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">clearCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">clearHistory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">removeCookies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>为了方便用户，提供两种清除数据接口的选择如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">WebBrowser</span> <span class=\"token punctuation\">&#123;</span>\t\t\t\t\t\t<span class=\"token comment\">//choice 1: 成员函数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">clearEverything</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>               <span class=\"token comment\">// calls clearCache, clearHistory,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                                        <span class=\"token comment\">// and removeCookies</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">clearBrowser</span><span class=\"token punctuation\">(</span>WebBrowser<span class=\"token operator\">&amp;</span> wb<span class=\"token punctuation\">)</span>\t\t<span class=\"token comment\">//choice 2: 非成员非友元函数</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  wb<span class=\"token punctuation\">.</span><span class=\"token function\">clearCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  wb<span class=\"token punctuation\">.</span><span class=\"token function\">clearHistory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  wb<span class=\"token punctuation\">.</span><span class=\"token function\">removeCookies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><ins class=\"primary\">如何提高封装性:</ins></p>\n<p>可以使用这样一个标准来衡量类的封装性，即可以<mark>直接访问</mark>类的 private 部分的函数的数量，这个数量越多，类的封装性就越差。从这点来看，应该选择使用 choice2。</p>\n<p><ins class=\"primary\">如何提高可扩展性:</ins></p>\n<p>个人认为，这一点更具有说服力。假设将类的成员函数分为两类：直接访问 private 部分的成员函数，如 <code>clearCache() clearHistory()</code>  等与间接访问 private 部分的成员函数，如这里的 <code>clearEverything()</code> 。很明显，第二种成员函数的<mark>设计目标是为了方便程序员的操作</mark>，因为即使没有第二种函数，程序员也可以通过调用第一种函数来达到目的。</p>\n<p>既然如此，为何不更方便一点呢，要实现这一点，需要配合 C++ 的 namespace 功能来实现。</p>\n<p>假设我们采用 choice1, 即使用更多的成员函数，类的定义会变得冗长，并且当我们更改某些 “方便” 成员函数的时候，使用这个类定义的所有编译单元都必须重新编译。解决这个问题的一个例子是 C++ 的 std 命名空间，比如 vector,string 等 std 命名空间提供的功能，分散在不同的源文件和头文件中，当你需要使用 vector 时，你无需 include string 相关的头文件。可以说，string 相关代码对你当前的代码没有影响。</p>\n<p>假设 webBrowser 类得到了扩展，需要提供书签，打印，清除数据这三个功能，完全可以使用一个 <code>namespace WebBrowserStuff</code>  并在不同的三个头文件和源文件中分别定义这三个功能相关的 &quot;方便&quot; 函数。假设某个源文件只需要类的打印功能，它不需要 include 其它的头文件，除了打印相关的其它头文件与源文件的更改也不会影响这个源文件的编译。</p>\n<p><ins class=\"dot\">简单来说： 我们通过将一个类的相关功能函数拆的四分五裂，达到了更高的灵活性与可扩展性。</ins></p>\n<h3 id=\"item24-当类型转换应该用于所有参数时声明为非成员函数\"><a class=\"anchor\" href=\"#item24-当类型转换应该用于所有参数时声明为非成员函数\">#</a> item24 当类型转换应该用于所有参数时，声明为非成员函数</h3>\n<p>一个简单的例子即可说明：</p>\n<p>考虑一个可以接受单个 int 类型构造的 Rational 类，如果在类中重载 operator* ，可以与另一个 Rational 类使用 * 运算符做乘法。这样的做法允许使用 <code>rational * 2</code>  而不允许使用 <code>2 * rational</code>  这样的语句，这往往不是程序员所期望的。即<mark>如果一个操作符是成员函数，那么它的第一个操作数 (调用对象) 不会发生隐式类型转换。</mark></p>\n<p>因此如果想允许像从 2 到 rational 对象这样的隐式类型转换，应该将 operator * 的重载放在类外。</p>\n<p>by the way, 如果想要禁止对某些类型的隐式类型转换，可以使用 C++ 11 之后的  <code>explicit</code>  关键字</p>\n<h3 id=\"item25-考虑支持不抛异常的-swap\"><a class=\"anchor\" href=\"#item25-考虑支持不抛异常的-swap\">#</a> item25 : 考虑支持不抛异常的 swap</h3>\n<p>此节内容非常精彩，深深体现了 C++ 语言的魅力，或者在反 C++ 程序员眼中无法忍受的特点：<strong>为了极致的性能提升而大大增加的程序复杂性与给程序员带来的思想负担，即使这个性能提升有时并不明显</strong>。一个简单的 swap 函数，竟然涉及了这么多的知识：模板类、完全特化与非完全特化、std 命名空间的扩充限制、命名空间与目标函数搜索规则、注重异常安全的编程范式...</p>\n<p>swap 是一个重要的函数，在本书中，它就作为异常安全编程 (exception-safe) 的基础 (item 29) 和一种实现自赋值的通用机制 (item 11) 被提及。</p>\n<p>作为一切的基础，先看看 std::swap 是如何实现的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">namespace</span> std <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>          <span class=\"token comment\">// 与常见的实现相同</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span> T<span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span>         </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    T <span class=\"token function\">temp</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    b <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到一点：只要我们的类型支持拷贝，std::swap 就能完成它的工作。</p>\n<p>缺点是：它太慢了，特别是对于成员变量含有指针的函数，它带来了三次拷贝，并且是不必要的。</p>\n<p>考虑这样一个类 Widget（体现了 pointer to implemention 设计思想的一组类），即它的主要成员是一个 WidgetImpl, 它长这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">WidgetImpl</span> <span class=\"token punctuation\">&#123;</span>                          <span class=\"token comment\">// class for Widget data;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span>                                     <span class=\"token comment\">// details are unimportant</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">;</span>                              <span class=\"token comment\">// possibly lots of data —</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">double</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// expensive to copy!</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">&#123;</span>                              <span class=\"token comment\">// class using the pimpl idiom</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Widget<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  Widget<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Widget<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span>      <span class=\"token comment\">// to copy a Widget, copy its</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span>                                         <span class=\"token comment\">// WidgetImpl object. For</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                      <span class=\"token comment\">// details on implementing</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>   <span class=\"token operator\">*</span>pImpl <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>rhs<span class=\"token punctuation\">.</span>pImpl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// operator= in general,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                      <span class=\"token comment\">// see Items 10, 11, and 12.</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  WidgetImpl <span class=\"token operator\">*</span>pImpl<span class=\"token punctuation\">;</span>                         <span class=\"token comment\">// ptr to object with this</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>考虑使用 std::swap 的开销：<strong>它不仅要拷贝三个 Widgets，而且还有三个 WidgetImpl 对象，而实际上只需要交换它们的指针就可以了</strong></p>\n<p>一个自然的想法是，我们提供 std::swap 的一个特化版本，如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">namespace</span> std <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>                            </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">swap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span>         <span class=\"token comment\">// 对 std::swap 特化 虽然还不能编译</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                    Widget<span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span>         </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>pImpl<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span>pImpl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// 只用交换指针就行</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                     </pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>不能通过编译的原因是，访问了 Widget 类中 private 部分的指针。解决这一问题也很简单：要么声明这个特化为 Widget 类的友元，要么让 Widget 提供一个成员函数 swap 作为接口，并让这个特化去调用它。根据 STL 中容器的选择：这里让 Widget 声明一个名为 swap 的 public 成员函数去做实际的交换，然后特化 std::swap 去调用那个成员函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">&#123;</span>                    </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span>                           </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&amp;</span> other<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>swap<span class=\"token punctuation\">;</span>                                    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>pImpl<span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">.</span>pImpl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">namespace</span> std <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>                       <span class=\"token comment\">// revised specialization of</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">swap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span>     <span class=\"token comment\">// std::swap</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                    Widget<span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    a<span class=\"token punctuation\">.</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                     <span class=\"token comment\">// to swap Widgets, call their</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                <span class=\"token comment\">// swap member function</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>到此问题告一段落，除非我们让问题变得更复杂一些：假设 Widget 和 WidgetImpl 是类模板，而不是类呢，比如说我们参数化存储在 WidgetImpl 中的数据类型：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">WidgetImpl</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>可以很自然的在刚才的基础上写出这样一段代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">namespace</span> std <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token generic-function\"><span class=\"token function\">swap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span>      <span class=\"token comment\">// error! illegal code!</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                        Widget<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>但是，它通过不了编译。理由是：这是一个试图对函数进行部分特化 (partial specialization) 的代码，<strong>而与允许对类进行部分特化相反的是，C++ 不允许对函数进行部分特化</strong>。这是由于函数重载完全可以达到函数部分特化的目的，所以 C++ 索性禁止了函数部分特化。正确使用重载来达到目的的代码是：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">namespace</span> std <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>             <span class=\"token comment\">// an overloading of std::swap</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span>          <span class=\"token comment\">// (note the lack of \"&lt;...>\" after</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            Widget<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span>          <span class=\"token comment\">// \"swap\"), but see below for</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>                   <span class=\"token comment\">// why this isn't valid code</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在通常情况下，上面的代码已经足够达成目的了，但是很遗憾，这又触发了 C++ 的另一条红线，因为我们试图为 C++ 的 std 命名空间添加新成员，而这一做法是 ub 的。<mark>根据<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2V4dGVuZGluZ19zdGQ=\"> Extending the namespace std - cppreference.com</span>C++ 禁止对 std 命名空间进行扩充，除非你试图为一个用户定义类型而对 std 空间里的原有成员添加一个完全特化。一个解释是：用户在扩充 std 命名空间后，如果下一个版本的 C++ 添加了一个与用户命名相同的新成员，就会发生命名冲突，从而导致用户之前的代码不再可用。</mark></p>\n<p>作者使用的方法是，将上面的代码原封不动地从 std 中挪到 Widget 类所在的命名空间：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">namespace</span> WidgetStuff <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                     <span class=\"token comment\">// templatized WidgetImpl, etc.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>                    <span class=\"token comment\">// as before, including the swap</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// member function</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>                    <span class=\"token comment\">// non-member swap function;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span>                 <span class=\"token comment\">// not part of the std namespace</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            Widget<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span>                                         </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    a<span class=\"token punctuation\">.</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在，从 client 视角来看我们的程序，</p>\n<p>假设你写了一个函数模板来交换两个对象的值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;</span> obj1<span class=\"token punctuation\">,</span> T<span class=\"token operator\">&amp;</span> obj2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">,</span> obj2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>哪一个 swap 应该被调用呢？std 中的通用版本，你知道它必定存在；std 中的通用版本的特化，可能存在，也可能不存在；T 专用版本，可能存在，也可能不存在，可能在一个 namespace 中，也可能不在一个 namespace 中（但是肯定不在 std 中）。究竟该调用哪一个呢？如果 T 专用版本存在，你希望调用它，如果它不存在，就回过头来调用 std 中的通用版本。如下这样就可以符合你的希望：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;</span> obj1<span class=\"token punctuation\">,</span> T<span class=\"token operator\">&amp;</span> obj2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>swap<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// make std::swap available in this function</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">,</span> obj2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// call the best swap for objects of type T</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当编译器看到这个 swap 调用，他会寻找正确的 swap 版本来调用。<mark>C++ 的名字查找规则 (参见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2FkbA==\"> Argument-dependent lookup - cppreference.com</span>) 确保能找到在全局 namespace 或者与 T 同一个 namespace 中的 T 专用的 swap。（例如，如果 T 是 namespace WidgetStuff 中的 Widget，编译器会利用参数依赖查找（argument-dependent lookup）找到 WidgetStuff 中的 swap。）如果 T 专用 swap 不存在，编译器将使用 std 中的 swap，这归功于此函数中的 using declaration 使 std::swap 在此可见。尽管如此，相对于通用模板，编译器还是更喜欢 T 专用的 std::swap 的特化，所以如果 std::swap 对 T 进行了特化，则特化的版本会被使用。</mark></p>\n<p>本节总结：</p>\n<ul>\n<li>如果 std::swap 对于你的类型来说是低效的，请提供一个 swap 成员函数。并确保你的 swap 不会抛出异常。</li>\n<li>如果你提供一个成员 swap，请同时提供一个调用成员 swap 的非成员 swap。对于类（非模板），还要特化 std::swap。</li>\n<li>调用 swap 时，请为 std::swap 使用一个 using declaration，然后在调用 swap 时不使用任何 namespace 限定条件。</li>\n<li>为用户定义类型完全地特化 std 模板没有什么问题，但是绝不要试图往 std 中加入任何全新的东西。</li>\n</ul>\n<p>也许还遗留了一个问题，如本节标题所言：绝不要让 swap 的成员版本抛出异常，这是因为 swap 的非常重要的应用之一是为类（以及类模板）提供强大的异常安全（exception-safety）保证 (参见 item 29)。swap 的缺省版本基于拷贝构造和拷贝赋值，如果这两个函数仅涉及内建类型，那么一切 ok，因为可以默认对内建类型的操作绝不会抛出异常。否则的话，可能涉及用户类型的拷贝，而我们为了高效的交换，此时应当提供一个更高效的 swap 版本，使用指针类型的交换来避免缺省拷贝函数的这一缺点，这时又正好解决了可能抛出异常的问题。</p>\n<h2 id=\"编程实践\"><a class=\"anchor\" href=\"#编程实践\">#</a> 编程实践</h2>\n<h3 id=\"item26-只要有可能就推迟变量定义\"><a class=\"anchor\" href=\"#item26-只要有可能就推迟变量定义\">#</a> item26 只要有可能就推迟变量定义</h3>\n<p>优点：</p>\n<ul>\n<li>增加程序可读性</li>\n<li>避免变量的定义和真正使用离得太远，使得中间出现 return 或抛出异常等情况而导致变量白白构造和析构。</li>\n</ul>\n<h3 id=\"item27-将强制转型转到最少\"><a class=\"anchor\" href=\"#item27-将强制转型转到最少\">#</a> item27 将强制转型转到最少</h3>\n<p>如果强制转型使用太多，很可能代码的设计就有问题。</p>\n<ul>\n<li>避免强制转型的滥用，特别是在性能敏感的代码中应用 dynamic_casts，如果一个设计需要强制转型，设法开发一个没有强制转型的侯选方案。</li>\n<li>如果必须要强制转型，设法将它隐藏在一个函数中。客户可以用调用那个函数来代替在他们自己的代码中加入强制转型。</li>\n<li>尽量用 C++ 风格的强制转型 (四种 cast) 替换 C 风格的强制转型。它们更容易被注意到，而且他们做的事情也更加明确。</li>\n</ul>\n<h3 id=\"item28-避免返回对象内部构件的句柄引用指针或迭代器\"><a class=\"anchor\" href=\"#item28-避免返回对象内部构件的句柄引用指针或迭代器\">#</a> item28 避免返回对象内部构件的句柄（引用，指针，或迭代器）</h3>\n<p>由于编译器的二进制常量性 (item3)，将成员函数声明为 const 有时仍然会破坏封装性，比如返回内部私有成员的指针或引用等，如果不得不这样做，应该同时将成员函数的返回值设为 const。</p>\n<h3 id=\"item29-争取异常安全exception-safe的代码\"><a class=\"anchor\" href=\"#item29-争取异常安全exception-safe的代码\">#</a> item29  争取异常安全（exception-safe）的代码</h3>\n<p>根据作者的定义，一个异常安全函数抛出异常时，应当：</p>\n<ol>\n<li>没有资源泄露</li>\n<li>不允许数据结构恶化，即对相关的变量使用不应该发生未定义或错误的行为。</li>\n</ol>\n<p>for example:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token class-name\">PrettyMenu</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">changeBackground</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> imgSrc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                      <span class=\"token comment\">// acquire mutex (as in Item 14)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">delete</span> bgImage<span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// get rid of old background</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token operator\">++</span>imageChanges<span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// update image change count</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  bgImage <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token type-opencl-host-cpp keyword\">Image</span><span class=\"token punctuation\">(</span>imgSrc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// install new background</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// release mutex</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这是一个对一个菜单对象背景图片更换的函数，当 new 操作符抛出异常时，mutex 对象并没有被释放，并且 bgImage 指针指向一个被删除的对象，分别违反了第一条和第二条原则，因此这个函数不是异常安全的。</p>\n<p>达到第一条原则有一个十分简单且通用的方法，就是利用 C++ 的 RAII 机制 (item 13)：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token class-name\">PrettyMenu</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">changeBackground</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> imgSrc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  Lock <span class=\"token function\">ml</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 \t<span class=\"token comment\">// 异常抛出时会触发 Lock 类的析构</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">delete</span> bgImage<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token operator\">++</span>imageChanges<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  bgImage <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token type-opencl-host-cpp keyword\">Image</span><span class=\"token punctuation\">(</span>imgSrc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>接着处理数据结构恶化问题，作者认为，异常安全对这一问题需要提供以下三种不同级别的保证之一：</p>\n<ul>\n<li>函数提供基本保证（the basic guarantee），允诺如果一个异常被抛出，程序中剩下的每一件东西都处于合法状态。没有对象或数据结构被破坏，而且所有的对象都处于内部调和状态（所有的类不变量都被满足）。即：<strong>抛出异常后，程序的一部分状态可能被改变，但仍处于合法状态，不至于影响程序继续运行，或者程序员有办法捕捉这些改变并做出应对。</strong></li>\n<li>函数提供强力保证（the strong guarantee），即如果一个异常被抛出，程序的状态就像它们从没有被调用过一样。</li>\n<li>函数提供不抛出保证（the nothrow guarantee），允诺决不抛出异常，对内建类型的操作一般都是 nothrow 的，这是异常安全代码中必不可少的基础构件。</li>\n</ul>\n<p>** 对于 programmer 来说，他们提供的函数应当尽量达到最高级别的保证。** 一般来说，程序员提供的函数只要不包含内建类型，基本就只能提供强力保证了。</p>\n<p>接下来是一个提供强力保证的通用策略：copy-and-swap，这常常配合 pimpl 原则 (pointer to implementation) 使用，它的步骤一般是这样的：</p>\n<ol>\n<li>将每一个对象中的全部数据从 “真正的” 对象中放入到一个单独的实现对象中，然后将一个指向实现对象的指针交给真正对象。(pimpl)</li>\n<li>做出一个你要改变的对象的拷贝，然后在这个拷贝上做出全部所需的改变。如果改变过程中的某些操作抛出了异常，最初的对象保持不变。在所有的改变完全成功之后，将被改变的对象和最初的对象在一个<strong>不会抛出异常</strong>的操作中进行交换。(copy-and-swap)</li>\n</ol>\n<p>对于 PrettyMenu 的 changeBackground 函数来说，可以这样写：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token class-name\">PrettyMenu</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">changeBackground</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>istream<span class=\"token operator\">&amp;</span> imgSrc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">using</span> std<span class=\"token double-colon punctuation\">::</span>swap<span class=\"token punctuation\">;</span>                            <span class=\"token comment\">// see Item 25</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  Lock <span class=\"token function\">ml</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                            <span class=\"token comment\">// acquire the mutex</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>tr1<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>PMImpl<span class=\"token operator\">></span>                <span class=\"token comment\">//copy obj. data，PMImpl 是一个包含所有数据的工具类。</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">pNew</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">PMImpl</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pImpl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  pNew<span class=\"token operator\">-></span>bgImage<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token type-opencl-host-cpp keyword\">Image</span><span class=\"token punctuation\">(</span>imgSrc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// modify the copy</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token operator\">++</span>pNew<span class=\"token operator\">-></span>imageChanges<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>pImpl<span class=\"token punctuation\">,</span> pNew<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// swap the new</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                                              <span class=\"token comment\">// data into place</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"item30-理解-inline-化的介入和排除\"><a class=\"anchor\" href=\"#item30-理解-inline-化的介入和排除\">#</a> item30 理解 inline 化的介入和排除</h3>\n<ol>\n<li>正确理解 inline： inline 只是对于编译器的请求，最终函数是否 inline 取决于编译器。</li>\n<li>正确使用 inline：\n<ul>\n<li>正确评估 inline 的效果：inline 一般只适用于小的，频繁调用的函数上，这种函数编译后的机器指令最好小于一个函数调用产生的机器指令。一个较大的函数 inline 化会带来代码膨胀，导致附加的分页调度，减少指令缓存命中率，以及随之而来的性能损失。</li>\n<li>对于头文件中函数的 inline 慎重，因为 inline 函数展开的特性，与头文件与实现相分离的模式相比，使用 inline 函数的 clients 必须在 inline 函数更改后进行重新编译。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"item-31-最小化文件之间的编译依赖\"><a class=\"anchor\" href=\"#item-31-最小化文件之间的编译依赖\">#</a> item 31 最小化文件之间的编译依赖</h3>\n<p>为了尽量减小更改一个实现所引起的链式反应，需要掌握最小化编译依赖的精髓：只要能实现，就让你的头文件独立自主，如果不能，就依赖其它文件中的声明，而不是定义。其它每一件事都从这个简单的设计策略产生。所以：</p>\n<ol>\n<li>\n<p>当对象的引用和指针可以做到时就避免使用对象。仅需一个类型的声明，你就可以定义到这个类型的引用或指针。而定义一个类型的对象必须要存在这个类型的定义。因为指针和引用的大小是固定的，而对象的大小不固定，在编译时需要知道对象具体大小的场景时不适用。</p>\n</li>\n<li>\n<p>用对类声明的依赖替代对类定义的依赖。声明一个使用一个类的函数时绝对不需要有这个类的定义，即使这个函数通过传值方式传递或返回这个类</p>\n<p>比如</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">;</span>                        <span class=\"token comment\">// class declaration</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Date <span class=\"token function\">today</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                      <span class=\"token comment\">// fine — no definition</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">clearAppointments</span><span class=\"token punctuation\">(</span>Date d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// of Date is needed</span></pre></td></tr></table></figure></li>\n<li>\n<p>为声明和定义分别提供头文件。为了便于坚持上面的指导方针，头文件需要成对出现：一个用于声明，另一个用于定义。当然，这些文件必须保持一致。如果一个声明在一个地方被改变了，它必须在两处都被改变。得出的结果是：库的客户应该总是 #include 一个声明文件，而不是自己前向声明某些东西，而库的作者应该提供两个头文件。例如，想要声明 today 和 clearAppointments 的 Date 的客户不应该像前面展示的那样手动前向声明 Date。更合适的是，它应该 #include 适当的用于声明的头文件：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"datefwd.h\"</span>            <span class=\"token comment\">// header file declaring (but not</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>                               <span class=\"token comment\">// defining) class Date</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Date <span class=\"token function\">today</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// as before</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">clearAppointments</span><span class=\"token punctuation\">(</span>Date d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ol>\n<p>基于以上想法的两个方法是 Handle 类和 Interface 类，Handle 类和 Interface 类从实现中分离出接口。</p>\n<p>Handle 类采用 pimpl 思想，将所有的操作都交给内部指针指向的对象来做，缺点是可能需要提供更多的文件。</p>\n<p>Interface 类利用纯虚函数的思想，类似 Java Interface 的使用，需要提供方法来制作具体的实体类。</p>\n<h2 id=\"面向对象设计\"><a class=\"anchor\" href=\"#面向对象设计\">#</a> 面向对象设计</h2>\n<h3 id=\"item-32-确保-public-inheritance-模拟-is-a\"><a class=\"anchor\" href=\"#item-32-确保-public-inheritance-模拟-is-a\">#</a> item 32 确保 public inheritance 模拟 &quot;is-a&quot;</h3>\n<p>不同于 private 继承的一点是，public 继承体系中，子类将拥有父类提供的所有 public 接口。即 public inheritance 意味着 &quot;is-a&quot;。适用于 base classes 的每一件事也适用于 derived classes，因为每一个 derived class object 都是一个 base class object。</p>\n<p>其实这是设计模式六大原则中 “里氏替换原则” 的 C++ 实践，里氏替换原则指出：应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换。一个经典的反例是一个 public 继承自长方形类的正方形类，正方形类不能像长方形那样随意地改变长度与宽度，即 setLength () 和 setWidth () 接口在正方形类的使用中会出现麻烦，因此正方形类不应该 public 继承自长方形类。</p>\n<h3 id=\"item33-避免覆盖通过继承得到的名称\"><a class=\"anchor\" href=\"#item33-避免覆盖通过继承得到的名称\">#</a> item33  避免覆盖 “通过继承得到的名称”</h3>\n<p>在子类中，只要声明了一个与父类同名的函数，比如 <code>foo()</code> ，那么父类中所有的<strong>同名函数</strong>都会变得不可见，不管是 <code>foo()</code>  还是 <code>foo(int)</code>  还是 <code>foo() const</code> ,<strong> 作用域级别的遮盖是和参数类型以及是否虚函数无关的</strong>，这可能有些违反直觉，作者的解释是这是为了防止 programmer 在从某个库或者某个框架中创建一个派生类时，在不知情的情况下从遥远的某个 base classes 中继承了同名的其它函数 (over loads) 的情况。不幸的是，一般情况下 programmer 是需要继承这些 overloads 的。在这种情况下如何绕过 C++ 对 “通过继承得到的名字” 的缺省的覆盖机制呢。</p>\n<p>一种方法是使用 using declarations, 这将使父类的所有同名函数可见:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">using</span> Base<span class=\"token double-colon punctuation\">::</span>mf1<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// make all things in Base named mf1 and mf3</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">using</span> Base<span class=\"token double-colon punctuation\">::</span>mf3<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// visible (and public) in Derived's scope</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">mf1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">mf3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">mf4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>还有一种情况是，只想让 base classes 的某个同名函数可见（这是不应该发生在 public 继承中的，否则将违反 item32），这种时候应当使用一个简单的 forwarding function:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">mf1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\">// forwarding function; implicitly</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span> <span class=\"token class-name\">Base</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">mf1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>                     <span class=\"token comment\">// inline (see Item 30)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>Derived d<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>d<span class=\"token punctuation\">.</span><span class=\"token function\">mf1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                               <span class=\"token comment\">// fine, calls Derived::mf1</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>d<span class=\"token punctuation\">.</span><span class=\"token function\">mf1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                              <span class=\"token comment\">// error! Base::mf1() is hidden</span></pre></td></tr></table></figure><p>总结：</p>\n<ul>\n<li>derived classes 中的名字会覆盖 base classes 中的名字，在 public 继承中 中，这不应当发生。</li>\n<li>为了使隐藏的 name 重新可见，使用 using declarations 或者 forwarding functions（转调函数）。</li>\n</ul>\n<h3 id=\"item-34-区分-inheritance-of-interface接口继承和-inheritance-of-implementation实现继承\"><a class=\"anchor\" href=\"#item-34-区分-inheritance-of-interface接口继承和-inheritance-of-implementation实现继承\">#</a> item 34 区分 inheritance of interface（接口继承）和 inheritance of implementation（实现继承）</h3>\n<p>继承的情况可以分为三种：</p>\n<ol>\n<li>继承了一个纯虚函数（Pure virtual functions）</li>\n<li>继承了一个简单虚拟函数（Simple virtual functions)</li>\n<li>继承了一个非虚拟函数 （Non-virtual functions)</li>\n</ol>\n<p>什么时候该选哪种方式呢？作者提供了这三种继承方式的语义，以供选择的时候参考</p>\n<ol>\n<li>纯虚函数指定<strong>仅有接口被继承</strong></li>\n<li>简单虚拟函数指定 接口继承加上 <strong>缺省实现继承</strong></li>\n<li>非虚拟函数指定接口继承加上<strong>强制实现继承</strong>，参见 item32 对于非虚拟函数一般来说不能重写它。</li>\n</ol>\n<h3 id=\"item35-考虑可选的虚函数的替代方法\"><a class=\"anchor\" href=\"#item35-考虑可选的虚函数的替代方法\">#</a> item35 考虑可选的虚函数的替代方法</h3>\n<p>虚函数简单易懂又功能强大，无脑的使用虚函数可以解决大部分问题，但是在一些特殊场景中，以下几个方法可能会更好。</p>\n<ol>\n<li>\n<p>non-virtual interface (NVI) idiom（非虚拟接口惯用法），这个方法主张将虚函数声明为私有，然后通过非虚拟的 public 接口调用它。这个方法适合继承体系的各个方法包含相同的处理逻辑的时候，将不同的部分放在虚函数中，让虚函数专注于实现各个类不同的部分，然后在调用它的 public 接口中做一些通用的控制工作，for example：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">GameCharacter</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">int</span> <span class=\"token function\">healthValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>               <span class=\"token comment\">// derived classes do not redefine</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span>                                     <span class=\"token comment\">// this - see Item 36</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                 <span class=\"token comment\">// do \"before\" stuff - see below</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">int</span> retVal <span class=\"token operator\">=</span> <span class=\"token function\">doHealthValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// do the real work</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                 <span class=\"token comment\">// do \"after\" stuff - see below</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span> retVal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">int</span> <span class=\"token function\">doHealthValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>     <span class=\"token comment\">// derived classes may redefine this</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                 <span class=\"token comment\">// default algorithm for calculating</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                     <span class=\"token comment\">// character's health</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在调用虚拟的 doHeadthValue 方法之前和之后可以做一些处理。</p>\n</li>\n<li>\n<p>使用作为成员变量的函数指针，一个策略模式的简单实现。</p>\n</li>\n<li>\n<p>使用 std::function 对象，这样做的优点是 function 对象可以被多个不同类调用，更方便。</p>\n</li>\n</ol>\n<h3 id=\"item36-绝不要重定义一个-inherited-non-virtual-function通过继承得到的非虚拟函数\"><a class=\"anchor\" href=\"#item36-绝不要重定义一个-inherited-non-virtual-function通过继承得到的非虚拟函数\">#</a> item36 绝不要重定义一个 inherited non-virtual function（通过继承得到的非虚拟函数）</h3>\n<p>可以参照 item32 与里式替换法则，在能使用父类的地方一定能够使用子类，而不会破坏程序的行为。同时，如果你的函数有多态调用的需求，一定记得把它设为虚函数，否则基类指针指向子类对象的时候是不会调用到子类重载过的函数的，很可能会出错。</p>\n<h3 id=\"item37-绝不要重定义一个函数的-inherited-default-parameter-value通过继承得到的缺省参数值\"><a class=\"anchor\" href=\"#item37-绝不要重定义一个函数的-inherited-default-parameter-value通过继承得到的缺省参数值\">#</a> item37 绝不要重定义一个函数的 inherited default parameter value（通过继承得到的缺省参数值）</h3>\n<p>原因是缺省参数是静态绑定的，但是对于虚函数是动态绑定的，因此通过父类指针调用子类的虚函数的时候，会发生实现按照子类，但缺省参数按照父类的情况。同时同 item36，除了虚函数外，也希望子类的表现与父类相同。</p>\n<h3 id=\"item38-通过-composition模拟-has-a或-is-implemented-in-terms-of是根据实现的\"><a class=\"anchor\" href=\"#item38-通过-composition模拟-has-a或-is-implemented-in-terms-of是根据实现的\">#</a> item38 通过 composition 模拟 &quot;has-a&quot; 或 &quot;is-implemented-in-terms-of&quot;（是根据…… 实现的）</h3>\n<p>使用复合代替继承是一个经典的设计思想，能提高程序运行的性能。假设 A 类拥有一个 B 类的成员变量，语义是 A 类是根据 B 类实现的，这很容易理解。</p>\n<h3 id=\"item39-谨慎使用-private-inheritance私有继承\"><a class=\"anchor\" href=\"#item39-谨慎使用-private-inheritance私有继承\">#</a> item39 谨慎使用 private inheritance（私有继承）</h3>\n<p>我们知道，public 继承代表着 &quot;is a&quot; 关系，private 继承代表着 has a 或者说 &quot;是根据... 实现的&quot; 关系。因为 private 继承不会拥有与父类相同的接口，但是可以复用父类的所有接口与成员变量来对外提供新功能。</p>\n<p>但是根据 item38，复合也拥有与私有继承同样的语义，那么如何在这两者中进行选择呢？结论是这样的：== 只要你能就用 composition（复合），只有在绝对必要的时候才用 private inheritance（私有继承）。== 这里绝对必要的情况主要是当 protected members 和虚函数参与进来的时候。比如说，当你要处理的两个 classes（类）不具有 is-a（是一个）的关系，而且其中的一个还需要访问另一个的 protected members（保护成员）或需要重定义一个或更多个它的 虚函数。甚至在这种情况下，我们也看到 public inheritance 和 containment 的混合使用通常也能产生你想要的行为，虽然有更大的设计复杂度。</p>\n<p>两个原因：</p>\n<ol>\n<li>private 继承的子类如果还可能被新的类继承的时候，可能需要禁止当前类的虚函数被重载，作者使用了复杂的方法，但 C++ 11 后使用 final 关键字便可解决此问题，故此原因可忽略</li>\n<li>item31 提到的最小化编译依赖的问题，复合可以只需要对象的声明，而继承必须看到对象的定义。</li>\n</ol>\n<h3 id=\"item40-谨慎使用多继承\"><a class=\"anchor\" href=\"#item40-谨慎使用多继承\">#</a> item40 谨慎使用多继承</h3>\n<p>能避免使用多继承就避免使用多继承，目前还没有看到过必须使用多继承的例子，java 删除了多继承貌似也没什么问题。</p>\n<p>总结：</p>\n<ul>\n<li>多继承比 single inheritance 单继承更复杂。它能导致新的歧义问题（父类中拥有同名 members) 和对 virtual inheritance（虚继承）的需要。</li>\n<li>virtual inheritance（虚继承）增加了 size 和 speed 成本，以及 initialization（初始化）和 assignment（赋值）的复杂度。当 virtual base classes（虚拟基类）没有数据时它是最适用的。</li>\n<li>多继承有合理的用途。比如一种方案涉及组合从一个 Interface class（接口类）的公有继承和从一个有助于实现的 类的 私有继承。</li>\n</ul>\n<h2 id=\"模板\"><a class=\"anchor\" href=\"#模板\">#</a> 模板</h2>\n<p>这一章的内容值得反复阅读，行文环环相扣，实在是难以再浓缩了。</p>\n<h3 id=\"item41-理解-implicit-interfaces隐式接口和-compile-time-polymorphism编译期多态\"><a class=\"anchor\" href=\"#item41-理解-implicit-interfaces隐式接口和-compile-time-polymorphism编译期多态\">#</a> item41 理解 implicit interfaces（隐式接口）和 compile-time polymorphism（编译期多态）</h3>\n<p>类和模版的一个共同特点是它们都支持接口和多态，区别是类支持显式接口和运行时多态（通过虚函数实现），而模版支持隐式接口和编译期多态。</p>\n<p>运行时多态与编译器多态很好理解。显式接口的意思是，一个类提供了哪些接口，在它的类定义之中就能全部找到，所以是显式的。而对于模板来说，参数化的类需要提供的接口是基于合法表达式的，比如一个表达式 <code>if (templateClass.size() &gt; 10)</code> , 我们可以<strong>推测</strong>出这个参数化的类必须提供 templateClass 接口，所以说是隐式的。</p>\n<h3 id=\"item42-理解-typename-的两个含义\"><a class=\"anchor\" href=\"#item42-理解-typename-的两个含义\">#</a> item42 理解 typename 的两个含义</h3>\n<p>第一个含义，用于模版声明中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// uses \"class\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// uses \"typename\"</span></pre></td></tr></table></figure><p>这里的 <code>typename</code>  和 <code>class</code>  在语法层面上没有什么不同，都用在声明一个模板类型参数的时候。但是，在惯例上，一般会使用 <code>typename</code> ，表示类型 T 不仅可以是一个类类型，也可以是其它类型，仅当模板类型参数仅接受用户定义类型的时候使用 class。</p>\n<p>第二个含义，用 <code>typename</code>  去标识 nested dependent type names（嵌套依赖类型名）</p>\n<p>这里设计两个概念：<strong>嵌套</strong>和<strong>依赖</strong>，for example，这个代码还不能通过编译，只是举例：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">C</span><span class=\"token operator\">></span>                            <span class=\"token comment\">// print 2nd element in</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">print2nd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> C<span class=\"token operator\">&amp;</span> container<span class=\"token punctuation\">)</span>               <span class=\"token comment\">// container;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span>                                               <span class=\"token comment\">// this is not valid C++!</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     C<span class=\"token double-colon punctuation\">::</span>const_iterator <span class=\"token function\">iter</span><span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// get iterator to 1st element</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     <span class=\"token operator\">++</span>iter<span class=\"token punctuation\">;</span>                                    <span class=\"token comment\">// move iter to 2nd element</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>iter<span class=\"token punctuation\">;</span>                         <span class=\"token comment\">// copy that element to an int</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> value<span class=\"token punctuation\">;</span>                        <span class=\"token comment\">// print the int</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个函数中有两个局部变量， <code>iter</code>  和  <code>value</code> 。 <code>iter </code> 的类型是  <code>C::const_iterator</code> ，一个依赖于模板参数 C 的类型。一个 模板中的依赖于一个 模板参数的名字被称为 dependent names（依赖名字）。当一个 dependent names（依赖名字）嵌套在一个类的内部时，我称它为 nested dependent name（嵌套依赖名字）。C::const_iterator 是一个 nested dependent name（嵌套依赖名字）。实际上，它是一个 nested dependent type name（嵌套依赖类型名），也就是说，<strong>一个涉及到一个 type（类型）的 nested dependent name（嵌套依赖名字）</strong>。</p>\n<p>print2nd 中的另一个 局部变量 <code>value</code>  具有 int 类型。int 是一个不依赖于任何模板参数的名字。这样的名字被称为 non-dependent names（非依赖名字）。</p>\n<p>上面的这个代码错在 <code>C::const_iterator iter(container.begin());</code>  这一行，在这里，我们之所以觉得能够声明 <code>iter</code>  这个变量，是因为我们默认 C::const_iterator 是一个类型，也就是说 <code>iter</code>  的声明仅在 <code>C::const_iterator</code>  是一个类型时才有意义，但是在编译器看来这是不对的，编译器会认为 C::const_iterator 可能是 C 中的一个静态数据成员，因为编译器会考虑所有可能的输入，** 因此在 C 还不是已知的时候，它会假定嵌套依赖名字不是一个 type (类型)。** 因此为了声明 <code>iter</code>  变量，我们必须告诉编译器 <code> C::const_iterator</code>  是一个类型，我们将 <code>typename</code>  放在这个声明的前面来做到这一点。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">C</span><span class=\"token operator\">></span>                           <span class=\"token comment\">// this is valid C++</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">print2nd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> C<span class=\"token operator\">&amp;</span> container<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">typename</span> <span class=\"token class-name\">C</span><span class=\"token double-colon punctuation\">::</span>const_iterator <span class=\"token function\">iter</span><span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这就是 <code>typename</code>  的第二个含义， <code>typename </code> 前置于嵌套依赖类型名。但这一规则也有两个例外：</p>\n<p><code>typename </code> 不必前置于在一个 list of base classes（基类列表）中的或者在一个 member initialization list（成员初始化列表）中作为一个 base classes identifier（基类标识符）的 nested dependent type name（嵌套依赖类型名）。很拗口，但例子很简单：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Base</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Nested</span></span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 基类列表中 typename not</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span>                                 <span class=\"token comment\">// allowed</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">explicit</span> <span class=\"token function\">Derived</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token operator\">:</span> <span class=\"token class-name\">Base</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">Nested</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>                  <span class=\"token comment\">// 初始化列表中的基类标识符</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span>                                     <span class=\"token comment\">// : typename not allowed</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">typename</span> <span class=\"token class-name\">Base</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>Nested temp<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// use of nested dependent type</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                 <span class=\"token comment\">// name not in a base class list or</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                     <span class=\"token comment\">// as a base class identifier in a</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                   <span class=\"token comment\">// mem. init. list: typename required</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里还有一个知识点，涉及 <code>typedef</code>  与 <code>typename</code> ，同时还需要一点点模板元编程的知识。</p>\n<p>假设我们在写一个取得一个 iterator 的 函数模板，而且我们要做一个 iterator 指向的对象的局部拷贝 temp，我们可以这样做：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">workWithIterator</span><span class=\"token punctuation\">(</span>IterT iter<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">typename</span> <span class=\"token class-name\">std</span><span class=\"token double-colon punctuation\">::</span>iterator_traits<span class=\"token operator\">&lt;</span>IterT<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>value_type <span class=\"token function\">temp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>iter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里 <code>typename std::iterator_traits&lt;IterT&gt;::value_type</code>  实在太长了，因此可以使用这种语法简化它：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">workWithIterator</span><span class=\"token punctuation\">(</span>IterT iter<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">typedef</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">std</span><span class=\"token double-colon punctuation\">::</span>iterator_traits<span class=\"token operator\">&lt;</span>IterT<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>value_type value_type<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  value_type <span class=\"token function\">temp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>iter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>有点怪，但是这是合理的，可以很快的习惯这种语法，因为输一长串 typename + 类型太麻烦了</p>\n<h3 id=\"item-43了解如何访问-templatized-base-classes模板化基类中的名字\"><a class=\"anchor\" href=\"#item-43了解如何访问-templatized-base-classes模板化基类中的名字\">#</a> item 43 了解如何访问 templatized base classes（模板化基类）中的名字</h3>\n<p>在模板类的继承体系中，子类不能像 Object-oriented C++ 那样直接使用父类的方法，这是模板具有特化的特性引起的问题，即<strong>针对某个类型进行的特化，这个特化后的类与其他通过相同模板的类可能拥有不同的方法</strong>，因此 C++ 拒绝模版派生类对模版基类方法的直接使用，因此，程序员需要向编译器保证任何后继的 base class template（基类模板）的 specializations（特化）都将支持 general template（通用模板）提供的 interface（接口），如果保证被证实不成立，真相将在后继的编译过程中暴露，编译器会报错。</p>\n<p>保证的方法有：</p>\n<ul>\n<li>经由 &quot;this-&gt;&quot; 前缀</li>\n<li>经由 using declarations</li>\n<li>经由一个 explicit base class qualification（显式基类限定）引用 base class templates（基类模板）中的名字。</li>\n</ul>\n<p>比如想要使用基类模板的 <code>sendClear(...)</code>  函数，直接使用 <code>sendClear()</code>  不行，而下面这些语法才是正确的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">Company</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">LoggingMsgSender</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">MsgSender</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Company</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">sendClearMsg</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> MsgInfo<span class=\"token operator\">&amp;</span> info<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    write <span class=\"token string\">\"before sending\"</span> info to the log<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token operator\">-></span><span class=\"token function\">sendClear</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                <span class=\"token comment\">// okay, assumes that</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                                          <span class=\"token comment\">// sendClear will be inherited</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    write <span class=\"token string\">\"after sending\"</span> info to the log<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">Company</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">LoggingMsgSender</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">MsgSender</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Company</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">using</span> MsgSender<span class=\"token operator\">&lt;</span>Company<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>sendClear<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// tell compilers to assume</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                    <span class=\"token comment\">// that sendClear is in the</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                                         <span class=\"token comment\">// base class</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">sendClearMsg</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> MsgInfo<span class=\"token operator\">&amp;</span> info<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">sendClear</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                     <span class=\"token comment\">// okay, assumes that</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                  <span class=\"token comment\">// sendClear will be inherited</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">Company</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">LoggingMsgSender</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">MsgSender</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Company</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">sendClearMsg</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> MsgInfo<span class=\"token operator\">&amp;</span> info<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token class-name\">MsgSender</span><span class=\"token operator\">&lt;</span>Company<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">sendClear</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// okay, assumes that</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                       <span class=\"token comment\">// sendClear will be</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                           <span class=\"token comment\">// inherited</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"item44-从模板中分离出参数无关的代码\"><a class=\"anchor\" href=\"#item44-从模板中分离出参数无关的代码\">#</a> item44 从模板中分离出参数无关的代码</h3>\n<p>考虑以下求矩阵得 invert 的代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span>           <span class=\"token comment\">// template for n x n matrices of</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>         std<span class=\"token double-colon punctuation\">::</span>size_t n<span class=\"token operator\">></span>        <span class=\"token comment\">// objects of type T; see below for info</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">SquareMatrix</span> <span class=\"token punctuation\">&#123;</span>           <span class=\"token comment\">// on the size_t parameter</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token function\">invert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>               <span class=\"token comment\">// invert the matrix in place</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>SquareMatrix<span class=\"token operator\">&lt;</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token operator\">></span> sm1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>sm1<span class=\"token punctuation\">.</span><span class=\"token function\">invert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                  <span class=\"token comment\">// call SquareMatrix&lt;double, 5>::invert</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>SquareMatrix<span class=\"token operator\">&lt;</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token operator\">></span> sm2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>sm2<span class=\"token punctuation\">.</span><span class=\"token function\">invert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                  <span class=\"token comment\">// call SquareMatrix&lt;double, 10>::invert</span></pre></td></tr></table></figure><p>这里将有两个 invert 函数被实例化。这两个函数不是相同的，因为一个作用于 5 x 5 矩阵，而另一个作用于 10 x 10 矩阵，但是除了常数 5 和 10 以外，这两个函数是相同的。很明显，这里发生了代码膨胀。</p>\n<p>因此正确的做法是提供一个模板父类，派生自这个父类的所有具有相同 T 类型的 SquareMatrix 子类都共享同一个 invert 函数。</p>\n<h3 id=\"item45-用成员函数模板接受所有兼容类型\"><a class=\"anchor\" href=\"#item45-用成员函数模板接受所有兼容类型\">#</a> item45 用成员函数模板接受所有兼容类型</h3>\n<p>本原则的场景是：考虑一个 A 类型与 B 类型，其中 B 类型是 A 类型的派生类，那么一个 B 类型的对象或指针可以隐式的转换为 A 类型的指针或对象。但是，对于智能指针或类似功能的其他类，一个 share_ptr&lt;B&gt; 类型对象却无法隐式转换为 share_ptr&lt;A &gt; 类型，<strong>因为同一个模板的不同实例化之间没有继承关系</strong>，虽然这样的转换符合直觉并且大多数情况下很有用。因此在用户定义类型中模仿这样的转换是有意义的，并且需要一些技巧。</p>\n<p>正确的做法是使用一个模板构造函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">SmartPtr</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">U</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token function\">SmartPtr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> SmartPtr<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> other<span class=\"token punctuation\">)</span>         <span class=\"token comment\">// initialize this held ptr</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token operator\">:</span> <span class=\"token function\">heldPtr</span><span class=\"token punctuation\">(</span>other<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span>             <span class=\"token comment\">// with other's held ptr</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  T<span class=\"token operator\">*</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> heldPtr<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span>                                     <span class=\"token comment\">// built-in pointer held</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  T <span class=\"token operator\">*</span>heldPtr<span class=\"token punctuation\">;</span>                                <span class=\"token comment\">// by the SmartPtr</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>他接受任意类型的其他智能指针，并且仅当 U 类型能隐式转换为 T 类型的时候，代码能通过编译，这正是我们想要的。除此之外，赋值操作也应该达到这个效果，因此我们可以写出下面的代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">shared_ptr</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span>                                     <span class=\"token comment\">// construct from</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">explicit</span> <span class=\"token function\">shared_ptr</span><span class=\"token punctuation\">(</span>Y <span class=\"token operator\">*</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                         <span class=\"token comment\">// any compatible</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span>                                     <span class=\"token comment\">// built-in pointer,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">shared_ptr</span><span class=\"token punctuation\">(</span>shared_ptr<span class=\"token operator\">&lt;</span>Y<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// shared_ptr,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span>                                     <span class=\"token comment\">// weak_ptr, or</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">explicit</span> <span class=\"token function\">shared_ptr</span><span class=\"token punctuation\">(</span>weak_ptr<span class=\"token operator\">&lt;</span>Y<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// auto_ptr</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">explicit</span> <span class=\"token function\">shared_ptr</span><span class=\"token punctuation\">(</span>auto_ptr<span class=\"token operator\">&lt;</span>Y<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span>                                     <span class=\"token comment\">// assign from</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    shared_ptr<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>shared_ptr<span class=\"token operator\">&lt;</span>Y<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// any compatible</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span>                                     <span class=\"token comment\">// shared_ptr or</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    shared_ptr<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>auto_ptr<span class=\"token operator\">&lt;</span>Y<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// auto_ptr</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>需要注意的是，成员模板并不改变语言规则，而且规则规定一个拷贝构造函数时必需的而我们没有提供，编译器会自动生成一个，所以<strong>一个模板构造函数不会阻止编译器生成非模板的构造函数</strong>。因此为了全面支配拷贝构造，我们必须既声明一个模板拷贝构造函数，又声明一个常规的，非模板的拷贝构造函数，这同样适用于赋值，正确的实践应当像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">shared_ptr</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token function\">shared_ptr</span><span class=\"token punctuation\">(</span>shared_ptr <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// copy constructor</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span>                                <span class=\"token comment\">// generalized</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">shared_ptr</span><span class=\"token punctuation\">(</span>shared_ptr<span class=\"token operator\">&lt;</span>Y<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">// copy constructor</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  shared_ptr<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>shared_ptr <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// copy assignment</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Y</span><span class=\"token operator\">></span>                                <span class=\"token comment\">// generalized</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    shared_ptr<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>shared_ptr<span class=\"token operator\">&lt;</span>Y<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// copy assignment</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"item46-需要类型转换时在模板内定义非成员函数\"><a class=\"anchor\" href=\"#item46-需要类型转换时在模板内定义非成员函数\">#</a> item46 需要类型转换时在模板内定义非成员函数</h3>\n<p>此节针对 item24 中的示例增加了扩展讨论 (模板化 Rational 和 operator*)。item 24 的结论告诉我们，非成员函数适合应用到所有参数都需要进行隐式类型转换的场景之中。因此在模板中也使用相同的方法是很自然的:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Rational</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token function\">Rational</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> T<span class=\"token operator\">&amp;</span> numerator <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>     <span class=\"token comment\">// see Item 20 for why params</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>           <span class=\"token keyword\">const</span> T<span class=\"token operator\">&amp;</span> denominator <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// are now passed by reference</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">const</span> T <span class=\"token function\">numerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// see Item 28 for why return</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">const</span> T <span class=\"token function\">denominator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// values are still passed by value,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                  <span class=\"token comment\">// Item 3 for why they're const</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                            <span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>正如 item24 中提到的，我们想要支持 mixed-mode arithmetic（混合模式运算），所以我们要让下面这些代码能够编译：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Rational<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">oneHalf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// this example is from Item 24,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>                                      <span class=\"token comment\">// except Rational is now a template</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Rational<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> result <span class=\"token operator\">=</span> oneHalf <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// error! won't compile</span></pre></td></tr></table></figure><p>编译失败的原因是：<mark>模板实参推导的过程中，从不考虑隐式类型转换</mark>因此面对一个 Rational&lt;int&gt; 类型的参数 <code>oneHalf</code>  和 int 类型的参数 <code>2</code> , 编译器不会将 <code>2</code>  隐式转换为 Rational&lt;int&gt; 类型，也就导致了 operator * 模板推导失败，编译器找不到能用的实现。</p>\n<p>也就是说，如果我们有了一个实例化的函数，对它的调用过程中参数可以发生隐式类型转换，但既然模板推导过程失败了，我们也就没有了实例化的函数，这就是编译失败的原因。</p>\n<p>这里用到的解决方案是让 class Rational&lt;T&gt; 为 Rational&lt;T&gt; 声明作为一个友元函数的 operator*。<strong>class 类模板不依靠 模板实参推演（这个过程仅适用于 function templates（函数模板）），所以 T 在 class Rational&lt;T&gt; 被实例化时总是已知的：</strong></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Rational</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">friend</span>                                              <span class=\"token comment\">// declare operator*</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">const</span> Rational <span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span>     <span class=\"token comment\">// function (see</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                           <span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// below for details)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>                                <span class=\"token comment\">// define operator*</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span> <span class=\"token comment\">// functions</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                            <span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在对 operator * 的混合模式调用可以编译了，因为当 object oneHalf 被声明为 Rational&lt;int&gt; 类型时，class Rational&lt;int&gt; 被实例化，而作为这一过程的一部分，取得 Rational&lt;int &gt; 参数的友元函数 operator* 被自动声明。作为已声明 函数（并非一个 函数模板），在调用它的时候编译器可以使用隐式转换函（譬如 Rational 的非显式构造函数），而这就是它们如何使得混合模式调用成功的。</p>\n<p>by the way，有一个小知识点是：在一个 类模板内部，模板的名字可以被用做 模板和它的参数的缩写，所以，在 Rational&lt;T&gt; 内部，我们可以只写 Rational 代替 Rational&lt;T&gt;。</p>\n<p>但是，上面的代码虽然能够编译，但是还不能链接，因为 operator* 还没有提供实现。我们打算让 class 之外的 operator* 模板提供这个定义，但是这种方法不能工作 (why)。让它能工作的最简单的方法或许就是将 operator* 的本体合并到它的 定义中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Rational</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">friend</span> <span class=\"token keyword\">const</span> Rational <span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Rational<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">return</span> <span class=\"token function\">Rational</span><span class=\"token punctuation\">(</span>lhs<span class=\"token punctuation\">.</span><span class=\"token function\">numerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">numerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>       <span class=\"token comment\">// same impl</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                  lhs<span class=\"token punctuation\">.</span><span class=\"token function\">denominator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">denominator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// as in</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span>                                                          <span class=\"token comment\">// Item 24</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"item47-为类型信息使用-traits-classes特征类\"><a class=\"anchor\" href=\"#item47-为类型信息使用-traits-classes特征类\">#</a> item47 为类型信息使用 traits classes（特征类）</h3>\n<p>当我们的函数想为某些特定类型提供更高效的实现，并且不想在运行期花费额外开销进行类型判断的时候，本节的技巧十分有用。本节的一些做法在 C++ 11 后有了更简洁的做法，不过了解一下还是很有必要的，替代方法在节末也有涉及。</p>\n<p>以 STL 提供的 advance 函数为例，advance 将一个指定的 iterator 移动一个指定的距离：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span>       <span class=\"token comment\">// move iter d units</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">advance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">// forward; if d &lt; 0,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                                               <span class=\"token comment\">// move iter backward</span></pre></td></tr></table></figure><p>在概念上，advance 仅仅是在做 <code>iter += d</code> , 但是这样实现是错误的，因为只有随机访问迭代器支持 <code>+=</code>  操作。其它迭代器不得不反复利用 <code>++</code>  或 <code>--</code>  d 次来实现 advance。</p>\n<p>STL 的 iterator 不同种类的简单回顾：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>特点</th>\n<th>代表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>input iterators (输入迭代器)</td>\n<td>只能向前移动，每次移动一步，只读</td>\n<td>输入文件的读指针</td>\n</tr>\n<tr>\n<td>output iterators (输出迭代器)</td>\n<td>只能向前移动，每次移动一步，只写</td>\n<td>输出文件的写指针</td>\n</tr>\n<tr>\n<td>forward iterators (前向迭代器)</td>\n<td>只能向前移动，每次移动一步</td>\n<td>单向链表容器的迭代器</td>\n</tr>\n<tr>\n<td>bidirectional iterators (双向迭代器)</td>\n<td>加上了和前向迭代器一样的向后移动能力</td>\n<td>set,map 的迭代器</td>\n</tr>\n<tr>\n<td>random access iterators (随机访问迭代器)</td>\n<td>可以在常量时间里向前或向后跳转任意距离</td>\n<td>vector,string 的迭代器</td>\n</tr>\n</tbody>\n</table>\n<p>对于五种迭代器种类，C++ 都有一个用于识别它的 &quot;tag struct&quot; 结构体在标准库中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">input_iterator_tag</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">output_iterator_tag</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">forward_iterator_tag</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">input_iterator_tag</span></span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">bidirectional_iterator_tag</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">forward_iterator_tag</span></span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">random_access_iterator_tag</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">bidirectional_iterator_tag</span></span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这些结构体之间的继承关系体现了 &quot;is a&quot; 关系</p>\n<p>返回到 advance，对于不同的 iterator, 实现 advance 的一个方法是使用反复增加或减少 iterator 的循环，这个方法时间复杂度是 O (n)，但是随机访问迭代器支持常量时间的移动，所以当它出现的时候我们最好能利用这种能力。我们真正想做的大致可以这样描述：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">advance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>iter is a random access iterator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     iter <span class=\"token operator\">+=</span> d<span class=\"token punctuation\">;</span>                                      <span class=\"token comment\">// use iterator arithmetic</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                                  <span class=\"token comment\">// for random access iters</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>d<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>iter<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>              <span class=\"token comment\">// use iterative calls to</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>d<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span>iter<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>                     <span class=\"token comment\">// ++ or -- for other</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                                  <span class=\"token comment\">// iterator categories</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>** 现在的关键是，我们如何得到关于一个类型的某些信息。这就是 traits 能做到的：它们允许你在编译过程中得到过于一个类型的信息。**traits 不是 C++ 中的一个关键字或预定义结构；它们是一项技术和 C++ 程序员遵守的惯例。建立这项技术的要求之一是它在 内建类型上必须和在 user-defined types（用户定义类型）上一样有效，因此将信息嵌入到类型内部是不可以的，因为无法将信息嵌入一个指针内部。那么，一个类型的 traits 信息，必须在类型外部。标准的方法是将它放到 模以及这个模板的一个或更多的特化中。对于 iterators，标准库中模板被称为 iterator_traits：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token operator\">></span>          <span class=\"token comment\">// template for information about</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">iterator_traits</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// iterator types</span></pre></td></tr></table></figure><p>iterator_traits 的工作方法是对于每一个 IterT 类型，在 结构体 iterator_traits&lt;IterT&gt; 中声明一个名为 iterator_category 的 typedef。这个 typedef 被看成是 IterT 的 iterator category（迭代器种类）。</p>\n<p>iterator_traits 通过两部分实现这一点。首先，它强制要求任何 user-defined iterator（用户定义迭代器）类型必须包含一个名为 iterator_category 的嵌套 typedef 用以识别适合的 tag struct（标签结构体）。例如，deque 的 iterators（迭代器）是随机访问的，所以一个 deque iterators 的 class 看起来就像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token operator\">></span>                    <span class=\"token comment\">// template params elided</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">deque</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">class</span> <span class=\"token class-name\">iterator</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">typedef</span> random_access_iterator_tag iterator_category<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>对于一个 list (双向链表)，则是这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">list</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">class</span> <span class=\"token class-name\">iterator</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">typedef</span> bidirectional_iterator_tag iterator_category<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>而 iterator_traits 仅仅是简单地模仿了 iterator class 的嵌套 typedef：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// the iterator_category for type IterT is whatever IterT says it is;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// see Item 42 for info on the use of \"typedef typename\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">iterator_traits</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">typedef</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token double-colon punctuation\">::</span>iterator_category iterator_category<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>同时为了支持指针这样无法带有嵌套 typedef 的东西，iterator_traites 为其提供了一个部分模板特化：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token operator\">></span>               <span class=\"token comment\">// partial template specialization</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">iterator_traits</span><span class=\"token operator\">&lt;</span>IterT<span class=\"token operator\">*</span><span class=\"token operator\">></span>         <span class=\"token comment\">// for built-in pointer types</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">typedef</span> random_access_iterator_tag iterator_category<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>到此为止，可以总结出如何设计和实现一个 traits class：</p>\n<ul>\n<li>识别你想让它可用的关于类型的一些信息（例如，对于 iterators（迭代器）来说，就是它们的 iterator category（迭代器种类））。</li>\n<li>选择一个名字标识这个信息（例如，iterator_category）。</li>\n<li>提供一个模板和一系列特化（例如，iterator_traits），它们包含你要支持的类型的信息。</li>\n</ul>\n<p>有了 iterator_traits，就可以改善 advance 的伪代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">advance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeid</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">std</span><span class=\"token double-colon punctuation\">::</span>iterator_traits<span class=\"token operator\">&lt;</span>IterT<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>iterator_category<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     <span class=\"token keyword\">typeid</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>random_access_iterator_tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">// 这个代码可能涉及编译问题 见原书 item48</span></pre></td></tr></table></figure><p>现在的问题是：IterT 的类型在编译期间是已知的，所以 iterator_traits&lt;IterT&gt;::iterator_category 可以在编译期间被确定。但是 if 语句还是要到运行时才能被求值。为什么要到运行时才做我们在编译期间就能做的事情呢？它浪费了时间。</p>\n<p>解决方法是，重载，重载的最佳匹配是编译期间完成的，这个行为也有点像 if 语句选择分支的过程。为了让 advance 拥有我们想要的行为方式，我们必须要做的全部就是创建一个包含 advance 的 “内容” 的重载函数的多个版本：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span>              <span class=\"token comment\">// use this impl for</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">doAdvance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">,</span>                  <span class=\"token comment\">// random access</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>               std<span class=\"token double-colon punctuation\">::</span>random_access_iterator_tag<span class=\"token punctuation\">)</span>       <span class=\"token comment\">// iterators</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  iter <span class=\"token operator\">+=</span> d<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span>              <span class=\"token comment\">// use this impl for</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">doAdvance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">,</span>                  <span class=\"token comment\">// bidirectional</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>               std<span class=\"token double-colon punctuation\">::</span>bidirectional_iterator_tag<span class=\"token punctuation\">)</span>       <span class=\"token comment\">// iterators</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>d<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>iter<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>d<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span>iter<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span>              <span class=\"token comment\">// use this impl for</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">doAdvance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">,</span>                  <span class=\"token comment\">// input iterators</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>               std<span class=\"token double-colon punctuation\">::</span>input_iterator_tag<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>     <span class=\"token keyword\">throw</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">out_of_range</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Negative distance\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// see below</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>d<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>iter<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>给出针对 doAdvance 的各种重载，advance 需要做的全部就是调用它们，传递一个适当的 iterator category 类型的额外 object 以便编译器利用重载匹配正确的实现：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">advance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token function\">doAdvance</span><span class=\"token punctuation\">(</span>                                              <span class=\"token comment\">// call the version</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    iter<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span>                                              <span class=\"token comment\">// of doAdvance</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">typename</span>                                              <span class=\"token comment\">// that is</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      std<span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">iterator_traits</span><span class=\"token operator\">&lt;</span>IterT<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">iterator_category</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">// appropriate for</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                                      <span class=\"token comment\">// iter's iterator</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>ps: C++17 后提供的 constexpr if 和 &lt;type_traits&gt; 库是重载的一个替代方法，可以使上述代码更简单易读：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;type_traits></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">IterT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">DistT</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">advance</span><span class=\"token punctuation\">(</span>IterT<span class=\"token operator\">&amp;</span> iter<span class=\"token punctuation\">,</span> DistT d<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">constexpr</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>is_same_v<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">std</span><span class=\"token double-colon punctuation\">::</span>iterator_traits<span class=\"token operator\">&lt;</span>IterT<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>iterator_category<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>random_access_iterator_tag<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token function\">doAdvance</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>random_access_iterator_tag<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">constexpr</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>is_same_v<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">std</span><span class=\"token double-colon punctuation\">::</span>iterator_traits<span class=\"token operator\">&lt;</span>IterT<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>iterator_category<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>bidirectional_iterator_tag<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">doAdvance</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>bidirectional_iterator_tag<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">doAdvance</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>input_iterator_tag<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"item48-感受模板元编程tmp\"><a class=\"anchor\" href=\"#item48-感受模板元编程tmp\">#</a> item48 感受模板元编程 (TMP)</h3>\n<p>本节提供的例子是 TMP 界的 &quot;hello world&quot; 程序：用模板元编程计算阶乘：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">unsigned</span> n<span class=\"token operator\">></span>                 <span class=\"token comment\">// general case: the value of</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Factorial</span> <span class=\"token punctuation\">&#123;</span>                   <span class=\"token comment\">// Factorial&lt;n> is n times the value</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                                     <span class=\"token comment\">// of Factorial&lt;n-1></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">&#123;</span> value <span class=\"token operator\">=</span> n <span class=\"token operator\">*</span> Factorial<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>value <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>                           <span class=\"token comment\">// special case: the value of</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Factorial</span><span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token operator\">></span> <span class=\"token punctuation\">&#123;</span>                <span class=\"token comment\">// Factorial&lt;0> is 1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">&#123;</span> value <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后可以这样使用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> Factorial<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>value<span class=\"token punctuation\">;</span>            <span class=\"token comment\">// prints 120</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> Factorial<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>value<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// prints 3628800</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>很基础，但是能体现 TMP 的最大优势：将运行期的计算放到编译器计算，但是可能还不足够显示模板元编程的巨大威力。模板元编程是一门图灵完备的语言，它能做到很多事，它带来的效率提升令人惊叹...</p>\n<p>C++11 后，模板元编程正式获得了标准库支持，遗憾的是本书完成之前还没有引入，模板元编程现在有了许多通用的范式和惯例，当需要的时候，可以深入去了解它们。</p>\n<p>C++11 的 &lt;type_traits&gt; 库提供了一些非常有用的模板元编程支持，包括 (gpt 生成）：</p>\n<ol>\n<li><strong>型别特征 (Type Traits)</strong>:\n<ul>\n<li><code>std::is_same&lt;T, U&gt;</code> : 检查两个类型是否相同。</li>\n<li><code>std::is_integral&lt;T&gt;</code> : 检查类型是否为整型。</li>\n<li><code>std::is_floating_point&lt;T&gt;</code> : 检查类型是否为浮点型。</li>\n<li><code>std::is_pointer&lt;T&gt;</code> : 检查类型是否为指针。</li>\n<li>还有很多其他有用的型别特征，如  <code>is_array</code> 、 <code>is_class</code> 、 <code>is_enum</code>  等。</li>\n</ul>\n</li>\n<li><strong>类型转换</strong>:\n<ul>\n<li><code>std::conditional&lt;B, T, F&gt;</code> : 根据布尔值  <code>B</code>  选择类型  <code>T</code>  或  <code>F</code> 。</li>\n<li><code>std::enable_if&lt;B, T&gt;</code> : 根据布尔值  <code>B</code>  启用或禁用类型  <code>T</code> 。</li>\n<li><code>std::decay&lt;T&gt;</code> : 获取类型  <code>T</code>  的 &quot;衰减&quot;(decay) 形式。</li>\n</ul>\n</li>\n<li><strong>数值计算</strong>:\n<ul>\n<li><code>std::integral_constant&lt;T, v&gt;</code> : 表示一个编译时常量值。</li>\n<li><code>std::tuple&lt;Types...&gt;</code> : 异构容器，可用于编译时计算。</li>\n<li><code>std::pair&lt;T, U&gt;</code> : 二元组，可用于编译时计算。</li>\n</ul>\n</li>\n<li><strong>函数操作</strong>:\n<ul>\n<li><code>std::invoke&lt;F, Args...&gt;</code> : 调用可调用对象  <code>F</code>  并传递参数  <code>Args</code> 。</li>\n<li><code>std::result_of&lt;F(Args...)&gt;</code> : 获取调用  <code>F(Args...)</code>  的结果类型。</li>\n</ul>\n</li>\n<li><strong>算法</strong>:\n<ul>\n<li><code>std::make_index_sequence&lt;N&gt;</code> : 生成一个包含  <code>0</code>  到  <code>N-1</code>  的整数序列。</li>\n<li><code>std::index_sequence_for&lt;T1, T2, ..., TN&gt;</code> : 根据给定类型生成整数序列。</li>\n</ul>\n</li>\n</ol>\n<p>从这些函数的作用可见 TMP 的强大效用，足以在需要的时候担当重任。</p>\n<h2 id=\"内存管理\"><a class=\"anchor\" href=\"#内存管理\">#</a> 内存管理</h2>\n<h3 id=\"item49-了解-new-handler的行为\"><a class=\"anchor\" href=\"#item49-了解-new-handler的行为\">#</a> item49 了解 new-handler 的行为</h3>\n<p>对是否处理内存分配失败这件事有争议，一种说法是直接让程序 crash 即可，毕竟内存不足已经是十分严重的系统问题，并且对于内存分配失败程序员大多数时候总是无能为力。但是，任何技术都有适合的场景，并且本节涉及的一些技巧还是十分精妙，有助于学习。</p>\n<p>这一节主要介绍了对 new 行为分配内存失败的一种处理方案：new-handler，程序员可以使用 &lt;new&gt; 标准库中的 set_new_handler 函数设置一个 new-handler，在内存分配失败时会调用设置的 new-handler，具体来说它们的声明是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">namespace</span> std <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>new_handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//new_handler 是一个函数指针类型</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tnew_handler <span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>new_handler p<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 设置 global new_handler 为 p，并返回旧的 new_handler</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>一个使用的例子是:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">outOfMem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tstd<span class=\"token double-colon punctuation\">::</span>cerr <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"Unable to satisfy request for memory\\n\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">abort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>outOfMem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span> pBigDataArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">1000000000L</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当 operator new 无法满足内存申请时，它会不断调用 new-handler，直到找到足够内存 (见 item 51)，从这个描述可以总结出<strong>一个好的 new-handler 必须做以下事情之一</strong>：</p>\n<ul>\n<li>让更多内存被使用</li>\n<li>安装另一个 new-handler（让有能力的人来)</li>\n<li>卸载 new-handler（将 new-handler 设置为 null，没有安装任何 new-handler 时，operator new 会在内存分配失败时抛出异常</li>\n<li>抛出 bad_alloc 异常</li>\n<li>不返回，调用 abort 或 exit</li>\n</ul>\n<p>很多时候我们希望以不同的方式处理内存分配失败情况，特别是希望视分配物属于哪个 class 而定，我们想要达到这样的效果：</p>\n<pre><code class=\"language-c++\">class X &#123;\npublic:\n\tstatic void outOfMemory();\n\t...\n&#125;\nclass Y &#123;\npublic:\n\tstatic void outOfMemory();\n&#125;\nX *p1 = new X; //失败时调用X::outOfMemory\nY *p2 = new Y; //失败时调用Y::outOfMemory\n</code></pre>\n<p>遗憾的是 C++ 不支持为类提供专属的 new-handlers, 我们不得不自己实现这种行为。只需每个 class 提供自己的 set_new_handler 和 operator new 即可，<strong>其中 set_new_handler 使客户得以指定 class 专属的 new-handler, 而 operator new 则确保在分配 class  对象内存的过程中用类专属的 new-handler 替换 global new-handler。</strong></p>\n<p>假设我们现在想为 Widget 类提供一个专属 new-handler</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">static</span> std<span class=\"token double-colon punctuation\">::</span>new_handler set_new<span class=\"token operator\">-</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>new_handler p<span class=\"token punctuation\">)</span><span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span><span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">static</span> std<span class=\"token double-colon punctuation\">::</span>new_handler currentHandler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>new_handler Widget<span class=\"token double-colon punctuation\">::</span>currentHandler <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>new_handler <span class=\"token class-name\">Widget</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>new_handler p<span class=\"token punctuation\">)</span><span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 和标准版没什么区别</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    std<span class=\"token double-colon punctuation\">::</span>new_handler oldHandler <span class=\"token operator\">=</span> currentHandler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    currentHandler <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span> oldHandler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>最重要的是 Widget 重载的 opertor new, 它需要做到以下事情:</p>\n<ol>\n<li>调用标准 set_new_handler, 将 Widget 的 new-handler 安装为 global new-handler</li>\n<li>调用 global operator new 执行实际的内存分配，如果分配失败，会调用 widget 的 new-handler，如果最终仍无法分配，会抛出 bad_alloc 异常，并且必须恢复原本的 global new-handler。为了确保原来的 new-handler 总是能够被重新安装回去，将用到 RAII 机制</li>\n<li>如果 global operator new 成功分配，Widget 的 operator new 会返回一个指向分配的内存的指针，并且要自动恢复调用前的 global new-handler。</li>\n</ol>\n<p>代码，运用到了 RAII 机制：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">NewHandlerHolder</span> <span class=\"token punctuation\">&#123;</span>\t<span class=\"token comment\">//\t资源管理类</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">explicit</span> <span class=\"token function\">NewHandlerHolder</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>new_handler nh<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>nh<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token operator\">~</span><span class=\"token function\">NewHandlerHolder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\t<span class=\"token comment\">// 析构时恢复 global new_handler</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">NewHandlerHolder</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> NewHandlerHolder <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 禁止拷贝和赋值</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    NewHandlerHolder<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> NewHandlerHolder <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tstd<span class=\"token double-colon punctuation\">::</span>new_handler handler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// Widget 的 operator new 也很简单</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span><span class=\"token operator\">*</span> Widget<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    NewHandlerHolder <span class=\"token function\">h</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>currentHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 成功返回或抛出异常时会自动恢复之前的 new-handler</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在 Widget 的客户可以这样方便地为其指定 new-handler:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">outOfMem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">Widget</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>outOfMem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Widget<span class=\"token operator\">*</span> pw1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Widget<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 失败是调用 outOfMem</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token operator\">*</span> ps <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 失败时调用 global new-handler</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token class-name\">Widget</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Widget<span class=\"token operator\">*</span> pw2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Widget<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 失败时抛出异常</span></pre></td></tr></table></figure><p>实现这一方案的代码并不因 class 的不同而不同，因此考虑如何加上复用是一个自然的想法，一个简单的做法是提供一个 base class 来允许派生类继承这一能力。由于每个类都需要获得一个不同的静态 currentHandler 对象，需要用到模板。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">NewHandlerSupport</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token keyword\">static</span> std<span class=\"token double-colon punctuation\">::</span>new_handler set_new<span class=\"token operator\">-</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>new_handler p<span class=\"token punctuation\">)</span><span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span><span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">;</span><span class=\"token operator\">:</span>size_t size<span class=\"token punctuation\">)</span><span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">static</span> std<span class=\"token double-colon punctuation\">::</span>new_handler currentHandler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>new_handler</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token class-name\">NewHandlerSupport</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>new_handler p<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\tstd<span class=\"token double-colon punctuation\">::</span>new_handler oldHandler <span class=\"token operator\">=</span> currentHandler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\tcurrentHandler <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token keyword\">return</span> oldHandler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>templace<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">void</span><span class=\"token operator\">*</span> NewHandlerSupport<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\tNewHandlerHolder <span class=\"token function\">h</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>currentHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>std<span class=\"token double-colon punctuation\">::</span>new_handler NewHandlerSupport<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>currentHandler <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">// 现在 widget 类只需要</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">NewHandlerSupport</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Widget</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"item50-领会何时替换new和delete才有意义\"><a class=\"anchor\" href=\"#item50-领会何时替换new和delete才有意义\">#</a> item50 领会何时替换 new 和 delete 才有意义</h3>\n<p>在以下情况可以替换缺省的 new 和 delete：</p>\n<ul>\n<li>为了检测运用错误</li>\n<li>为了收集动态分配内存的使用统计信息</li>\n<li>为了增加分配和归还的速度</li>\n<li>为了降低缺省内存管理器带来的额外空间开销</li>\n<li>为了弥补缺省分配器中的非最佳齐位 (比如 x86 架构对 8 byte 齐位的 double 类型最快，所以重载 opertor new 让分配地址都是 8 byte 齐位)</li>\n<li>为了将相关对象集中</li>\n<li>为了获得非传统的行为</li>\n</ul>\n<p><strong>内存分配很困难，坑也很多，如需要重写最好还是引入或者参考开源库。</strong></p>\n<h3 id=\"item51-编写-new-和-delete-时要遵守惯例\"><a class=\"anchor\" href=\"#item51-编写-new-和-delete-时要遵守惯例\">#</a> item51 编写 new 和 delete 时要遵守惯例</h3>\n<p>首先看看 operator new 大概做了什么：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>                                      <span class=\"token comment\">// your operator new might</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// take additional params</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>                     <span class=\"token comment\">// handle 0-byte requests</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    size <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// by treating them as</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>                                    <span class=\"token comment\">// 1-byte requests</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   _attempt to allocate size bytes<span class=\"token punctuation\">;</span>_</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_the allocation was successful_<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>       <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>_a pointer to the memory_<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// allocation was unsuccessful; find out what the</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// current new-handling function is (see below)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    new_handler globalHandler <span class=\"token operator\">=</span> <span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">set_new_handler</span><span class=\"token punctuation\">(</span>globalHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>globalHandler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>globalHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">else</span> <span class=\"token keyword\">throw</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">bad_alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>它处理了零字节（C++ 要求即使请求零字节，operator new 也要返回一个合理的指针），也包含了一个无限循环，跳出循环的唯一出路是内存被成功分配或 new-handling function 做了 item49 中描述的事情之一：使得更多的内存可用，安装一个不同的 new-handler，卸载 new-handler，抛出一个 bad_alloc，或不再返回。我们自己重写的 operator new 也需要遵循这些规则。</p>\n<p>有一个容易被忽略的点是 operator new 成员函数会被派生类继承，对于 Class X 来说 它的 operator new 成员函数的 size 一般是与 sizeof (X) 适配的，绝不会更大或者更小。然而，由于继承，就有可能一个基类中的 operator new 被调用来为一个派生类分配内存。如果基类 的 operator new 不是被设计成应付这种情况的（很有可能是基类专属的操作）。它处理这种局面的最佳方法就是把这个请求调用甩给 standard operator new:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> Base<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">!=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>              <span class=\"token comment\">// if size is \"wrong,\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token keyword\">return</span> <span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// have standard operator</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                                          <span class=\"token comment\">// new handle the request</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>                                     <span class=\"token comment\">// otherwise handle</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                                          <span class=\"token comment\">// the request here</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>对于 operator delete，事情就更简单了，唯一需要注意的就是 C++ 保证删除空指针总是安全的，所以你需要遵循这个保证。下面是一个 standard operator delete 的伪代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>rawMemory<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rawMemory <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">// do nothing if the null</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                                         <span class=\"token comment\">// pointer is being deleted</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  _deallocate the memory pointed to by rawMemory<span class=\"token punctuation\">;</span>_</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>类似地，对于错误大小的 delete 请求，也可以委托给 stardard operator delete 来做。</p>\n<h3 id=\"item52-如果编写了-placement-new就要编写-placement-delete\"><a class=\"anchor\" href=\"#item52-如果编写了-placement-new就要编写-placement-delete\">#</a> item52 如果编写了 placement new，就要编写 placement delete</h3>\n<p>两个要点：</p>\n<ul>\n<li>\n<p><strong>在编写一个 operator new 的 placement 版本时，确保同时编写 operator delete 的相应的 placement 版本。否则，你的程序可能会发生微妙的，断续的 memory leaks 内存泄漏。</strong></p>\n<p>原因是，考虑下面这种代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Widget <span class=\"token operator\">*</span>pw <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Widget<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这行代码会发生两件事，一是调用 operator new 为 Widget 分配内存，然后调用 Widget 的默认构造函数，假设第二步调用抛出了一个异常，第一步的内存分配必须被撤销，否则就是一个内存泄漏。由于 clients 无法获取第一步分配的地址，因此撤销操作必须由 C++ runtime system 来完成。</p>\n<p>那么 C++ 会调用哪个 delete 函数来撤销呢，它会调用与这个 new 操作参数一致的 operator delete 来撤销，如果没有提供，它什么也不会做，那么就将发生内存泄漏。</p>\n<p>比如说：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span><span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t size<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> logStream<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里提供了一个 placement new </span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>pMemory<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>pMemory<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>ostream<span class=\"token operator\">&amp;</span> logStream<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 必须提供一个与 placement new 对应的 delete 函数</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>当你声明 new 和 delete 的 placement 版本时，确保不会无意中覆盖这些函数的常规版本。</strong></p>\n<p>item 33 讨论了继承体系中 name 被覆盖的场景和需要考虑的细节，new 和 delete 的编写也不例外。</p>\n<p>C++ 在全局提供如下形式的 operator new:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span><span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>bad_alloc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// normal new</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span><span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// placement new</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span><span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t<span class=\"token punctuation\">,</span>                             <span class=\"token comment\">// nothrow new —</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                   <span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>nothrow_t<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// see [Item 49]</span></pre></td></tr></table></figure><p>因此如果你在一个 class 中声明了任何 operator news，都将覆盖所有这些标准形式。<strong>除非你有意防止 class 的客户使用这些形式，否则，除了你创建的任何自定义 new 形式以外，还要确保它们都可以使用。</strong></p>\n</li>\n</ul>\n",
            "tags": [
                "C++ 读书笔记"
            ]
        },
        {
            "id": "http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/",
            "url": "http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/",
            "title": "C++：移动语义与右值引用",
            "date_published": "2022-11-14T08:08:33.000Z",
            "content_html": "<h1 id=\"c的移动语义与右值引用\"><a class=\"anchor\" href=\"#c的移动语义与右值引用\">#</a> C++ 的移动语义与右值引用</h1>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"preview.jpg\" alt=\"Gaze\"></p>\n<h2 id=\"移动语义\"><a class=\"anchor\" href=\"#移动语义\">#</a> 移动语义</h2>\n<h3 id=\"为何需要移动语义\"><a class=\"anchor\" href=\"#为何需要移动语义\">#</a> 为何需要移动语义</h3>\n<p>假设有如下代码：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; vstr;// build up a vector of 20000 strings,each of 1000 characters\nvector&lt;string&gt; vstr_copy1(vstr);\n</code></pre>\n<p>为了初始化 vstr_copy1 先调用 vector 的复制构造函数，使用 new 给 20000 个 string 对象分配内存，而每个 string 对象又调用 string 的复制构造函数，为 1000 个字符分配内存。这很浪费时间，但如果 vstr 与 vstr_copy1 都需要使用，这很难避免。</p>\n<p>可有时候这样不太妥当，例如 vstr 不再被使用时。例如如下定义的函数：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; allcaps(const vector&lt;string&gt; &amp; vs)\n&#123;\n    vector&lt;string&gt; temp;\n    //让temp存储vs中string的大写版本的代码\n    return temp;\n&#125;\n</code></pre>\n<p>并这样使用它：</p>\n<pre><code class=\"language-c++\">vector&lt;string&gt; vstr;\nvector&lt;string&gt; vstr_copy1(vstr); //#1\nvector&lt;string&gt; vstr_copy2(allcaps(vstr)); //#2\n</code></pre>\n<p>allcaps () 创建了对象 temp，该对象管理着 20000000 个字符；语句二使用 vector 和 string 的复制构造函数创建了一个 temp 的副本，然后删除了 temp，做了大量无用功。如果编译器直接把 temp 对数据的所有权转让给 vstr_copy2，将会更好。</p>\n<p>实际上，我们可以把实际内容保留在原来地方，而之修改记录，这就是移动语义的本质，它避免了移动原始数据，而转为修改记录。</p>\n<p>要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制。这就是右值引用发挥作用的地方。可定义两个构造函数，其中一个是常规复制构造函数，它使用 const 左值引用作为参数，如语句 #1。另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参，如语句 #2 中 allcaps (vstr) 的返回值。移动构造函数可能修改其实参，这意味着右值引用参数不应是 const。</p>\n<h3 id=\"如何使用\"><a class=\"anchor\" href=\"#如何使用\">#</a> 如何使用</h3>\n<p>直接将变量的值赋值为参数的变量值，如果变量为指针，为了防止 double free，还需将参数的指针改为 nullptr。</p>\n<p>例如：</p>\n<pre><code>Useless(Useless &amp;&amp; f) : n(f.n)\n&#123;\n\t++ct;\n\tpc = f.pc;\n\tf.pc = nullptr;\n\tf.n = 0;\n&#125;\n</code></pre>\n<h3 id=\"强制移动\"><a class=\"anchor\" href=\"#强制移动\">#</a> 强制移动</h3>\n<p>移动构造函数和移动赋值运算符使用右值，如果要让它们使用左值，该怎么办？例如，将一个左值变量赋值给一个对象，并立刻丢弃这个变量。此时可以使用头文件 utility 中声明的函数 std::move。</p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/",
            "url": "http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/",
            "title": "STL学习-01-智能指针与vector",
            "date_published": "2022-10-05T11:54:58.000Z",
            "content_html": "<h1 id=\"c-的标准模板库\"><a class=\"anchor\" href=\"#c-的标准模板库\">#</a> c++ 的标准模板库</h1>\n<p><span id=\"more\"></span></p>\n<p><img data-src=\"%E9%9B%A8%E5%A4%A9-%E5%A5%B3%E5%AD%A9-%E5%95%86%E5%BA%97.jpg\" alt=\"雨天 女孩 商店\"></p>\n<h2 id=\"智能指针模板类\"><a class=\"anchor\" href=\"#智能指针模板类\">#</a> 智能指针模板类</h2>\n<p>智能指针是类似于指针的类对象，比较方便内存管理。传统的指针必须时时刻刻记得 new 与 delete 的配套使用，很容易造成内存泄漏。而智能指针实际上类似于一个类，有自己的析构函数，所以编译器再不需要智能指针时便可以自动调用其析构函数释放内存，也就是可以略去 delete 操作。</p>\n<h3 id=\"使用智能指针\"><a class=\"anchor\" href=\"#使用智能指针\">#</a> 使用智能指针</h3>\n<p>要创建智能指针对象，必须包含头文件 memory 然后使用通常的模板语法来实例化所需类型的指针。</p>\n<p>声明：  <code> template &lt;class X&gt; class auto_ptr</code></p>\n<p>使用 eg：  <code> auto_ptr&lt;double&gt; pd(new double);</code></p>\n<p>​\t\t\t\t\t  <code>auto_ptr&lt;string&gt; ps(new string);</code></p>\n<p>注意： 智能指针模板位于名称空间 std 中。</p>\n<h3 id=\"有关智能指针的注意事项\"><a class=\"anchor\" href=\"#有关智能指针的注意事项\">#</a> 有关智能指针的注意事项</h3>\n<p>c++ 目前有三种常见智能指针：auto_ptr, unique_ptr,shared_ptr</p>\n<p>在使用智能指针时，可能会遇到问题，比如如果两个智能指针指向同一块内存区域，则程序会删除同一个对象两次，这是会造成极大错误的。为避免这种问题，方法有多种。</p>\n<ul>\n<li>建立所有权概念，对于特定对象，只有一个智能指针可以拥有他。 这是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 更严格</li>\n<li>创建智能更高的指针，跟踪引用特定对象的智能指针数，这称为引用计数。当最后一个指针过期时，才调用 delete。这是 shared_ptr 的策略</li>\n<li>执行深拷贝</li>\n</ul>\n<p>auto_ptr 和 unique_ptr 的区别：</p>\n<p>​\t\t两个 auto_ptr 指向同一块内存区域时，可以通过编译，但可能在运行时报错。两个 unique_ptr 指向同一块内存区域时，会在编译阶段就报错（除非赋值给其中一个 unique_ptr 的另一个 unique_ptr 是一个用完即毁的智能指针，如某一函数中 new 出来的 unique_ptr 的返回）。</p>\n<h2 id=\"模板类vector\"><a class=\"anchor\" href=\"#模板类vector\">#</a> 模板类 vector</h2>\n<h3 id=\"创建vector\"><a class=\"anchor\" href=\"#创建vector\">#</a> 创建 vector</h3>\n<p>要创建 vector 模板对象， 可使用通常的 &lt;type&gt; 表示法来指出要使用的类型。另外，vector 模板使用动态内存分配，因此可以用初始化参数指出需要多少元素。</p>\n<p><code> vector&lt;int&gt; ratings(5);  // a vector of 5 ints</code></p>\n<h3 id=\"可对vector执行的操作\"><a class=\"anchor\" href=\"#可对vector执行的操作\">#</a> 可对 vector 执行的操作</h3>\n<p>size ()—— 返回容器中元素数目        swap ()—— 交换两个容器的内容             begin ()—— 返回一个指向容器中第一个元素的 <em><strong>迭代器</strong></em>      end () 返回一个表示超过容器尾的<em><strong>迭代器</strong></em></p>\n<p>什么是迭代器？ 它是一个广义的指针，可以对其执行类似指针的操作，如解除引用 *、递增 ++</p>\n<p>STL 的每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，作用域为整个类。如要为 vector 的 double 类型规范声明一个迭代器，可以这样做：</p>\n<p>​\t <code>vector&lt;double&gt;::iterator pd;//  pd an iterator</code></p>\n<p>假设 scores 是一个 vector&lt;double&gt; 对象，可以利用好 auto 关键字简化书写：</p>\n<p><code>auto pd = scores.begin()</code></p>\n<p>vector 还支持 push_back () (内存不够会自动扩充容器), erase () insert () 等方法</p>\n<h3 id=\"其它操作\"><a class=\"anchor\" href=\"#其它操作\">#</a> 其它操作</h3>\n<p>有两个具有代表性的 STL 函数：for_each () 和 sort () 。</p>\n<p>for_each () 函数可用于很多容器类，它接受 3 个参数。前两个是定义容器中的迭代器，最后一个是一个函数指针。for_each () 函数将被指向的函数应用于容器区间中的各个元素，可以用 for_each () 函数来代替 for 循环。</p>\n<p>eg:  <code>for_each(books.begin(), books.end(), ShowReview);</code></p>\n<p>sort () 函数也要求函数支持随机访问。该函数接收两个定义区间的迭代器参数。如果容器中的元素有内置的 &lt; 运算符进行值比较，可以直接使用。如果容器中的元素是用户定义的类对象，则用户需要利用重载定义 &lt; 运算符。</p>\n<p>还有第二个版本的 sort () 函数，它接收第三个参数，该参数是一个函数指针，不一定是用于比较的 operator&lt;()，而是一个返回值可转换为 bool 类型的函数，它接收两个容器中的元素，返回为 false 表示两个参数的顺序不正确。</p>\n",
            "tags": [
                "STL C++"
            ]
        }
    ]
}