<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>MikeMao&#39;s blog • Posts by &#34;c++&#34; category</title>
    <link href="http://example.com" />
    <updated>2024-07-28T09:38:31.000Z</updated>
    <category term="C++" />
    <category term="git" />
    <category term="C++ 读书笔记" />
    <category term="Maven" />
    <category term="Linux" />
    <category term="STL C++" />
    <category term="python 爬虫 计算机网络" />
    <category term="python 爬虫" />
    <category term="go语言" />
    <category term="python" />
    <category term="爬虫" />
    <category term="分布式" />
    <category term="数理逻辑" />
    <category term="docker" />
    <category term="TVM 深度学习 机器学习 编译" />
    <category term="编译原理" />
    <entry>
        <id>http://example.com/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
        <title>Effective C++读书笔记</title>
        <link rel="alternate" href="http://example.com/2024/07/28/Effective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
        <content type="html">&lt;p&gt;C++ 是我最喜欢的一门语言，C++ programer 一直为其拥有的非同寻常的能力范围和表现力而自豪（当然如果能正确使用的话）。正如 Scott Meyers, 本书作者所言：学习一种编程语言的基础是一回事；学习如何用那种语言设计和实现高效率的程序完全是另外一回事。断断续续学习了两年的 C++ programing language, 我的追求从学会语言基础，逐渐变为追求更加高效，并同时具备高可扩展性和可维护性的编程。&lt;/p&gt;
&lt;p&gt;Effetive C++ 是一本主要面向 C++  03 标准及之前的 C++ 编程过程中的一些编程 guidelines 的，自 C++  11 以来，C++ 不断推陈出新，关于一些场景作者提出的解决方案也许有了更好的替代方案。但作为一切的基础，以及一系列书目的开山之作（more Efective C++, Effective Modern C++)，此书仍然被许多人认为是 CPP programer 进阶的必看书目。此读书笔记仅供我自己查阅，提供简单的总结与感想，以从作者引人入胜但对于已经认真体会的读者而言无益的行文中走出 (TLDR)。并对书中的一些问题尝试使用 C++ 11 后的新特性解决。&lt;/p&gt;
&lt;p&gt;我不想成为一个语言学家，阅读之后还需要更多的编程练习来巩固所学习的知识。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;杂项&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#杂项&#34;&gt;#&lt;/a&gt; 杂项&lt;/h2&gt;
&lt;h3 id=&#34;item1-将c视为-federation-of-languages语言联合体&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item1-将c视为-federation-of-languages语言联合体&#34;&gt;#&lt;/a&gt; item1 将 C++ 视为 federation of languages (语言联合体)&lt;/h3&gt;
&lt;p&gt;将 C++ 从一门编程语言看作四门互相联系但有各自主体思想的子语言的结合体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C: 包括 built-in 数据结构，流程控制语句等，提供语法基础。&lt;/li&gt;
&lt;li&gt;Object-Oriented C++：C++ 的面向对象部分，主要设计封装继承多态这三个方面&lt;/li&gt;
&lt;li&gt;Template C++：泛型编程部分，对多数程序员少用但及其强大的 C++ 语言部分，提供包括 TMP (模板元编程) 这样的黑魔法。&lt;/li&gt;
&lt;li&gt;STL：containers,iterators,algorithms,functions objects... 方便地使用大佬们提供的编程工具，优化编程体验，不用像 C 那样 array simulate everything 了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一种子语言都有一套自己常用的编程理念，在不同的子语言下编程时，可能会要从不同的规则中进行转换（比如传值的方式）。&lt;/p&gt;
&lt;h3 id=&#34;item2-用consts-enums和inlines-取代defines&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item2-用consts-enums和inlines-取代defines&#34;&gt;#&lt;/a&gt; item2 用 consts, enums, 和 inlines 取代 #defines&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;#defines 无法提供包括作用域控制，类型检查等功能，因此能避免就避免。一般只在控制编译逻辑的时候配合 #ifdef/#ifndef 使用，比如根据某些宏修改一些 objects 的定义，而不要用在编程的逻辑中。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想使用 #defines 定义常量时 比如 &lt;code&gt;#define PI 3.1415926&lt;/code&gt; ，使用 const 替代，以获取更好的编译器报错体验与类型检查&lt;/li&gt;
&lt;li&gt;想使用 #defines 定义&lt;strong&gt;类属常量&lt;/strong&gt;时，比如&lt;strong&gt;在类中&lt;/strong&gt;定义 &lt;code&gt;static const int a = 5;&lt;/code&gt;  这里涉及到了类属常量的初始化问题，简要来说，一些编译器禁止 static integral class constants（静态整型族类属常量）的 in-class specification 而不得不在类外使用 &lt;code&gt;const int MyClass::a = 5;&lt;/code&gt;  这样的初始化方式。（ps： 都是很老的编译器了，在作者那个年代都算过时的了，gcc4.0.4 都可以在类中定义整型族常量）。对于静态非整型族类属常量，比如 &lt;code&gt;static const string s = &amp;quot;hello&amp;quot;&lt;/code&gt; ，或者 &lt;code&gt;static const string s = nullptr&lt;/code&gt;  这样的语句是不允许出现在类的定义中的。你必须要在类外初始化。for example:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;MyClass&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; cst &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;// allowed&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; string s&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;// static const string s = &#34;hello&#34;? not allowed&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; p &lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;// static const int* p = nullter? not allowed&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; string MyClass&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;s &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;hello&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; MyClass&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;p &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;这个过程体现了 C++ 令人难以忍受的缺陷，对于很多东西，它具有很多的特例，并且你很难理解为什么，没有什么规则是通用的&lt;/strong&gt;。一个好消息是，C++ 17 后做出了补救 (又有新东西要记了)：&lt;/p&gt;
&lt;p&gt;according to &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU2Mzg5Ny9ob3ctY2FuLXlvdS1kZWZpbmUtYS1zdGF0aWMtZGF0YS1tZW1iZXItb2YtdHlwZS1jb25zdC1zdGRzdHJpbmc=&#34;&gt;c++ - How can you define a static data member of type const std::string? - Stack Overflow&lt;/span&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;MyClass&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; cst &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;constexpr&lt;/span&gt; std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;string_view STRING &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;some useful string constant&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; p &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;想使用 #defines 定义函数时，使用 inline 的模版函数替代，以获取函数参数具有的参数类型检查功能，并且拥有不输于 defines 的性能。还有，在使用 defines 定义函数时，你不得不给参数加括号 😃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对了 忘了提 enums 了，这里作者使用了一个叫做 the enum hack 的技术，主要来源于一个 enumerated type（枚举类型）的值可以用在一个需要 ints 的地方。for example:&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;GamePlayer&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; NumTurns &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;token comment&#34;&gt;// &#34;the enum hack&#34; - makes&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;                                     &lt;span class=&#34;token comment&#34;&gt;// NumTurns a symbolic name for 5&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; scores&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;NumTurns&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;              &lt;span class=&#34;token comment&#34;&gt;// fine&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;使用这项技术，你可以禁止对 NumTurns 的取地址行为，第二个理由是，大量的代码在使用它（作为模版元编程的基本技术之一），所以最好还是认识一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by the way, 当你声明一个常量指针的时候，最好别忘了把这个指针也设为 const。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;item3-只要可能就用const&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item3-只要可能就用const&#34;&gt;#&lt;/a&gt; item3 只要可能就用 const&lt;/h3&gt;
&lt;p&gt;use &lt;em&gt;const&lt;/em&gt; as long as possible, 经常看到的一句话了，这节内容主要分为三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;const 关键字提供了语义上的表达，有助于编译器发现错误。const 用途广泛，可用于对象，函数参数，返回类型，成员函数等。（这点为大部分程序员对此节标题的唯一理解）&lt;/li&gt;
&lt;li&gt;编译器坚持的是&lt;strong&gt; bitwise constness&lt;/strong&gt; (二进制位常量性), 但程序员应当使用&lt;strong&gt; conceptual constness&lt;/strong&gt; (概念上的常量性) 来编程。&lt;/li&gt;
&lt;li&gt;当 const 和 non-const 成员函数本质上具有相同的实现的时候，使用 non-const 版本调用 const 版本可以避免代码重复。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于第二点的理解：&lt;/p&gt;
&lt;p&gt;二进制位常量性是指当你声明一个变量为 const 的时候，编译器只需要检查它在内存中存储的二进制位有没有被更改就行了，因为这样实现十分方便，比如当你声明一个指针为 const 时候，你不能改变指针的值，但是你可以改变指针指向的对象的值。但是当你声明一个类为 const 的时候，只能调用 const 成员函数，并且不能改变其任何成员变量，这实在是太苛刻了。&lt;/p&gt;
&lt;p&gt;for example: 一个可以存储文本块长度的类：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;CTextBlock&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;size_t &lt;span class=&#34;token function&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;pText&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;size_t textLength&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;token comment&#34;&gt;// last calculated length of textblock&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;bool&lt;/span&gt; lengthIsValid&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                 &lt;span class=&#34;token comment&#34;&gt;// whether length is currently valid&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;size_t &lt;span class=&#34;token class-name&#34;&gt;CTextBlock&lt;/span&gt;&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!&lt;/span&gt;lengthIsValid&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    textLength &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;pText&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// error! can&#39;t assign to textLength&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    lengthIsValid &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;token comment&#34;&gt;// and lengthIsValid in a const&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;                                   &lt;span class=&#34;token comment&#34;&gt;// member function&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; textLength&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;对于 length () 成员函数，由于语义的需要必须定义为 const。但不想每次都调用 strlen 计算文本长度，这会带来许多开销，于是便用上述方法存储字符串长度。但是这违反了二进制常量性，毕竟改变了成员变量。&lt;/p&gt;
&lt;p&gt;因此引入了逻辑常量性的概念，这一理念认为，** 一个 const 成员函数可以改变对象中的一些 bits, 但是只能用客户无法察觉的方法。** 这种理念的实现是通过 mutable 关键字实现的，比如将上面的 textLength 和 lengthIsValid 变量用 mutable 修饰即可。&lt;/p&gt;
&lt;p&gt;对于第三点的理解：&lt;/p&gt;
&lt;p&gt;一般来说，类中重载的 const 成员函数和非 const 成员函数的逻辑都是差不多的，这带来了额外的编译时间，维护成本以及代码膨胀，这对于一些程序员来说是不可忍受的。因此可以使用这样一个 trick: 通过强制转型，让 non-const 成员函数调用 const 版本。for example:&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;TextBlock&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;size_t position&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt;     &lt;span class=&#34;token comment&#34;&gt;// same as before&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; text&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;position&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;std&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;size_t position&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;         &lt;span class=&#34;token comment&#34;&gt;// now just calls const op[]&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token generic-function&#34;&gt;&lt;span class=&#34;token function&#34;&gt;const_cast&lt;/span&gt;&lt;span class=&#34;token generic class-name&#34;&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;                         &lt;span class=&#34;token comment&#34;&gt;// cast away const on&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;                                                 &lt;span class=&#34;token comment&#34;&gt;// op[]&#39;s return type;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token generic-function&#34;&gt;&lt;span class=&#34;token function&#34;&gt;static_cast&lt;/span&gt;&lt;span class=&#34;token generic class-name&#34;&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; TextBlock&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;     &lt;span class=&#34;token comment&#34;&gt;// add const to *this&#39;s type;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;position&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;                             &lt;span class=&#34;token comment&#34;&gt;// call const version of op[]&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这样的代码通过不了选美比赛 😄 ，但是它有效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，反过来让 const 版本调用 non-const 版本不可取，因为违反了 const 的语义，你将承受改变成员变量的风险。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;item-4-确保对象在使用前被初始化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item-4-确保对象在使用前被初始化&#34;&gt;#&lt;/a&gt; item 4 确保对象在使用前被初始化&lt;/h3&gt;
&lt;p&gt;对于 C++ 的对象，当你不初始化它们时，有些时候它们会自动初始化，有时候不会，因此为了避免 ub，再声明的同时最好也初始化它们。&lt;/p&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;手动初始化 built-in type 的 objects，因为 C++ 只在某些时候才会自己初始化它们&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 constructor 中，用 member initialization list 代替函数体中的 assignment。initialization list 中 data members 的排列顺序要与它们在 class（类）中被声明的顺序相同。因为在构造函数赋值之前，成员变量已经被默认初始化好了，这样做能提升性能。除此之外的是，有些时候，初始化列表式可选项，有时候是必选项，因此为了方便记忆，一律使用初始化列表即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过用 local static objects（局部静态对象）代替 non-local static objects（非局部静态对象）来避免跨 translation units（编译单元）的 初始化顺序问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即将在全局中定义一个 &lt;code&gt;static FileSystem fs; &lt;/code&gt;  替换为提供一个函数，有点像单例模式：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;FileSystem&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;tfs&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;                   &lt;span class=&#34;token comment&#34;&gt;// this replaces the tfs object; it could be&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;                                   &lt;span class=&#34;token comment&#34;&gt;// static in the FileSystem class&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; FileSystem fs&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;token comment&#34;&gt;// define and initialize a local static object&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; fs&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                        &lt;span class=&#34;token comment&#34;&gt;// return a reference to it&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;构造-析构与赋值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#构造-析构与赋值&#34;&gt;#&lt;/a&gt; 构造、析构与赋值&lt;/h2&gt;
&lt;h3 id=&#34;item5-了解c为你默认编写并调用了哪些函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item5-了解c为你默认编写并调用了哪些函数&#34;&gt;#&lt;/a&gt; item5 了解 C++ 为你默认编写并调用了哪些函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编译器可以隐式生成一个 class（类）的 default constructor（缺省构造函数），copy constructor（拷贝构造函数），copy assignment operator（拷贝赋值运算符）和 destructor（析构函数）。C++11 后还增加了移动构造和移动赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于以下场景：深拷贝，类中有 const 或引用成员变量，以及析构函数有 virtual 需求的时候，默认生成的函数可能不会符合要求&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;item6-若不想使用编译器生成函数就明确拒绝&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item6-若不想使用编译器生成函数就明确拒绝&#34;&gt;#&lt;/a&gt; item6 若不想使用编译器生成函数，就明确拒绝&lt;/h3&gt;
&lt;p&gt;在 C++ 11 之前，作者是通过将相应的成员函数声明为 private 实现的，或者继承自一个使用这种方法实现的 Uncopyable 的基类。&lt;/p&gt;
&lt;p&gt;C++ 11 之后，使用 &lt;code&gt;= delete&lt;/code&gt;  即可&lt;/p&gt;
&lt;h3 id=&#34;item7-为多态基类声明虚析构函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item7-为多态基类声明虚析构函数&#34;&gt;#&lt;/a&gt; item7 为多态基类声明虚析构函数&lt;/h3&gt;
&lt;p&gt;为了防止内存泄露，必须将多态基类的析构函数声明为虚函数&lt;/p&gt;
&lt;p&gt;除此之外还要注意两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价&lt;/li&gt;
&lt;li&gt;如果一个类型没有被设计成多态基类，又有被误继承的风险，可以使用 C++ 11 中的 &lt;code&gt;final&lt;/code&gt;  关键字，这样禁止派生可以防止误继承造成上述问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;item8-防止异常逃离析构函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item8-防止异常逃离析构函数&#34;&gt;#&lt;/a&gt; item8 防止异常逃离析构函数&lt;/h3&gt;
&lt;p&gt;两个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后&lt;strong&gt;抑制它们或者终止程序&lt;/strong&gt;。这里的抑制指的是在 try catch 语句中捕获并处理。&lt;/li&gt;
&lt;li&gt;如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于第二点，一个常见例子是使用各种 db 的连接池的场景，通常用户需要使用 db.close () 显式释放资源，对于拥有 RAII 机制的 C++ 来说，为什么还需要这样做呢。因为通过 db.close () 这样的普通成员函数，用户可以通过 try catch 语句自行对这个异常做出回应。在析构函数中，同样可以继续使用 RAII 机制，记录用户有无手动释放，没有则自行调用 db.close ()&lt;/p&gt;
&lt;h3 id=&#34;item9-避免在构造函数或者析构函数中调用虚函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item9-避免在构造函数或者析构函数中调用虚函数&#34;&gt;#&lt;/a&gt; item9 避免在构造函数或者析构函数中调用虚函数&lt;/h3&gt;
&lt;p&gt;简单来说，在构造和析构的时候，对象的类型是不确定的，因此想要调用的虚函数可能不会如你所愿。可以这样理解，再析构和构造函数中虚函数表的构造和析构的时机是不确定的，因此调用虚函数会存在问题。&lt;/p&gt;
&lt;p&gt;这点看似简单，却十分容易踩坑，考虑以下场景，为了避免重复代码，我们可能将不同的变量初始化放到一个 init () 函数之中，即使这个函数不是虚函数，但如果其中调用了虚函数，还是违背了这一原则，并且以难以察觉的方式。&lt;/p&gt;
&lt;h3 id=&#34;item10-在赋值运算符中返回一个reference-to-this&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item10-在赋值运算符中返回一个reference-to-this&#34;&gt;#&lt;/a&gt; item10 在赋值运算符中返回一个 reference to *this&lt;/h3&gt;
&lt;p&gt;简单来说 这样做是为了支持链式赋值并让自己的接口和内置类型的接口尽可能相似。因此，请将赋值操作符的返回类型设为 ObjectClass&amp;amp; 并返回 * this。&lt;/p&gt;
&lt;h3 id=&#34;item11-在赋值运算符中处理自赋值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item11-在赋值运算符中处理自赋值&#34;&gt;#&lt;/a&gt; item11 在赋值运算符中处理自赋值&lt;/h3&gt;
&lt;p&gt;当给一个对象赋值时，一般来说，这个对象需要释放现有资源，然后通过赋值获取新资源，这个逻辑在处理自我赋值的时候会失效，因为释放的资源可能永远找不到了。&lt;/p&gt;
&lt;p&gt;解决这个问题的一个方案是，通过特判处理自赋值情况，很简单也常见的一种思路如下：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;SomeClass&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt; SomeClass&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; SomeClass&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt; rhs&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;rhs&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;delete&lt;/span&gt; ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  ptr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;DataBlock&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;rhs&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;ptr&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;token comment&#34;&gt;// 如果此处抛出异常，ptr 将指向一块已经被删除的内存。&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;首先这种方案的一个问题是：当释放已有资源后，获取新资源的过程可能发生异常，此时指针会指向被释放的资源，导致后续程序出错。&lt;/p&gt;
&lt;p&gt;解决的思路也很简单，即先获取新的资源，然后再释放原有的资源：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;SomeClass&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt; SomeClass&lt;span class=&#34;token double-colon punctuation&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; SomeClass&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt; rhs&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  DataBlock&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; pOrg &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  ptr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;DataBlock&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;rhs&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;ptr&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;token comment&#34;&gt;// 如果此处抛出异常，ptr 仍然指向之前的内存。&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;delete&lt;/span&gt; pOrg&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;同样，这种方案也不用特判是否是自赋值语句了，还有一点好处是，通过减少 if 语句，可能会对指令流水线的工作有益。&lt;/p&gt;
&lt;p&gt;还有一种方案是使用 copy-and-swap 方法，不过本人感觉性能可能会稍低，因此不作讨论。&lt;/p&gt;
&lt;h3 id=&#34;item12-拷贝一个对象的所有组成成分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item12-拷贝一个对象的所有组成成分&#34;&gt;#&lt;/a&gt; item12 拷贝一个对象的所有组成成分&lt;/h3&gt;
&lt;p&gt;即时刻注意以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为类增加成员时，别忘了更改拷贝相关的函数中的逻辑&lt;/li&gt;
&lt;li&gt;在继承的场景下，子类需要并且必须通过调用父类的拷贝构造或拷贝赋值来进行父类成员的拷贝。&lt;/li&gt;
&lt;li&gt;拷贝构造和拷贝赋值不能互相调用，如果想减少代码重复，就将通用功能放入一个第三方的函数中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;资源管理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#资源管理&#34;&gt;#&lt;/a&gt; 资源管理&lt;/h2&gt;
&lt;h3 id=&#34;item13-使用对象管理资源&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item13-使用对象管理资源&#34;&gt;#&lt;/a&gt; item13 使用对象管理资源&lt;/h3&gt;
&lt;p&gt;经典的 RAII 思想，即利用析构函数退出作用域自动调用的特点处理资源的释放。&lt;/p&gt;
&lt;p&gt;C++11 后有了智能指针，因此 RAII 的实践已经很简单了。没想到那时候的智能指针已经存在于 tr1 库里了😄&lt;/p&gt;
&lt;h3 id=&#34;item14-谨慎考虑资源管理类的拷贝行为&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item14-谨慎考虑资源管理类的拷贝行为&#34;&gt;#&lt;/a&gt; item14 谨慎考虑资源管理类的拷贝行为&lt;/h3&gt;
&lt;p&gt;即需要考虑在不同情况下是否要禁止或以其他方式控制对资源的拷贝。&lt;/p&gt;
&lt;p&gt;C++11 后有了 shared_ptr 和 unique_ptr 后，应该能应付各种场景了。&lt;/p&gt;
&lt;h3 id=&#34;item15-在资源管理类中准备访问裸资源raw-resources&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item15-在资源管理类中准备访问裸资源raw-resources&#34;&gt;#&lt;/a&gt; item15 在资源管理类中准备访问裸资源（raw resources）&lt;/h3&gt;
&lt;p&gt;在智能指针中，可以发现，它们提供了 get () 方法获取保管的资源。为什么？&lt;/p&gt;
&lt;p&gt;因为很多 API 的参数中，是和资源本身打交道的，因此一个 RAII 资源管理类需要提供访问裸资源的接口。&lt;/p&gt;
&lt;p&gt;一个疑问是，这样是否违反了封装性？答案是不会，因为 RAII 只是为了保证资源释放这个行为的发生，封装不是其存在的目的。同时，如果你提供隐式转换，可能会导致一些预期之外的错误，因此资源管理类仅提供显示转换是最合理的。&lt;/p&gt;
&lt;h3 id=&#34;item16-使用相同形式的new和delete&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item16-使用相同形式的new和delete&#34;&gt;#&lt;/a&gt; item16 使用相同形式的 new 和 delete&lt;/h3&gt;
&lt;p&gt;即 new 和 delete，new [] 和 delete [] 搭配使用&lt;/p&gt;
&lt;h3 id=&#34;item17-在一个独立的语句中将new出来的对象存入智能指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item17-在一个独立的语句中将new出来的对象存入智能指针&#34;&gt;#&lt;/a&gt; item17 在一个独立的语句中将 new 出来的对象存入智能指针&lt;/h3&gt;
&lt;p&gt;此条是为了防止非常微妙的内存泄漏，这种 bug 发生概率很小，但一旦出现很难被解决。&lt;/p&gt;
&lt;p&gt;对于这样的两个函数：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;priority&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;processWidget&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;share_ptr&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;Widget&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; sp&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; priority&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;一个简洁的调用方法是：&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;processWidget&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token generic-function&#34;&gt;&lt;span class=&#34;token function&#34;&gt;share_ptr&lt;/span&gt;&lt;span class=&#34;token generic class-name&#34;&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;widget&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;priority&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;但这个语句的一大特点是，可能变为这样的执行顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;执行 &amp;quot;new Widget&amp;quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 priority。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 shared_ptr 的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当在第二点中发生了异常，第一点的 new Widget () 构造的类可能就会发生内存泄漏。&lt;/p&gt;
&lt;p&gt;避免类似问题的方法很简单：用一个单独的语句创建 Widget 并将它存入一个智能指针，然后将这个智能指针传递给 processWidget&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;shared_ptr&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;Widget&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;pw&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// store newed object&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;                                      &lt;span class=&#34;token comment&#34;&gt;// in a smart pointer in a&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;									  &lt;span class=&#34;token comment&#34;&gt;// standalone statement&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;processWidget&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;pw&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;priority&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;token comment&#34;&gt;// this call won&#39;t leak&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这样做是因为编译器在不同的语句之间重新安排操作顺序的活动余地比在一个语句之内要小得多&lt;/p&gt;
&lt;h2 id=&#34;设计与声明&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#设计与声明&#34;&gt;#&lt;/a&gt; 设计与声明&lt;/h2&gt;
&lt;h3 id=&#34;item18-让接口容易被正确使用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item18-让接口容易被正确使用&#34;&gt;#&lt;/a&gt; item18 让接口容易被正确使用&lt;/h3&gt;
&lt;p&gt;本条款讨论如何&lt;strong&gt;帮助你的客户在使用你的接口时避免他们犯错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在设计接口时，我们常常会错误地假设，接口的调用者&lt;strong&gt;拥有某些必要的知识来规避一些常识性的错误&lt;/strong&gt;。但事实上，接口的调用者并不总是像正在设计接口的我们一样 “聪明” 或者知道接口实现的” 内幕信息 “，结果就是，我们错误的假设使接口表现得不稳定。这些不稳定因素可能是由于调用者缺乏某些先验知识，也有可能仅仅是代码上的粗心错误。接口的调用者可能是别人，也可能是未来的你。所以一个合理的接口，应该尽可能的从&lt;strong&gt;语法层面&lt;/strong&gt;并在&lt;strong&gt;编译之时运行之前&lt;/strong&gt;，帮助接口的调用者规避可能的风险。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;外覆类型（wrapper）&lt;strong&gt;提醒调用者传参错误检查，将参数的附加条件限制在&lt;/strong&gt;类型本身&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当调用者试图传入数字 “13” 来表达一个 “月份” 的时候，你可以在函数内部做运行期的检查，然后提出报警或一个异常，但这样的做法更像是一种责任转嫁 —— 调用者只有在尝试过后才发现自己手残把 “12” 写成了 “13”。如果在设计参数类型时就把 “月份” 这一类型抽象出来，比如使用 enum class（强枚举类型），就能帮助客户在编译时期就发现问题，把参数的附加条件限制在类型本身，可以让接口更易用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;语法层面&lt;/strong&gt;限制调用者&lt;strong&gt;不能做的事&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口的调用者往往无意甚至没有意识到自己犯了个错误，所以接口的设计者必须在语法层面做出限制。一个比较常见的限制是加上 &lt;code&gt;const&lt;/code&gt; ，比如在 &lt;code&gt;operate*&lt;/code&gt;  的返回类型上加上 &lt;code&gt;const&lt;/code&gt;  修饰，可以防止无意错误的赋值 &lt;code&gt;if (a * b = c)&lt;/code&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口应表现出与内置类型的一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让自己的类型和内置类型的一致性，比如自定义容器的接口在命名上和 STL 应具备一致性，可以有效防止调用者犯错误。或者你有两个对象相乘的需求，那么你最好重载 &lt;code&gt;operator*&lt;/code&gt;  而并非设计名为”multiply” 的成员函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从语法层面限制调用者&lt;strong&gt;必须做的事&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;别让接口的调用者总是记得做某些事情&lt;/strong&gt;，接口的设计者应在假定他们&lt;strong&gt;总是忘记&lt;/strong&gt;这些条条框框的前提下设计接口。比如用智能指针代替原生指针就是为调用者着想的好例子。如果一个核心方法需要在使用前后设置和恢复环境（比如获取锁和归还锁），更好的做法是将设置和恢复环境设置成纯虚函数并要求调用者继承该抽象类，强制他们去实现。在核心方法前后对设置和恢复环境的调用，则应由接口设计者操心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当方法的调用者（我们的客户）责任越少，他们可能犯的错误也就越少。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;item19-将class的设计当成设计一个type&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item19-将class的设计当成设计一个type&#34;&gt;#&lt;/a&gt; item19 将 class 的设计当成设计一个 type&lt;/h3&gt;
&lt;p&gt;本条款提醒我们设计 class 需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象该如何创建销毁：包括构造函数、析构函数以及 new 和 delete 操作符的重构需求。&lt;/li&gt;
&lt;li&gt;对象的初始化与赋值行为应有何区别。&lt;/li&gt;
&lt;li&gt;对象被拷贝时应考虑的行为：拷贝构造函数。&lt;/li&gt;
&lt;li&gt;对象的合法值是什么？在成员函数内部对参数做合法性检查。&lt;/li&gt;
&lt;li&gt;新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题。&lt;/li&gt;
&lt;li&gt;新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非 explicit 函数之间的取舍。&lt;/li&gt;
&lt;li&gt;新类型是否需要重载操作符。&lt;/li&gt;
&lt;li&gt;什么样的接口应当暴露在外，而什么样的接口应当封装在内（public 和 private）&lt;/li&gt;
&lt;li&gt;新类型的效率、资源获取归还、线程安全性和异常安全性如何保证。&lt;/li&gt;
&lt;li&gt;这个类是否具备 template 的潜质，如果有的话，就应改为模板类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;item20-尽量使用pass-by-reference-to-const替换pass-by-value&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#item20-尽量使用pass-by-reference-to-const替换pass-by-value&#34;&gt;#&lt;/a&gt; item20 尽量使用 pass-by-reference-to-const 替换 pass-by-value&lt;/h3&gt;
&lt;p&gt;值传参的问题有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按值传参涉及大量参数的复制，这些副本大多是没有必要的。&lt;/li&gt;
&lt;li&gt;如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管如此，面对内置类型和 STL 的迭代器与函数对象，我们通常还是会选择按值传参的方式设计接口。因为，对于内置类型和迭代器，它们往往很小，值传递开销低，有时甚至胜过引用。至于函数对象，值传递主要解决多线程中的同步问题。&lt;/p&gt;
</content>
        <category term="C++ 读书笔记" />
        <updated>2024-07-28T09:38:31.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
        <title>C++：移动语义与右值引用</title>
        <link rel="alternate" href="http://example.com/2022/11/14/C-%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
        <content type="html">&lt;h1 id=&#34;c的移动语义与右值引用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c的移动语义与右值引用&#34;&gt;#&lt;/a&gt; C++ 的移动语义与右值引用&lt;/h1&gt;
&lt;p&gt;&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;preview.jpg&#34; alt=&#34;Gaze&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;移动语义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#移动语义&#34;&gt;#&lt;/a&gt; 移动语义&lt;/h2&gt;
&lt;h3 id=&#34;为何需要移动语义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#为何需要移动语义&#34;&gt;#&lt;/a&gt; 为何需要移动语义&lt;/h3&gt;
&lt;p&gt;假设有如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;string&amp;gt; vstr;// build up a vector of 20000 strings,each of 1000 characters
vector&amp;lt;string&amp;gt; vstr_copy1(vstr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了初始化 vstr_copy1 先调用 vector 的复制构造函数，使用 new 给 20000 个 string 对象分配内存，而每个 string 对象又调用 string 的复制构造函数，为 1000 个字符分配内存。这很浪费时间，但如果 vstr 与 vstr_copy1 都需要使用，这很难避免。&lt;/p&gt;
&lt;p&gt;可有时候这样不太妥当，例如 vstr 不再被使用时。例如如下定义的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;string&amp;gt; allcaps(const vector&amp;lt;string&amp;gt; &amp;amp; vs)
&amp;#123;
    vector&amp;lt;string&amp;gt; temp;
    //让temp存储vs中string的大写版本的代码
    return temp;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并这样使用它：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;string&amp;gt; vstr;
vector&amp;lt;string&amp;gt; vstr_copy1(vstr); //#1
vector&amp;lt;string&amp;gt; vstr_copy2(allcaps(vstr)); //#2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;allcaps () 创建了对象 temp，该对象管理着 20000000 个字符；语句二使用 vector 和 string 的复制构造函数创建了一个 temp 的副本，然后删除了 temp，做了大量无用功。如果编译器直接把 temp 对数据的所有权转让给 vstr_copy2，将会更好。&lt;/p&gt;
&lt;p&gt;实际上，我们可以把实际内容保留在原来地方，而之修改记录，这就是移动语义的本质，它避免了移动原始数据，而转为修改记录。&lt;/p&gt;
&lt;p&gt;要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制。这就是右值引用发挥作用的地方。可定义两个构造函数，其中一个是常规复制构造函数，它使用 const 左值引用作为参数，如语句 #1。另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参，如语句 #2 中 allcaps (vstr) 的返回值。移动构造函数可能修改其实参，这意味着右值引用参数不应是 const。&lt;/p&gt;
&lt;h3 id=&#34;如何使用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#如何使用&#34;&gt;#&lt;/a&gt; 如何使用&lt;/h3&gt;
&lt;p&gt;直接将变量的值赋值为参数的变量值，如果变量为指针，为了防止 double free，还需将参数的指针改为 nullptr。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Useless(Useless &amp;amp;&amp;amp; f) : n(f.n)
&amp;#123;
	++ct;
	pc = f.pc;
	f.pc = nullptr;
	f.n = 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;强制移动&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#强制移动&#34;&gt;#&lt;/a&gt; 强制移动&lt;/h3&gt;
&lt;p&gt;移动构造函数和移动赋值运算符使用右值，如果要让它们使用左值，该怎么办？例如，将一个左值变量赋值给一个对象，并立刻丢弃这个变量。此时可以使用头文件 utility 中声明的函数 std::move。&lt;/p&gt;
</content>
        <category term="C++" />
        <updated>2022-11-14T08:08:33.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/</id>
        <title>STL学习-01-智能指针与vector</title>
        <link rel="alternate" href="http://example.com/2022/10/05/STL%E5%AD%A6%E4%B9%A0-01-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8Evector/"/>
        <content type="html">&lt;h1 id=&#34;c-的标准模板库&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c-的标准模板库&#34;&gt;#&lt;/a&gt; c++ 的标准模板库&lt;/h1&gt;
&lt;p&gt;&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E9%9B%A8%E5%A4%A9-%E5%A5%B3%E5%AD%A9-%E5%95%86%E5%BA%97.jpg&#34; alt=&#34;雨天 女孩 商店&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;智能指针模板类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#智能指针模板类&#34;&gt;#&lt;/a&gt; 智能指针模板类&lt;/h2&gt;
&lt;p&gt;智能指针是类似于指针的类对象，比较方便内存管理。传统的指针必须时时刻刻记得 new 与 delete 的配套使用，很容易造成内存泄漏。而智能指针实际上类似于一个类，有自己的析构函数，所以编译器再不需要智能指针时便可以自动调用其析构函数释放内存，也就是可以略去 delete 操作。&lt;/p&gt;
&lt;h3 id=&#34;使用智能指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用智能指针&#34;&gt;#&lt;/a&gt; 使用智能指针&lt;/h3&gt;
&lt;p&gt;要创建智能指针对象，必须包含头文件 memory 然后使用通常的模板语法来实例化所需类型的指针。&lt;/p&gt;
&lt;p&gt;声明：  &lt;code&gt; template &amp;lt;class X&amp;gt; class auto_ptr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用 eg：  &lt;code&gt; auto_ptr&amp;lt;double&amp;gt; pd(new double);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​					  &lt;code&gt;auto_ptr&amp;lt;string&amp;gt; ps(new string);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意： 智能指针模板位于名称空间 std 中。&lt;/p&gt;
&lt;h3 id=&#34;有关智能指针的注意事项&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#有关智能指针的注意事项&#34;&gt;#&lt;/a&gt; 有关智能指针的注意事项&lt;/h3&gt;
&lt;p&gt;c++ 目前有三种常见智能指针：auto_ptr, unique_ptr,shared_ptr&lt;/p&gt;
&lt;p&gt;在使用智能指针时，可能会遇到问题，比如如果两个智能指针指向同一块内存区域，则程序会删除同一个对象两次，这是会造成极大错误的。为避免这种问题，方法有多种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立所有权概念，对于特定对象，只有一个智能指针可以拥有他。 这是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 更严格&lt;/li&gt;
&lt;li&gt;创建智能更高的指针，跟踪引用特定对象的智能指针数，这称为引用计数。当最后一个指针过期时，才调用 delete。这是 shared_ptr 的策略&lt;/li&gt;
&lt;li&gt;执行深拷贝&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;auto_ptr 和 unique_ptr 的区别：&lt;/p&gt;
&lt;p&gt;​		两个 auto_ptr 指向同一块内存区域时，可以通过编译，但可能在运行时报错。两个 unique_ptr 指向同一块内存区域时，会在编译阶段就报错（除非赋值给其中一个 unique_ptr 的另一个 unique_ptr 是一个用完即毁的智能指针，如某一函数中 new 出来的 unique_ptr 的返回）。&lt;/p&gt;
&lt;h2 id=&#34;模板类vector&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模板类vector&#34;&gt;#&lt;/a&gt; 模板类 vector&lt;/h2&gt;
&lt;h3 id=&#34;创建vector&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建vector&#34;&gt;#&lt;/a&gt; 创建 vector&lt;/h3&gt;
&lt;p&gt;要创建 vector 模板对象， 可使用通常的 &amp;lt;type&amp;gt; 表示法来指出要使用的类型。另外，vector 模板使用动态内存分配，因此可以用初始化参数指出需要多少元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt; vector&amp;lt;int&amp;gt; ratings(5);  // a vector of 5 ints&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;可对vector执行的操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#可对vector执行的操作&#34;&gt;#&lt;/a&gt; 可对 vector 执行的操作&lt;/h3&gt;
&lt;p&gt;size ()—— 返回容器中元素数目        swap ()—— 交换两个容器的内容             begin ()—— 返回一个指向容器中第一个元素的 &lt;em&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/em&gt;      end () 返回一个表示超过容器尾的&lt;em&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;什么是迭代器？ 它是一个广义的指针，可以对其执行类似指针的操作，如解除引用 *、递增 ++&lt;/p&gt;
&lt;p&gt;STL 的每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，作用域为整个类。如要为 vector 的 double 类型规范声明一个迭代器，可以这样做：&lt;/p&gt;
&lt;p&gt;​	 &lt;code&gt;vector&amp;lt;double&amp;gt;::iterator pd;//  pd an iterator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;假设 scores 是一个 vector&amp;lt;double&amp;gt; 对象，可以利用好 auto 关键字简化书写：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto pd = scores.begin()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;vector 还支持 push_back () (内存不够会自动扩充容器), erase () insert () 等方法&lt;/p&gt;
&lt;h3 id=&#34;其它操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其它操作&#34;&gt;#&lt;/a&gt; 其它操作&lt;/h3&gt;
&lt;p&gt;有两个具有代表性的 STL 函数：for_each () 和 sort () 。&lt;/p&gt;
&lt;p&gt;for_each () 函数可用于很多容器类，它接受 3 个参数。前两个是定义容器中的迭代器，最后一个是一个函数指针。for_each () 函数将被指向的函数应用于容器区间中的各个元素，可以用 for_each () 函数来代替 for 循环。&lt;/p&gt;
&lt;p&gt;eg:  &lt;code&gt;for_each(books.begin(), books.end(), ShowReview);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sort () 函数也要求函数支持随机访问。该函数接收两个定义区间的迭代器参数。如果容器中的元素有内置的 &amp;lt; 运算符进行值比较，可以直接使用。如果容器中的元素是用户定义的类对象，则用户需要利用重载定义 &amp;lt; 运算符。&lt;/p&gt;
&lt;p&gt;还有第二个版本的 sort () 函数，它接收第三个参数，该参数是一个函数指针，不一定是用于比较的 operator&amp;lt;()，而是一个返回值可转换为 bool 类型的函数，它接收两个容器中的元素，返回为 false 表示两个参数的顺序不正确。&lt;/p&gt;
</content>
        <category term="STL C++" />
        <updated>2022-10-05T11:54:58.000Z</updated>
    </entry>
</feed>
